
module Control.Applicative where
  (*>) :: Applicative f => f a -> f b -> f b
  (<$) :: GHC.Base.Functor f => a -> f b -> f a
  (<$>) :: GHC.Base.Functor f => (a -> b) -> f a -> f b
  (<*) :: Applicative f => f a -> f b -> f a
  (<**>) :: Applicative f => f a -> f (a -> b) -> f b
  (<*>) :: Applicative f => f (a -> b) -> f a -> f b
  (<|>) :: Alternative f => f a -> f a -> f a
  type Alternative :: (* -> *) -> Constraint
  class Applicative f => Alternative f
    ...
  type Applicative :: (* -> *) -> Constraint
  class GHC.Base.Functor f => Applicative f
    ...
  Const :: forall {k} a (b :: k). a -> Const a b
  type role Const representational phantom
  type Const :: forall {k}. * -> k -> *
  newtype Const a b = ...
  WrapArrow :: a b c -> WrappedArrow a b c
  WrapMonad :: m a -> WrappedMonad m a
  type role WrappedArrow representational nominal nominal
  type WrappedArrow :: (* -> * -> *) -> * -> * -> *
  newtype WrappedArrow a b c = ...
  type role WrappedMonad representational nominal
  type WrappedMonad :: (* -> *) -> * -> *
  newtype WrappedMonad m a = ...
  ZipList :: [a] -> ZipList a
  type ZipList :: * -> *
  newtype ZipList a = ...
  asum :: (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
  empty :: Alternative f => f a
  getConst :: forall {k} a (b :: k). Const a b -> a
  getZipList :: ZipList a -> [a]
  liftA :: Applicative f => (a -> b) -> f a -> f b
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  many :: Alternative f => f a -> f [a]
  optional :: Alternative f => f a -> f (GHC.Maybe.Maybe a)
  pure :: Applicative f => a -> f a
  some :: Alternative f => f a -> f [a]
  unwrapArrow :: WrappedArrow a b c -> a b c
  unwrapMonad :: WrappedMonad m a -> m a

module Control.Arrow where
  (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
  (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
  (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
  (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
  (<<<) :: forall {k} (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Control.Category.Category cat => cat b c -> cat a b -> cat a c
  (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
  (>>>) :: forall {k} (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Control.Category.Category cat => cat a b -> cat b c -> cat a c
  (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
  type Arrow :: (* -> * -> *) -> Constraint
  class Control.Category.Category a => Arrow a
    ...
  type ArrowApply :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowApply a
    ...
  type ArrowChoice :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowChoice a
    ...
  type ArrowLoop :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowLoop a
    ...
  ArrowMonad :: a () b -> ArrowMonad a b
  type role ArrowMonad representational nominal
  type ArrowMonad :: (* -> * -> *) -> * -> *
  newtype ArrowMonad a b = ...
  type ArrowPlus :: (* -> * -> *) -> Constraint
  class ArrowZero a => ArrowPlus a
    ...
  type ArrowZero :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowZero a
    ...
  Kleisli :: (a -> m b) -> Kleisli m a b
  type role Kleisli representational representational nominal
  type Kleisli :: (* -> *) -> * -> * -> *
  newtype Kleisli m a b = ...
  (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
  (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
  app :: ArrowApply a => a (a b c, b) c
  arr :: Arrow a => (b -> c) -> a b c
  first :: Arrow a => a b c -> a (b, d) (c, d)
  left :: ArrowChoice a => a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
  leftApp :: ArrowApply a => a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
  loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
  returnA :: Arrow a => a b b
  right :: ArrowChoice a => a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
  runKleisli :: Kleisli m a b -> a -> m b
  second :: Arrow a => a b c -> a (d, b) (d, c)
  zeroArrow :: ArrowZero a => a b c
  (|||) :: ArrowChoice a => a b d -> a c d -> a (Data.Either.Either b c) d

module Control.Category where
  (.) :: forall {k} (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
  (<<<) :: forall {k} (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
  (>>>) :: forall {k} (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
  type Category :: forall {k}. (k -> k -> *) -> Constraint
  class Category cat
    ...
  id :: forall {k} (cat :: k -> k -> *) (a :: k). Category cat => cat a a

module Control.Concurrent where
  type Chan :: * -> *
  data Chan a = ...
  type MVar :: * -> *
  data MVar a = ...
  type QSem :: *
  newtype QSem = ...
  type QSemN :: *
  data QSemN = ...
  type ThreadId :: *
  data ThreadId = ...
  addMVarFinalizer :: MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  dupChan :: Chan a -> GHC.Types.IO (Chan a)
  forkFinally :: GHC.Types.IO a -> (Data.Either.Either GHC.Exception.Type.SomeException a -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOS :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOSWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  getChanContents :: Chan a -> GHC.Types.IO [a]
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  isCurrentThreadBound :: GHC.Types.IO GHC.Types.Bool
  isEmptyMVar :: MVar a -> GHC.Types.IO GHC.Types.Bool
  killThread :: ThreadId -> GHC.Types.IO ()
  mkWeakMVar :: MVar a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (MVar a))
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  modifyMVar :: MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked :: MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked_ :: MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  modifyMVar_ :: MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  myThreadId :: GHC.Types.IO ThreadId
  newChan :: GHC.Types.IO (Chan a)
  newEmptyMVar :: GHC.Types.IO (MVar a)
  newMVar :: a -> GHC.Types.IO (MVar a)
  newQSem :: GHC.Types.Int -> GHC.Types.IO QSem
  newQSemN :: GHC.Types.Int -> GHC.Types.IO QSemN
  putMVar :: MVar a -> a -> GHC.Types.IO ()
  readChan :: Chan a -> GHC.Types.IO a
  readMVar :: MVar a -> GHC.Types.IO a
  rtsSupportsBoundThreads :: GHC.Types.Bool
  runInBoundThread :: GHC.Types.IO a -> GHC.Types.IO a
  runInUnboundThread :: GHC.Types.IO a -> GHC.Types.IO a
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  signalQSem :: QSem -> GHC.Types.IO ()
  signalQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  swapMVar :: MVar a -> a -> GHC.Types.IO a
  takeMVar :: MVar a -> GHC.Types.IO a
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadDelay :: GHC.Types.Int -> GHC.Types.IO ()
  threadWaitRead :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitReadSTM :: System.Posix.Types.Fd -> GHC.Types.IO (GHC.Conc.Sync.STM (), GHC.Types.IO ())
  threadWaitWrite :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitWriteSTM :: System.Posix.Types.Fd -> GHC.Types.IO (GHC.Conc.Sync.STM (), GHC.Types.IO ())
  throwTo :: GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  tryPutMVar :: MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  waitQSem :: QSem -> GHC.Types.IO ()
  waitQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  withMVar :: MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMVarMasked :: MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeChan :: Chan a -> a -> GHC.Types.IO ()
  writeList2Chan :: Chan a -> [a] -> GHC.Types.IO ()
  yield :: GHC.Types.IO ()

module Control.Concurrent.Chan where
  type Chan :: * -> *
  data Chan a = ...
  dupChan :: Chan a -> GHC.Types.IO (Chan a)
  getChanContents :: Chan a -> GHC.Types.IO [a]
  newChan :: GHC.Types.IO (Chan a)
  readChan :: Chan a -> GHC.Types.IO a
  writeChan :: Chan a -> a -> GHC.Types.IO ()
  writeList2Chan :: Chan a -> [a] -> GHC.Types.IO ()

module Control.Concurrent.MVar where
  type MVar :: * -> *
  data MVar a = ...
  addMVarFinalizer :: MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  isEmptyMVar :: MVar a -> GHC.Types.IO GHC.Types.Bool
  mkWeakMVar :: MVar a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (MVar a))
  modifyMVar :: MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked :: MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked_ :: MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  modifyMVar_ :: MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  newEmptyMVar :: GHC.Types.IO (MVar a)
  newMVar :: a -> GHC.Types.IO (MVar a)
  putMVar :: MVar a -> a -> GHC.Types.IO ()
  readMVar :: MVar a -> GHC.Types.IO a
  swapMVar :: MVar a -> a -> GHC.Types.IO a
  takeMVar :: MVar a -> GHC.Types.IO a
  tryPutMVar :: MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  withMVar :: MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMVarMasked :: MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b

module Control.Concurrent.QSem where
  type QSem :: *
  newtype QSem = ...
  newQSem :: GHC.Types.Int -> GHC.Types.IO QSem
  signalQSem :: QSem -> GHC.Types.IO ()
  waitQSem :: QSem -> GHC.Types.IO ()

module Control.Concurrent.QSemN where
  type QSemN :: *
  data QSemN = ...
  newQSemN :: GHC.Types.Int -> GHC.Types.IO QSemN
  signalQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  waitQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()

module Control.Exception where
  AllocationLimitExceeded :: AllocationLimitExceeded
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = ...
  type ArithException :: *
  data ArithException = ...
  type ArrayException :: *
  data ArrayException = ...
  AssertionFailed :: GHC.Base.String -> AssertionFailed
  type AssertionFailed :: *
  newtype AssertionFailed = ...
  type AsyncException :: *
  data AsyncException = ...
  BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = ...
  BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = ...
  CompactionFailed :: GHC.Base.String -> CompactionFailed
  type CompactionFailed :: *
  newtype CompactionFailed = ...
  Deadlock :: Deadlock
  type Deadlock :: *
  data Deadlock = ...
  Denormal :: ArithException
  DivideByZero :: ArithException
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ...
  ErrorCallWithLocation :: GHC.Base.String -> GHC.Base.String -> ErrorCall
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e
    ...
  Handler :: Exception e => (e -> GHC.Types.IO a) -> Handler a
  type Handler :: * -> *
  data Handler a = ...
  HeapOverflow :: AsyncException
  type IOException :: *
  data IOException = ...
  IndexOutOfBounds :: GHC.Base.String -> ArrayException
  LossOfPrecision :: ArithException
  MaskedInterruptible :: MaskingState
  MaskedUninterruptible :: MaskingState
  type MaskingState :: *
  data MaskingState = ...
  NestedAtomically :: NestedAtomically
  type NestedAtomically :: *
  data NestedAtomically = ...
  NoMethodError :: GHC.Base.String -> NoMethodError
  type NoMethodError :: *
  newtype NoMethodError = ...
  NonTermination :: NonTermination
  type NonTermination :: *
  data NonTermination = ...
  Overflow :: ArithException
  PatternMatchFail :: GHC.Base.String -> PatternMatchFail
  type PatternMatchFail :: *
  newtype PatternMatchFail = ...
  RatioZeroDenominator :: ArithException
  RecConError :: GHC.Base.String -> RecConError
  type RecConError :: *
  newtype RecConError = ...
  RecSelError :: GHC.Base.String -> RecSelError
  type RecSelError :: *
  newtype RecSelError = ...
  RecUpdError :: GHC.Base.String -> RecUpdError
  type RecUpdError :: *
  newtype RecUpdError = ...
  SomeAsyncException :: Exception e => e -> SomeAsyncException
  type SomeAsyncException :: *
  data SomeAsyncException = ...
  SomeException :: Exception e => e -> SomeException
  type SomeException :: *
  data SomeException = ...
  StackOverflow :: AsyncException
  ThreadKilled :: AsyncException
  TypeError :: GHC.Base.String -> TypeError
  type TypeError :: *
  newtype TypeError = ...
  UndefinedElement :: GHC.Base.String -> ArrayException
  Underflow :: ArithException
  Unmasked :: MaskingState
  UserInterrupt :: AsyncException
  allowInterrupt :: GHC.Types.IO ()
  assert :: GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: Exception e => e -> SomeException
  bracket :: GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracketOnError :: GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracket_ :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c -> GHC.Types.IO c
  catch :: Exception e => GHC.Types.IO a -> (e -> GHC.Types.IO a) -> GHC.Types.IO a
  catchJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> (b -> GHC.Types.IO a) -> GHC.Types.IO a
  catches :: GHC.Types.IO a -> [Handler a] -> GHC.Types.IO a
  displayException :: Exception e => e -> GHC.Base.String
  evaluate :: a -> GHC.Types.IO a
  finally :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  fromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  getMaskingState :: GHC.Types.IO MaskingState
  handle :: Exception e => (e -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  handleJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> (b -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  interruptible :: GHC.Types.IO a -> GHC.Types.IO a
  ioError :: GHC.IO.Exception.IOError -> GHC.Types.IO a
  mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
  mask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  mask_ :: GHC.Types.IO a -> GHC.Types.IO a
  onException :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throw :: Exception e => e -> a
  throwIO :: Exception e => e -> GHC.Types.IO a
  throwTo :: Exception e => GHC.Conc.Sync.ThreadId -> e -> GHC.Types.IO ()
  toException :: Exception e => e -> SomeException
  try :: Exception e => GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either e a)
  tryJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either b a)
  uninterruptibleMask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  uninterruptibleMask_ :: GHC.Types.IO a -> GHC.Types.IO a

module Control.Exception.Base where
  AllocationLimitExceeded :: AllocationLimitExceeded
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = ...
  type ArithException :: *
  data ArithException = ...
  type ArrayException :: *
  data ArrayException = ...
  AssertionFailed :: GHC.Base.String -> AssertionFailed
  type AssertionFailed :: *
  newtype AssertionFailed = ...
  type AsyncException :: *
  data AsyncException = ...
  BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = ...
  BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = ...
  CompactionFailed :: GHC.Base.String -> CompactionFailed
  type CompactionFailed :: *
  newtype CompactionFailed = ...
  Deadlock :: Deadlock
  type Deadlock :: *
  data Deadlock = ...
  Denormal :: ArithException
  DivideByZero :: ArithException
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ...
  ErrorCallWithLocation :: GHC.Base.String -> GHC.Base.String -> ErrorCall
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e
    ...
  FixIOException :: FixIOException
  type FixIOException :: *
  data FixIOException = ...
  HeapOverflow :: AsyncException
  type IOException :: *
  data IOException = ...
  IndexOutOfBounds :: GHC.Base.String -> ArrayException
  LossOfPrecision :: ArithException
  MaskedInterruptible :: MaskingState
  MaskedUninterruptible :: MaskingState
  type MaskingState :: *
  data MaskingState = ...
  NestedAtomically :: NestedAtomically
  type NestedAtomically :: *
  data NestedAtomically = ...
  NoMatchingContinuationPrompt :: NoMatchingContinuationPrompt
  type NoMatchingContinuationPrompt :: *
  data NoMatchingContinuationPrompt = ...
  NoMethodError :: GHC.Base.String -> NoMethodError
  type NoMethodError :: *
  newtype NoMethodError = ...
  NonTermination :: NonTermination
  type NonTermination :: *
  data NonTermination = ...
  Overflow :: ArithException
  PatternMatchFail :: GHC.Base.String -> PatternMatchFail
  type PatternMatchFail :: *
  newtype PatternMatchFail = ...
  RatioZeroDenominator :: ArithException
  RecConError :: GHC.Base.String -> RecConError
  type RecConError :: *
  newtype RecConError = ...
  RecSelError :: GHC.Base.String -> RecSelError
  type RecSelError :: *
  newtype RecSelError = ...
  RecUpdError :: GHC.Base.String -> RecUpdError
  type RecUpdError :: *
  newtype RecUpdError = ...
  SomeAsyncException :: Exception e => e -> SomeAsyncException
  type SomeAsyncException :: *
  data SomeAsyncException = ...
  SomeException :: Exception e => e -> SomeException
  type SomeException :: *
  data SomeException = ...
  StackOverflow :: AsyncException
  ThreadKilled :: AsyncException
  TypeError :: GHC.Base.String -> TypeError
  type TypeError :: *
  newtype TypeError = ...
  UndefinedElement :: GHC.Base.String -> ArrayException
  Underflow :: ArithException
  Unmasked :: MaskingState
  UserInterrupt :: AsyncException
  assert :: GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: Exception e => e -> SomeException
  bracket :: GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracketOnError :: GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracket_ :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c -> GHC.Types.IO c
  catch :: Exception e => GHC.Types.IO a -> (e -> GHC.Types.IO a) -> GHC.Types.IO a
  catchJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> (b -> GHC.Types.IO a) -> GHC.Types.IO a
  displayException :: Exception e => e -> GHC.Base.String
  evaluate :: a -> GHC.Types.IO a
  finally :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  fromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  getMaskingState :: GHC.Types.IO MaskingState
  handle :: Exception e => (e -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  handleJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> (b -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  impossibleConstraintError :: GHC.Prim.Addr# -=> a
  impossibleError :: GHC.Prim.Addr# -> a
  ioError :: GHC.IO.Exception.IOError -> GHC.Types.IO a
  mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
  mask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  mask_ :: GHC.Types.IO a -> GHC.Types.IO a
  nestedAtomically :: SomeException
  noMatchingContinuationPrompt :: SomeException
  noMethodBindingError :: GHC.Prim.Addr# -> a
  nonExhaustiveGuardsError :: GHC.Prim.Addr# -> a
  nonTermination :: SomeException
  onException :: GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  patError :: GHC.Prim.Addr# -> a
  recConError :: GHC.Prim.Addr# -> a
  recSelError :: GHC.Prim.Addr# -> a
  throw :: Exception e => e -> a
  throwIO :: Exception e => e -> GHC.Types.IO a
  throwTo :: Exception e => GHC.Conc.Sync.ThreadId -> e -> GHC.Types.IO ()
  toException :: Exception e => e -> SomeException
  try :: Exception e => GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either e a)
  tryJust :: Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either b a)
  typeError :: GHC.Prim.Addr# -> a
  uninterruptibleMask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  uninterruptibleMask_ :: GHC.Types.IO a -> GHC.Types.IO a

module Control.Monad where
  (<$) :: Functor f => a -> f b -> f a
  (<$!>) :: Monad m => (a -> b) -> m a -> m b
  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
  (=<<) :: Monad m => (a -> m b) -> m a -> m b
  (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
  (>>) :: Monad m => m a -> m b -> m b
  (>>=) :: Monad m => m a -> (a -> m b) -> m b
  type Functor :: (* -> *) -> Constraint
  class Functor f
    ...
  type Monad :: (* -> *) -> Constraint
  class GHC.Base.Applicative m => Monad m
    ...
  type MonadFail :: (* -> *) -> Constraint
  class Monad m => MonadFail m
    ...
  type MonadPlus :: (* -> *) -> Constraint
  class (GHC.Base.Alternative m, Monad m) => MonadPlus m
    ...
  ap :: Monad m => m (a -> b) -> m a -> m b
  fail :: MonadFail m => GHC.Base.String -> m a
  filterM :: GHC.Base.Applicative m => (a -> m GHC.Types.Bool) -> [a] -> m [a]
  fmap :: Functor f => (a -> b) -> f a -> f b
  foldM :: (Data.Foldable.Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
  foldM_ :: (Data.Foldable.Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
  forM :: (Data.Traversable.Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
  forM_ :: (Data.Foldable.Foldable t, Monad m) => t a -> (a -> m b) -> m ()
  forever :: GHC.Base.Applicative f => f a -> f b
  guard :: GHC.Base.Alternative f => GHC.Types.Bool -> f ()
  join :: Monad m => m (m a) -> m a
  liftM :: Monad m => (a1 -> r) -> m a1 -> m r
  liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
  liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
  liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
  liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
  mapAndUnzipM :: GHC.Base.Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
  mapM :: (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  mapM_ :: (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
  mfilter :: MonadPlus m => (a -> GHC.Types.Bool) -> m a -> m a
  mplus :: MonadPlus m => m a -> m a -> m a
  msum :: (Data.Foldable.Foldable t, MonadPlus m) => t (m a) -> m a
  mzero :: MonadPlus m => m a
  replicateM :: GHC.Base.Applicative m => GHC.Types.Int -> m a -> m [a]
  replicateM_ :: GHC.Base.Applicative m => GHC.Types.Int -> m a -> m ()
  return :: Monad m => a -> m a
  sequence :: (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
  sequence_ :: (Data.Foldable.Foldable t, Monad m) => t (m a) -> m ()
  unless :: GHC.Base.Applicative f => GHC.Types.Bool -> f () -> f ()
  void :: Functor f => f a -> f ()
  when :: GHC.Base.Applicative f => GHC.Types.Bool -> f () -> f ()
  zipWithM :: GHC.Base.Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
  zipWithM_ :: GHC.Base.Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

module Control.Monad.Fail where
  type MonadFail :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadFail m
    ...
  fail :: MonadFail m => GHC.Base.String -> m a

module Control.Monad.Fix where
  type MonadFix :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadFix m
    ...
  fix :: (a -> a) -> a
  mfix :: MonadFix m => (a -> m a) -> m a

module Control.Monad.IO.Class where
  type MonadIO :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadIO m
    ...
  liftIO :: MonadIO m => GHC.Types.IO a -> m a

module Control.Monad.Instances where
  (<$) :: Functor f => a -> f b -> f a
  (>>) :: Monad m => m a -> m b -> m b
  (>>=) :: Monad m => m a -> (a -> m b) -> m b
  type Functor :: (* -> *) -> Constraint
  class Functor f
    ...
  type Monad :: (* -> *) -> Constraint
  class GHC.Base.Applicative m => Monad m
    ...
  fmap :: Functor f => (a -> b) -> f a -> f b
  return :: Monad m => a -> m a

module Control.Monad.ST where
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: (a -> ST s a) -> ST s a
  runST :: (forall s. ST s a) -> a
  stToIO :: ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Lazy where
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: (a -> ST s a) -> ST s a
  lazyToStrictST :: ST s a -> GHC.ST.ST s a
  runST :: (forall s. ST s a) -> a
  stToIO :: ST RealWorld a -> GHC.Types.IO a
  strictToLazyST :: GHC.ST.ST s a -> ST s a

module Control.Monad.ST.Lazy.Safe where
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: (a -> ST s a) -> ST s a
  lazyToStrictST :: ST s a -> GHC.ST.ST s a
  runST :: (forall s. ST s a) -> a
  stToIO :: ST RealWorld a -> GHC.Types.IO a
  strictToLazyST :: GHC.ST.ST s a -> ST s a

module Control.Monad.ST.Lazy.Unsafe where
  unsafeIOToST :: GHC.Types.IO a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a
  unsafeInterleaveST :: base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a

module Control.Monad.ST.Safe where
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: (a -> ST s a) -> ST s a
  runST :: (forall s. ST s a) -> a
  stToIO :: ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Strict where
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: (a -> ST s a) -> ST s a
  runST :: (forall s. ST s a) -> a
  stToIO :: ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Unsafe where
  unsafeDupableInterleaveST :: GHC.ST.ST s a -> GHC.ST.ST s a
  unsafeIOToST :: GHC.Types.IO a -> GHC.ST.ST s a
  unsafeInterleaveST :: GHC.ST.ST s a -> GHC.ST.ST s a
  unsafeSTToIO :: GHC.ST.ST s a -> GHC.Types.IO a

module Control.Monad.Zip where
  type MonadZip :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadZip m
    ...
  munzip :: MonadZip m => m (a, b) -> (m a, m b)
  mzip :: MonadZip m => m a -> m b -> m (a, b)
  mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c

module Data.Array.Byte where
  ByteArray :: GHC.Prim.ByteArray# -> ByteArray
  type ByteArray :: *
  data ByteArray = ...
  MutableByteArray :: GHC.Prim.MutableByteArray# s -> MutableByteArray s
  type role MutableByteArray nominal
  type MutableByteArray :: * -> *
  data MutableByteArray s = ...

module Data.Bifoldable where
  type Bifoldable :: (* -> * -> *) -> Constraint
  class Bifoldable p
    ...
  biList :: Bifoldable t => t a a -> [a]
  biall :: Bifoldable t => (a -> GHC.Types.Bool) -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
  biand :: Bifoldable t => t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
  biany :: Bifoldable t => (a -> GHC.Types.Bool) -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
  biasum :: (Bifoldable t, GHC.Base.Alternative f) => t (f a) (f a) -> f a
  biconcat :: Bifoldable t => t [a] [a] -> [a]
  biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]
  bielem :: (Bifoldable t, GHC.Classes.Eq a) => a -> t a a -> GHC.Types.Bool
  bifind :: Bifoldable t => (a -> GHC.Types.Bool) -> t a a -> GHC.Maybe.Maybe a
  bifold :: (Bifoldable p, GHC.Base.Monoid m) => p m m -> m
  bifoldMap :: (Bifoldable p, GHC.Base.Monoid m) => (a -> m) -> (b -> m) -> p a b -> m
  bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
  bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
  bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a
  bifoldlM :: (Bifoldable t, GHC.Base.Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
  bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
  bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
  bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a
  bifoldrM :: (Bifoldable t, GHC.Base.Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
  biforM_ :: (Bifoldable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
  bifor_ :: (Bifoldable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
  bilength :: Bifoldable t => t a b -> GHC.Types.Int
  bimapM_ :: (Bifoldable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()
  bimaximum :: (Bifoldable t, GHC.Classes.Ord a) => t a a -> a
  bimaximumBy :: Bifoldable t => (a -> a -> GHC.Types.Ordering) -> t a a -> a
  biminimum :: (Bifoldable t, GHC.Classes.Ord a) => t a a -> a
  biminimumBy :: Bifoldable t => (a -> a -> GHC.Types.Ordering) -> t a a -> a
  bimsum :: (Bifoldable t, GHC.Base.Alternative f) => t (f a) (f a) -> f a
  binotElem :: (Bifoldable t, GHC.Classes.Eq a) => a -> t a a -> GHC.Types.Bool
  binull :: Bifoldable t => t a b -> GHC.Types.Bool
  bior :: Bifoldable t => t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
  biproduct :: (Bifoldable t, GHC.Num.Num a) => t a a -> a
  bisequenceA_ :: (Bifoldable t, GHC.Base.Applicative f) => t (f a) (f b) -> f ()
  bisequence_ :: (Bifoldable t, GHC.Base.Applicative f) => t (f a) (f b) -> f ()
  bisum :: (Bifoldable t, GHC.Num.Num a) => t a a -> a
  bitraverse_ :: (Bifoldable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

module Data.Bifoldable1 where
  type Bifoldable1 :: (* -> * -> *) -> Constraint
  class Data.Bifoldable.Bifoldable t => Bifoldable1 t
    ...
  bifold1 :: (Bifoldable1 t, GHC.Base.Semigroup m) => t m m -> m
  bifoldMap1 :: (Bifoldable1 t, GHC.Base.Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m

module Data.Bifunctor where
  type Bifunctor :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Base.Functor (p a)) => Bifunctor p
    ...
  bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
  first :: Bifunctor p => (a -> b) -> p a c -> p b c
  second :: Bifunctor p => (b -> c) -> p a b -> p a c

module Data.Bitraversable where
  type Bitraversable :: (* -> * -> *) -> Constraint
  class (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) => Bitraversable t
    ...
  bifoldMapDefault :: (Bitraversable t, GHC.Base.Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
  bifor :: (Bitraversable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
  biforM :: (Bitraversable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
  bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
  bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
  bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d
  bimapM :: (Bitraversable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
  bisequence :: (Bitraversable t, GHC.Base.Applicative f) => t (f a) (f b) -> f (t a b)
  bisequenceA :: (Bitraversable t, GHC.Base.Applicative f) => t (f a) (f b) -> f (t a b)
  bitraverse :: (Bitraversable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

module Data.Bits where
  (!<<.) :: Bits a => a -> GHC.Types.Int -> a
  (!>>.) :: Bits a => a -> GHC.Types.Int -> a
  (.&.) :: Bits a => a -> a -> a
  (.<<.) :: Bits a => a -> GHC.Types.Int -> a
  (.>>.) :: Bits a => a -> GHC.Types.Int -> a
  (.^.) :: Bits a => a -> a -> a
  (.|.) :: Bits a => a -> a -> a
  And :: a -> And a
  type And :: * -> *
  newtype And a = ...
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a
    ...
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b
    ...
  Iff :: a -> Iff a
  type Iff :: * -> *
  newtype Iff a = ...
  Ior :: a -> Ior a
  type Ior :: * -> *
  newtype Ior a = ...
  Xor :: a -> Xor a
  type Xor :: * -> *
  newtype Xor a = ...
  bit :: Bits a => GHC.Types.Int -> a
  bitDefault :: (Bits a, GHC.Num.Num a) => GHC.Types.Int -> a
  bitSize :: Bits a => a -> GHC.Types.Int
  bitSizeMaybe :: Bits a => a -> GHC.Maybe.Maybe GHC.Types.Int
  clearBit :: Bits a => a -> GHC.Types.Int -> a
  complement :: Bits a => a -> a
  complementBit :: Bits a => a -> GHC.Types.Int -> a
  countLeadingZeros :: FiniteBits b => b -> GHC.Types.Int
  countTrailingZeros :: FiniteBits b => b -> GHC.Types.Int
  finiteBitSize :: FiniteBits b => b -> GHC.Types.Int
  getAnd :: And a -> a
  getIff :: Iff a -> a
  getIor :: Ior a -> a
  getXor :: Xor a -> a
  isSigned :: Bits a => a -> GHC.Types.Bool
  oneBits :: FiniteBits a => a
  popCount :: Bits a => a -> GHC.Types.Int
  popCountDefault :: (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int
  rotate :: Bits a => a -> GHC.Types.Int -> a
  rotateL :: Bits a => a -> GHC.Types.Int -> a
  rotateR :: Bits a => a -> GHC.Types.Int -> a
  setBit :: Bits a => a -> GHC.Types.Int -> a
  shift :: Bits a => a -> GHC.Types.Int -> a
  shiftL :: Bits a => a -> GHC.Types.Int -> a
  shiftR :: Bits a => a -> GHC.Types.Int -> a
  testBit :: Bits a => a -> GHC.Types.Int -> GHC.Types.Bool
  testBitDefault :: (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int -> GHC.Types.Bool
  toIntegralSized :: (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  unsafeShiftL :: Bits a => a -> GHC.Types.Int -> a
  unsafeShiftR :: Bits a => a -> GHC.Types.Int -> a
  xor :: Bits a => a -> a -> a
  zeroBits :: Bits a => a

module Data.Bool where
  (&&) :: Bool -> Bool -> Bool
  type Bool :: *
  data Bool = ...
  False :: Bool
  True :: Bool
  bool :: a -> a -> Bool -> a
  not :: Bool -> Bool
  otherwise :: Bool
  (||) :: Bool -> Bool -> Bool

module Data.Char where
  type Char :: *
  data Char = ...
  ClosePunctuation :: GeneralCategory
  ConnectorPunctuation :: GeneralCategory
  Control :: GeneralCategory
  CurrencySymbol :: GeneralCategory
  DashPunctuation :: GeneralCategory
  DecimalNumber :: GeneralCategory
  EnclosingMark :: GeneralCategory
  FinalQuote :: GeneralCategory
  Format :: GeneralCategory
  type GeneralCategory :: *
  data GeneralCategory = ...
  InitialQuote :: GeneralCategory
  LetterNumber :: GeneralCategory
  LineSeparator :: GeneralCategory
  LowercaseLetter :: GeneralCategory
  MathSymbol :: GeneralCategory
  ModifierLetter :: GeneralCategory
  ModifierSymbol :: GeneralCategory
  NonSpacingMark :: GeneralCategory
  NotAssigned :: GeneralCategory
  OpenPunctuation :: GeneralCategory
  OtherLetter :: GeneralCategory
  OtherNumber :: GeneralCategory
  OtherPunctuation :: GeneralCategory
  OtherSymbol :: GeneralCategory
  ParagraphSeparator :: GeneralCategory
  PrivateUse :: GeneralCategory
  Space :: GeneralCategory
  SpacingCombiningMark :: GeneralCategory
  Surrogate :: GeneralCategory
  TitlecaseLetter :: GeneralCategory
  UppercaseLetter :: GeneralCategory
  chr :: GHC.Types.Int -> Char
  digitToInt :: Char -> GHC.Types.Int
  generalCategory :: Char -> GeneralCategory
  intToDigit :: GHC.Types.Int -> Char
  isAlpha :: Char -> GHC.Types.Bool
  isAlphaNum :: Char -> GHC.Types.Bool
  isAscii :: Char -> GHC.Types.Bool
  isAsciiLower :: Char -> GHC.Types.Bool
  isAsciiUpper :: Char -> GHC.Types.Bool
  isControl :: Char -> GHC.Types.Bool
  isDigit :: Char -> GHC.Types.Bool
  isHexDigit :: Char -> GHC.Types.Bool
  isLatin1 :: Char -> GHC.Types.Bool
  isLetter :: Char -> GHC.Types.Bool
  isLower :: Char -> GHC.Types.Bool
  isLowerCase :: Char -> GHC.Types.Bool
  isMark :: Char -> GHC.Types.Bool
  isNumber :: Char -> GHC.Types.Bool
  isOctDigit :: Char -> GHC.Types.Bool
  isPrint :: Char -> GHC.Types.Bool
  isPunctuation :: Char -> GHC.Types.Bool
  isSeparator :: Char -> GHC.Types.Bool
  isSpace :: Char -> GHC.Types.Bool
  isSymbol :: Char -> GHC.Types.Bool
  isUpper :: Char -> GHC.Types.Bool
  isUpperCase :: Char -> GHC.Types.Bool
  lexLitChar :: Text.ParserCombinators.ReadP.ReadS GHC.Base.String
  ord :: Char -> GHC.Types.Int
  readLitChar :: Text.ParserCombinators.ReadP.ReadS Char
  showLitChar :: Char -> GHC.Show.ShowS
  toLower :: Char -> Char
  toTitle :: Char -> Char
  toUpper :: Char -> Char

module Data.Coerce where
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
  coerce :: Coercible a b => a -> b

module Data.Complex where
  (:+) :: a -> a -> Complex a
  type Complex :: * -> *
  data Complex a = ...
  cis :: GHC.Float.Floating a => a -> Complex a
  conjugate :: GHC.Num.Num a => Complex a -> Complex a
  imagPart :: Complex a -> a
  magnitude :: GHC.Float.RealFloat a => Complex a -> a
  mkPolar :: GHC.Float.Floating a => a -> a -> Complex a
  phase :: GHC.Float.RealFloat a => Complex a -> a
  polar :: GHC.Float.RealFloat a => Complex a -> (a, a)
  realPart :: Complex a -> a

module Data.Data where
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    ...
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    ...
  AlgConstr :: ConIndex -> ConstrRep
  AlgRep :: [Constr] -> DataRep
  CharConstr :: GHC.Types.Char -> ConstrRep
  CharRep :: DataRep
  type ConIndex :: *
  type ConIndex = GHC.Types.Int
  type Constr :: *
  data Constr = ...
  type ConstrRep :: *
  data ConstrRep = ...
  type Data :: * -> Constraint
  class Typeable a => Data a
    ...
  type DataRep :: *
  data DataRep = ...
  type DataType :: *
  data DataType = ...
  type Fixity :: *
  data Fixity = ...
  FloatConstr :: GHC.Real.Rational -> ConstrRep
  FloatRep :: DataRep
  HRefl :: forall {k1} (a :: k1). a :~~: a
  Infix :: Fixity
  IntConstr :: GHC.Num.Integer.Integer -> ConstrRep
  IntRep :: DataRep
  NoRep :: DataRep
  Prefix :: Fixity
  Proxy :: forall {k} (t :: k). Proxy t
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = ...
  Refl :: forall {k} (a :: k). a :~: a
  type TyCon :: *
  data TyCon = ...
  type TypeRep :: *
  type TypeRep = base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  type Typeable :: forall k. k -> Constraint
  class Typeable a
    ...
  cast :: (Typeable a, Typeable b) => a -> GHC.Maybe.Maybe b
  constrFields :: Constr -> [GHC.Base.String]
  constrFixity :: Constr -> Fixity
  constrIndex :: Constr -> ConIndex
  constrRep :: Constr -> ConstrRep
  constrType :: Constr -> DataType
  dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> GHC.Maybe.Maybe (c a)
  dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> GHC.Maybe.Maybe (c a)
  dataTypeConstrs :: DataType -> [Constr]
  dataTypeName :: DataType -> GHC.Base.String
  dataTypeOf :: Data a => a -> DataType
  dataTypeRep :: DataType -> DataRep
  eqT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~: b)
  fromConstr :: Data a => Constr -> a
  fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a
  fromConstrM :: (GHC.Base.Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
  funResultTy :: TypeRep -> TypeRep -> GHC.Maybe.Maybe TypeRep
  gcast :: forall {k} (a :: k) (b :: k) (c :: k -> *). (Typeable a, Typeable b) => c a -> GHC.Maybe.Maybe (c b)
  gcast1 :: forall {k1} {k2} (c :: k1 -> *) (t :: k2 -> k1) (t' :: k2 -> k1) (a :: k2). (Typeable t, Typeable t') => c (t a) -> GHC.Maybe.Maybe (c (t' a))
  gcast2 :: forall {k1} {k2} {k3} (c :: k1 -> *) (t :: k2 -> k3 -> k1) (t' :: k2 -> k3 -> k1) (a :: k2) (b :: k3). (Typeable t, Typeable t') => c (t a b) -> GHC.Maybe.Maybe (c (t' a b))
  gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
  gmapM :: (Data a, GHC.Base.Monad m) => (forall d. Data d => d -> m d) -> a -> m a
  gmapMo :: (Data a, GHC.Base.MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
  gmapMp :: (Data a, GHC.Base.MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
  gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
  gmapQi :: Data a => GHC.Types.Int -> (forall d. Data d => d -> u) -> a -> u
  gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
  gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
  gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a
  gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
  heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~~: b)
  indexConstr :: DataType -> ConIndex -> Constr
  isAlgType :: DataType -> GHC.Types.Bool
  isNorepType :: DataType -> GHC.Types.Bool
  maxConstrIndex :: DataType -> ConIndex
  mkCharConstr :: DataType -> GHC.Types.Char -> Constr
  mkCharType :: GHC.Base.String -> DataType
  mkConstr :: DataType -> GHC.Base.String -> [GHC.Base.String] -> Fixity -> Constr
  mkConstrTag :: DataType -> GHC.Base.String -> GHC.Types.Int -> [GHC.Base.String] -> Fixity -> Constr
  mkDataType :: GHC.Base.String -> [Constr] -> DataType
  mkFloatType :: GHC.Base.String -> DataType
  mkFunTy :: TypeRep -> TypeRep -> TypeRep
  mkIntType :: GHC.Base.String -> DataType
  mkIntegralConstr :: (GHC.Real.Integral a, GHC.Show.Show a) => DataType -> a -> Constr
  mkNoRepType :: GHC.Base.String -> DataType
  mkRealConstr :: (GHC.Real.Real a, GHC.Show.Show a) => DataType -> a -> Constr
  readConstr :: DataType -> GHC.Base.String -> GHC.Maybe.Maybe Constr
  repConstr :: DataType -> ConstrRep -> Constr
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: TypeRep -> ()
  showConstr :: Constr -> GHC.Base.String
  showsTypeRep :: TypeRep -> GHC.Show.ShowS
  splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
  toConstr :: Data a => a -> Constr
  trLiftedRep :: base-4.18.0.0:Data.Typeable.Internal.TypeRep GHC.Types.LiftedRep
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  tyconModule :: GHC.Base.String -> GHC.Base.String
  tyconUQname :: GHC.Base.String -> GHC.Base.String
  typeOf :: Typeable a => a -> TypeRep
  typeOf1 :: Typeable t => t a -> TypeRep
  typeOf2 :: Typeable t => t a b -> TypeRep
  typeOf3 :: Typeable t => t a b c -> TypeRep
  typeOf4 :: Typeable t => t a b c d -> TypeRep
  typeOf5 :: Typeable t => t a b c d e -> TypeRep
  typeOf6 :: Typeable t => t a b c d e f -> TypeRep
  typeOf7 :: Typeable t => t a b c d e f g -> TypeRep
  typeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
  typeRepArgs :: TypeRep -> [TypeRep]
  typeRepFingerprint :: TypeRep -> GHC.Fingerprint.Type.Fingerprint
  typeRepTyCon :: TypeRep -> TyCon

module Data.Dynamic where
  Dynamic :: base-4.18.0.0:Data.Typeable.Internal.TypeRep a -> a -> Dynamic
  type Dynamic :: *
  data Dynamic where
    ...
  type Typeable :: forall k. k -> Constraint
  class Typeable a
    ...
  dynApp :: Dynamic -> Dynamic -> Dynamic
  dynApply :: Dynamic -> Dynamic -> GHC.Maybe.Maybe Dynamic
  dynTypeRep :: Dynamic -> base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  fromDyn :: Typeable a => Dynamic -> a -> a
  fromDynamic :: Typeable a => Dynamic -> GHC.Maybe.Maybe a
  toDyn :: Typeable a => a -> Dynamic

module Data.Either where
  type Either :: * -> * -> *
  data Either a b = ...
  Left :: a -> Either a b
  Right :: b -> Either a b
  either :: (a -> c) -> (b -> c) -> Either a b -> c
  fromLeft :: a -> Either a b -> a
  fromRight :: b -> Either a b -> b
  isLeft :: Either a b -> GHC.Types.Bool
  isRight :: Either a b -> GHC.Types.Bool
  lefts :: [Either a b] -> [a]
  partitionEithers :: [Either a b] -> ([a], [b])
  rights :: [Either a b] -> [b]

module Data.Eq where
  (/=) :: Eq a => a -> a -> GHC.Types.Bool
  (==) :: Eq a => a -> a -> GHC.Types.Bool
  type Eq :: * -> Constraint
  class Eq a
    ...

module Data.Fixed where
  type Centi :: *
  type Centi = Fixed E2
  type Deci :: *
  type Deci = Fixed E1
  type E0 :: *
  data E0
  type E1 :: *
  data E1
  type E12 :: *
  data E12
  type E2 :: *
  data E2
  type E3 :: *
  data E3
  type E6 :: *
  data E6
  type E9 :: *
  data E9
  type role Fixed phantom
  type Fixed :: forall k. k -> *
  newtype Fixed a = ...
  type HasResolution :: forall k. k -> Constraint
  class HasResolution a
    ...
  type Micro :: *
  type Micro = Fixed E6
  type Milli :: *
  type Milli = Fixed E3
  MkFixed :: forall k (a :: k). GHC.Num.Integer.Integer -> Fixed a
  type Nano :: *
  type Nano = Fixed E9
  type Pico :: *
  type Pico = Fixed E12
  type Uni :: *
  type Uni = Fixed E0
  div' :: (GHC.Real.Real a, GHC.Real.Integral b) => a -> a -> b
  divMod' :: (GHC.Real.Real a, GHC.Real.Integral b) => a -> a -> (b, a)
  mod' :: GHC.Real.Real a => a -> a -> a
  resolution :: forall k (a :: k) (p :: k -> *). HasResolution a => p a -> GHC.Num.Integer.Integer
  showFixed :: forall {k} (a :: k). HasResolution a => GHC.Types.Bool -> Fixed a -> GHC.Base.String

module Data.Foldable where
  type Foldable :: (* -> *) -> Constraint
  class Foldable t
    ...
  all :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  and :: Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  any :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  asum :: (Foldable t, GHC.Base.Alternative f) => t (f a) -> f a
  concat :: Foldable t => t [a] -> [a]
  concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
  elem :: (Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  find :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Maybe.Maybe a
  fold :: (Foldable t, GHC.Base.Monoid m) => t m -> m
  foldMap :: (Foldable t, GHC.Base.Monoid m) => (a -> m) -> t a -> m
  foldMap' :: (Foldable t, GHC.Base.Monoid m) => (a -> m) -> t a -> m
  foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
  foldlM :: (Foldable t, GHC.Base.Monad m) => (b -> a -> m b) -> b -> t a -> m b
  foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
  foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
  foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
  foldrM :: (Foldable t, GHC.Base.Monad m) => (a -> b -> m b) -> b -> t a -> m b
  forM_ :: (Foldable t, GHC.Base.Monad m) => t a -> (a -> m b) -> m ()
  for_ :: (Foldable t, GHC.Base.Applicative f) => t a -> (a -> f b) -> f ()
  length :: Foldable t => t a -> GHC.Types.Int
  mapM_ :: (Foldable t, GHC.Base.Monad m) => (a -> m b) -> t a -> m ()
  maximum :: (Foldable t, GHC.Classes.Ord a) => t a -> a
  maximumBy :: Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimum :: (Foldable t, GHC.Classes.Ord a) => t a -> a
  minimumBy :: Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  msum :: (Foldable t, GHC.Base.MonadPlus m) => t (m a) -> m a
  notElem :: (Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  null :: Foldable t => t a -> GHC.Types.Bool
  or :: Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  product :: (Foldable t, GHC.Num.Num a) => t a -> a
  sequenceA_ :: (Foldable t, GHC.Base.Applicative f) => t (f a) -> f ()
  sequence_ :: (Foldable t, GHC.Base.Monad m) => t (m a) -> m ()
  sum :: (Foldable t, GHC.Num.Num a) => t a -> a
  toList :: Foldable t => t a -> [a]
  traverse_ :: (Foldable t, GHC.Base.Applicative f) => (a -> f b) -> t a -> f ()

module Data.Foldable1 where
  type Foldable1 :: (* -> *) -> Constraint
  class Data.Foldable.Foldable t => Foldable1 t
    ...
  fold1 :: (Foldable1 t, GHC.Base.Semigroup m) => t m -> m
  foldMap1 :: (Foldable1 t, GHC.Base.Semigroup m) => (a -> m) -> t a -> m
  foldMap1' :: (Foldable1 t, GHC.Base.Semigroup m) => (a -> m) -> t a -> m
  foldl1 :: Foldable1 t => (a -> a -> a) -> t a -> a
  foldl1' :: Foldable1 t => (a -> a -> a) -> t a -> a
  foldlM1 :: (Foldable1 t, GHC.Base.Monad m) => (a -> a -> m a) -> t a -> m a
  foldlMap1 :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b
  foldlMap1' :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b
  foldlMapM1 :: (Foldable1 t, GHC.Base.Monad m) => (a -> m b) -> (b -> a -> m b) -> t a -> m b
  foldr1 :: Foldable1 t => (a -> a -> a) -> t a -> a
  foldr1' :: Foldable1 t => (a -> a -> a) -> t a -> a
  foldrM1 :: (Foldable1 t, GHC.Base.Monad m) => (a -> a -> m a) -> t a -> m a
  foldrMap1 :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b
  foldrMap1' :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b
  foldrMapM1 :: (Foldable1 t, GHC.Base.Monad m) => (a -> m b) -> (a -> b -> m b) -> t a -> m b
  head :: Foldable1 t => t a -> a
  intercalate1 :: (Foldable1 t, GHC.Base.Semigroup m) => m -> t m -> m
  last :: Foldable1 t => t a -> a
  maximum :: (Foldable1 t, GHC.Classes.Ord a) => t a -> a
  maximumBy :: Foldable1 t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimum :: (Foldable1 t, GHC.Classes.Ord a) => t a -> a
  minimumBy :: Foldable1 t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  toNonEmpty :: Foldable1 t => t a -> GHC.Base.NonEmpty a

module Data.Function where
  ($) :: (a -> b) -> a -> b
  (&) :: a -> (a -> b) -> b
  (.) :: (b -> c) -> (a -> b) -> a -> c
  applyWhen :: GHC.Types.Bool -> (a -> a) -> a -> a
  const :: a -> b -> a
  fix :: (a -> a) -> a
  flip :: (a -> b -> c) -> b -> a -> c
  id :: a -> a
  on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

module Data.Functor where
  ($>) :: Functor f => f a -> b -> f b
  (<$) :: Functor f => a -> f b -> f a
  (<$>) :: Functor f => (a -> b) -> f a -> f b
  (<&>) :: Functor f => f a -> (a -> b) -> f b
  type Functor :: (* -> *) -> Constraint
  class Functor f
    ...
  fmap :: Functor f => (a -> b) -> f a -> f b
  void :: Functor f => f a -> f ()

module Data.Functor.Classes where
  type Eq1 :: (* -> *) -> Constraint
  class (forall a. GHC.Classes.Eq a => GHC.Classes.Eq (f a)) => Eq1 f
    ...
  type Eq2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Classes.Eq a => Eq1 (f a)) => Eq2 f
    ...
  type Ord1 :: (* -> *) -> Constraint
  class (Eq1 f, forall a. GHC.Classes.Ord a => GHC.Classes.Ord (f a)) => Ord1 f
    ...
  type Ord2 :: (* -> * -> *) -> Constraint
  class (Eq2 f, forall a. GHC.Classes.Ord a => Ord1 (f a)) => Ord2 f
    ...
  type Read1 :: (* -> *) -> Constraint
  class (forall a. GHC.Read.Read a => GHC.Read.Read (f a)) => Read1 f
    ...
  type Read2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Read.Read a => Read1 (f a)) => Read2 f
    ...
  type Show1 :: (* -> *) -> Constraint
  class (forall a. GHC.Show.Show a => GHC.Show.Show (f a)) => Show1 f
    ...
  type Show2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Show.Show a => Show1 (f a)) => Show2 f
    ...
  compare1 :: (Ord1 f, GHC.Classes.Ord a) => f a -> f a -> GHC.Types.Ordering
  compare2 :: (Ord2 f, GHC.Classes.Ord a, GHC.Classes.Ord b) => f a b -> f a b -> GHC.Types.Ordering
  eq1 :: (Eq1 f, GHC.Classes.Eq a) => f a -> f a -> GHC.Types.Bool
  eq2 :: (Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) => f a b -> f a b -> GHC.Types.Bool
  liftCompare :: Ord1 f => (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
  liftCompare2 :: Ord2 f => (a -> b -> GHC.Types.Ordering) -> (c -> d -> GHC.Types.Ordering) -> f a c -> f b d -> GHC.Types.Ordering
  liftEq :: Eq1 f => (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
  liftEq2 :: Eq2 f => (a -> b -> GHC.Types.Bool) -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
  liftReadList :: Read1 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> Text.ParserCombinators.ReadP.ReadS [f a]
  liftReadList2 :: Read2 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> Text.ParserCombinators.ReadP.ReadS [f a b]
  liftReadList2Default :: Read2 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> Text.ParserCombinators.ReadP.ReadS [f a b]
  liftReadListDefault :: Read1 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> Text.ParserCombinators.ReadP.ReadS [f a]
  liftReadListPrec :: Read1 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
  liftReadListPrec2 :: Read2 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
  liftReadListPrec2Default :: Read2 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
  liftReadListPrecDefault :: Read1 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
  liftReadPrec :: Read1 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
  liftReadPrec2 :: Read2 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
  liftReadsPrec :: Read1 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
  liftReadsPrec2 :: Read2 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
  liftShowList :: Show1 f => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
  liftShowList2 :: Show2 f => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> ([b] -> GHC.Show.ShowS) -> [f a b] -> GHC.Show.ShowS
  liftShowsPrec :: Show1 f => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> GHC.Types.Int -> f a -> GHC.Show.ShowS
  liftShowsPrec2 :: Show2 f => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> ([b] -> GHC.Show.ShowS) -> GHC.Types.Int -> f a b -> GHC.Show.ShowS
  readBinaryWith :: Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec b -> GHC.Base.String -> (a -> b -> t) -> Text.ParserCombinators.ReadPrec.ReadPrec t
  readData :: Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readPrec1 :: (Read1 f, GHC.Read.Read a) => Text.ParserCombinators.ReadPrec.ReadPrec (f a)
  readPrec2 :: (Read2 f, GHC.Read.Read a, GHC.Read.Read b) => Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
  readUnaryWith :: Text.ParserCombinators.ReadPrec.ReadPrec a -> GHC.Base.String -> (a -> t) -> Text.ParserCombinators.ReadPrec.ReadPrec t
  readsBinary1 :: (Read1 f, Read1 g, GHC.Read.Read a) => GHC.Base.String -> (f a -> g a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsBinaryWith :: (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> GHC.Base.String -> (a -> b -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsData :: (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a) -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
  readsPrec1 :: (Read1 f, GHC.Read.Read a) => GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
  readsPrec2 :: (Read2 f, GHC.Read.Read a, GHC.Read.Read b) => GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
  readsUnary :: GHC.Read.Read a => GHC.Base.String -> (a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsUnary1 :: (Read1 f, GHC.Read.Read a) => GHC.Base.String -> (f a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsUnaryWith :: (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> GHC.Base.String -> (a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  showsBinary1 :: (Show1 f, Show1 g, GHC.Show.Show a) => GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
  showsBinaryWith :: (GHC.Types.Int -> a -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> GHC.Base.String -> GHC.Types.Int -> a -> b -> GHC.Show.ShowS
  showsPrec1 :: (Show1 f, GHC.Show.Show a) => GHC.Types.Int -> f a -> GHC.Show.ShowS
  showsPrec2 :: (Show2 f, GHC.Show.Show a, GHC.Show.Show b) => GHC.Types.Int -> f a b -> GHC.Show.ShowS
  showsUnary :: GHC.Show.Show a => GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
  showsUnary1 :: (Show1 f, GHC.Show.Show a) => GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
  showsUnaryWith :: (GHC.Types.Int -> a -> GHC.Show.ShowS) -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS

module Data.Functor.Compose where
  Compose :: forall {k} {k1} (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Compose f g a
  type role Compose representational nominal nominal
  type Compose :: forall {k} {k1}. (k -> *) -> (k1 -> k) -> k1 -> *
  newtype Compose f g a = ...
  getCompose :: forall {k1} {k2} (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). Compose f g a -> f (g a)

module Data.Functor.Const where
  Const :: forall {k} a (b :: k). a -> Const a b
  type role Const representational phantom
  type Const :: forall {k}. * -> k -> *
  newtype Const a b = ...
  getConst :: forall {k} a (b :: k). Const a b -> a

module Data.Functor.Contravariant where
  ($<) :: Contravariant f => f b -> b -> f a
  (>$) :: Contravariant f => b -> f b -> f a
  (>$$<) :: Contravariant f => f b -> (a -> b) -> f a
  (>$<) :: Contravariant f => (a -> b) -> f b -> f a
  Comparison :: (a -> a -> GHC.Types.Ordering) -> Comparison a
  type Comparison :: * -> *
  newtype Comparison a = ...
  type Contravariant :: (* -> *) -> Constraint
  class Contravariant f
    ...
  Equivalence :: (a -> a -> GHC.Types.Bool) -> Equivalence a
  type Equivalence :: * -> *
  newtype Equivalence a = ...
  Op :: (b -> a) -> Op a b
  type Op :: * -> * -> *
  newtype Op a b = ...
  Predicate :: (a -> GHC.Types.Bool) -> Predicate a
  type Predicate :: * -> *
  newtype Predicate a = ...
  comparisonEquivalence :: Comparison a -> Equivalence a
  contramap :: Contravariant f => (a' -> a) -> f a -> f a'
  defaultComparison :: GHC.Classes.Ord a => Comparison a
  defaultEquivalence :: GHC.Classes.Eq a => Equivalence a
  getComparison :: Comparison a -> a -> a -> GHC.Types.Ordering
  getEquivalence :: Equivalence a -> a -> a -> GHC.Types.Bool
  getOp :: Op a b -> b -> a
  getPredicate :: Predicate a -> a -> GHC.Types.Bool
  phantom :: (GHC.Base.Functor f, Contravariant f) => f a -> f b

module Data.Functor.Identity where
  Identity :: a -> Identity a
  type Identity :: * -> *
  newtype Identity a = ...
  runIdentity :: Identity a -> a

module Data.Functor.Product where
  Pair :: forall {k} (f :: k -> *) (g :: k -> *) (a :: k). f a -> g a -> Product f g a
  type role Product representational representational nominal
  type Product :: forall {k}. (k -> *) -> (k -> *) -> k -> *
  data Product f g a = ...

module Data.Functor.Sum where
  InL :: forall {k} (f :: k -> *) (g :: k -> *) (a :: k). f a -> Sum f g a
  InR :: forall {k} (f :: k -> *) (g :: k -> *) (a :: k). g a -> Sum f g a
  type role Sum representational representational nominal
  type Sum :: forall {k}. (k -> *) -> (k -> *) -> k -> *
  data Sum f g a = ...

module Data.IORef where
  type IORef :: * -> *
  newtype IORef a = ...
  atomicModifyIORef :: IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicWriteIORef :: IORef a -> a -> GHC.Types.IO ()
  mkWeakIORef :: IORef a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (IORef a))
  modifyIORef :: IORef a -> (a -> a) -> GHC.Types.IO ()
  modifyIORef' :: IORef a -> (a -> a) -> GHC.Types.IO ()
  newIORef :: a -> GHC.Types.IO (IORef a)
  readIORef :: IORef a -> GHC.Types.IO a
  writeIORef :: IORef a -> a -> GHC.Types.IO ()

module Data.Int where
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...

module Data.Ix where
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a
    ...
  inRange :: Ix a => (a, a) -> a -> GHC.Types.Bool
  index :: Ix a => (a, a) -> a -> GHC.Types.Int
  range :: Ix a => (a, a) -> [a]
  rangeSize :: Ix a => (a, a) -> GHC.Types.Int

module Data.Kind where
  type Constraint :: *
  type Constraint = GHC.Prim.CONSTRAINT GHC.Types.LiftedRep
  type role FUN nominal representational representational
  type FUN :: forall (n :: GHC.Types.Multiplicity) -> * -> * -> *
  data FUN n a b
  type Type :: *
  type Type = TYPE GHC.Types.LiftedRep

module Data.List where
  (!!) :: GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: [a] -> [a] -> [a]
  (\\) :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  all :: Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  and :: Data.Foldable.Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  any :: Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  break :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  concat :: Data.Foldable.Foldable t => t [a] -> [a]
  concatMap :: Data.Foldable.Foldable t => (a -> [b]) -> t a -> [b]
  cycle :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  delete :: GHC.Classes.Eq a => a -> [a] -> [a]
  deleteBy :: (a -> a -> GHC.Types.Bool) -> a -> [a] -> [a]
  deleteFirstsBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  drop :: GHC.Types.Int -> [a] -> [a]
  dropWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  dropWhileEnd :: (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: (Data.Foldable.Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  elemIndex :: GHC.Classes.Eq a => a -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: GHC.Classes.Eq a => a -> [a] -> [GHC.Types.Int]
  filter :: (a -> GHC.Types.Bool) -> [a] -> [a]
  find :: Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Maybe.Maybe a
  findIndex :: (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: (a -> GHC.Types.Bool) -> [a] -> [GHC.Types.Int]
  foldl :: Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl' :: Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl1 :: Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
  foldl1' :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: Data.Foldable.Foldable t => (a -> b -> b) -> b -> t a -> b
  foldr1 :: Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
  genericDrop :: GHC.Real.Integral i => i -> [a] -> [a]
  genericIndex :: GHC.Real.Integral i => [a] -> i -> a
  genericLength :: GHC.Num.Num i => [a] -> i
  genericReplicate :: GHC.Real.Integral i => i -> a -> [a]
  genericSplitAt :: GHC.Real.Integral i => i -> [a] -> ([a], [a])
  genericTake :: GHC.Real.Integral i => i -> [a] -> [a]
  group :: GHC.Classes.Eq a => [a] -> [[a]]
  groupBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [[a]]
  head :: GHC.Stack.Types.HasCallStack => [a] -> a
  init :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  inits :: [a] -> [[a]]
  insert :: GHC.Classes.Ord a => a -> [a] -> [a]
  insertBy :: (a -> a -> GHC.Types.Ordering) -> a -> [a] -> [a]
  intercalate :: [a] -> [[a]] -> [a]
  intersect :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  intersectBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  intersperse :: a -> [a] -> [a]
  isInfixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isPrefixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSubsequenceOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSuffixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  iterate :: (a -> a) -> a -> [a]
  iterate' :: (a -> a) -> a -> [a]
  last :: GHC.Stack.Types.HasCallStack => [a] -> a
  length :: Data.Foldable.Foldable t => t a -> GHC.Types.Int
  lines :: GHC.Base.String -> [GHC.Base.String]
  lookup :: GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: (a -> b) -> [a] -> [b]
  mapAccumL :: Data.Traversable.Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  mapAccumR :: Data.Traversable.Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  maximum :: (Data.Foldable.Foldable t, GHC.Classes.Ord a) => t a -> a
  maximumBy :: Data.Foldable.Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimum :: (Data.Foldable.Foldable t, GHC.Classes.Ord a) => t a -> a
  minimumBy :: Data.Foldable.Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  notElem :: (Data.Foldable.Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  nub :: GHC.Classes.Eq a => [a] -> [a]
  nubBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  null :: Data.Foldable.Foldable t => t a -> GHC.Types.Bool
  or :: Data.Foldable.Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  partition :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  permutations :: [a] -> [[a]]
  product :: (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
  repeat :: a -> [a]
  replicate :: GHC.Types.Int -> a -> [a]
  reverse :: [a] -> [a]
  scanl :: (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: (a -> a -> a) -> [a] -> [a]
  scanr :: (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: (a -> a -> a) -> [a] -> [a]
  singleton :: a -> [a]
  sort :: GHC.Classes.Ord a => [a] -> [a]
  sortBy :: (a -> a -> GHC.Types.Ordering) -> [a] -> [a]
  sortOn :: GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  span :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: GHC.Types.Int -> [a] -> ([a], [a])
  stripPrefix :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Maybe.Maybe [a]
  subsequences :: [a] -> [[a]]
  sum :: (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
  tail :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  tails :: [a] -> [[a]]
  take :: GHC.Types.Int -> [a] -> [a]
  takeWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  transpose :: [[a]] -> [[a]]
  uncons :: [a] -> GHC.Maybe.Maybe (a, [a])
  unfoldr :: (b -> GHC.Maybe.Maybe (a, b)) -> b -> [a]
  union :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  unionBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  unlines :: [GHC.Base.String] -> GHC.Base.String
  unwords :: [GHC.Base.String] -> GHC.Base.String
  unzip :: [(a, b)] -> ([a], [b])
  unzip3 :: [(a, b, c)] -> ([a], [b], [c])
  unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
  unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
  unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
  unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
  words :: GHC.Base.String -> [GHC.Base.String]
  zip :: [a] -> [b] -> [(a, b)]
  zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
  zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
  zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
  zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
  zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
  zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
  zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
  zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
  zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

module Data.List.NonEmpty where
  (!!) :: GHC.Stack.Types.HasCallStack => NonEmpty a -> GHC.Types.Int -> a
  (:|) :: a -> [a] -> NonEmpty a
  (<|) :: a -> NonEmpty a -> NonEmpty a
  type NonEmpty :: * -> *
  data NonEmpty a = ...
  append :: NonEmpty a -> NonEmpty a -> NonEmpty a
  appendList :: NonEmpty a -> [a] -> NonEmpty a
  break :: (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  cons :: a -> NonEmpty a -> NonEmpty a
  cycle :: NonEmpty a -> NonEmpty a
  drop :: GHC.Types.Int -> NonEmpty a -> [a]
  dropWhile :: (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  filter :: (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  fromList :: GHC.Stack.Types.HasCallStack => [a] -> NonEmpty a
  group :: (Data.Foldable.Foldable f, GHC.Classes.Eq a) => f a -> [NonEmpty a]
  group1 :: GHC.Classes.Eq a => NonEmpty a -> NonEmpty (NonEmpty a)
  groupAllWith :: GHC.Classes.Ord b => (a -> b) -> [a] -> [NonEmpty a]
  groupAllWith1 :: GHC.Classes.Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
  groupBy :: Data.Foldable.Foldable f => (a -> a -> GHC.Types.Bool) -> f a -> [NonEmpty a]
  groupBy1 :: (a -> a -> GHC.Types.Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)
  groupWith :: (Data.Foldable.Foldable f, GHC.Classes.Eq b) => (a -> b) -> f a -> [NonEmpty a]
  groupWith1 :: GHC.Classes.Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
  head :: NonEmpty a -> a
  init :: NonEmpty a -> [a]
  inits :: Data.Foldable.Foldable f => f a -> NonEmpty [a]
  inits1 :: NonEmpty a -> NonEmpty (NonEmpty a)
  insert :: (Data.Foldable.Foldable f, GHC.Classes.Ord a) => a -> f a -> NonEmpty a
  intersperse :: a -> NonEmpty a -> NonEmpty a
  isPrefixOf :: GHC.Classes.Eq a => [a] -> NonEmpty a -> GHC.Types.Bool
  iterate :: (a -> a) -> a -> NonEmpty a
  last :: NonEmpty a -> a
  length :: NonEmpty a -> GHC.Types.Int
  map :: (a -> b) -> NonEmpty a -> NonEmpty b
  nonEmpty :: [a] -> GHC.Maybe.Maybe (NonEmpty a)
  nub :: GHC.Classes.Eq a => NonEmpty a -> NonEmpty a
  nubBy :: (a -> a -> GHC.Types.Bool) -> NonEmpty a -> NonEmpty a
  partition :: (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  prependList :: [a] -> NonEmpty a -> NonEmpty a
  repeat :: a -> NonEmpty a
  reverse :: NonEmpty a -> NonEmpty a
  scanl :: Data.Foldable.Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b
  scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a
  scanr :: Data.Foldable.Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b
  scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a
  singleton :: a -> NonEmpty a
  some1 :: GHC.Base.Alternative f => f a -> f (NonEmpty a)
  sort :: GHC.Classes.Ord a => NonEmpty a -> NonEmpty a
  sortBy :: (a -> a -> GHC.Types.Ordering) -> NonEmpty a -> NonEmpty a
  sortWith :: GHC.Classes.Ord o => (a -> o) -> NonEmpty a -> NonEmpty a
  span :: (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  splitAt :: GHC.Types.Int -> NonEmpty a -> ([a], [a])
  tail :: NonEmpty a -> [a]
  tails :: Data.Foldable.Foldable f => f a -> NonEmpty [a]
  tails1 :: NonEmpty a -> NonEmpty (NonEmpty a)
  take :: GHC.Types.Int -> NonEmpty a -> [a]
  takeWhile :: (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  toList :: NonEmpty a -> [a]
  transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)
  uncons :: NonEmpty a -> (a, GHC.Maybe.Maybe (NonEmpty a))
  unfold :: (a -> (b, GHC.Maybe.Maybe a)) -> a -> NonEmpty b
  unfoldr :: (a -> (b, GHC.Maybe.Maybe a)) -> a -> NonEmpty b
  unzip :: GHC.Base.Functor f => f (a, b) -> (f a, f b)
  xor :: NonEmpty GHC.Types.Bool -> GHC.Types.Bool
  zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)
  zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

module Data.Maybe where
  Just :: a -> Maybe a
  type Maybe :: * -> *
  data Maybe a = ...
  Nothing :: Maybe a
  catMaybes :: [Maybe a] -> [a]
  fromJust :: GHC.Stack.Types.HasCallStack => Maybe a -> a
  fromMaybe :: a -> Maybe a -> a
  isJust :: Maybe a -> GHC.Types.Bool
  isNothing :: Maybe a -> GHC.Types.Bool
  listToMaybe :: [a] -> Maybe a
  mapMaybe :: (a -> Maybe b) -> [a] -> [b]
  maybe :: b -> (a -> b) -> Maybe a -> b
  maybeToList :: Maybe a -> [a]

module Data.Monoid where
  (<>) :: GHC.Base.Semigroup a => a -> a -> a
  All :: GHC.Types.Bool -> All
  type All :: *
  newtype All = ...
  Alt :: forall {k} (f :: k -> *) (a :: k). f a -> Alt f a
  type role Alt representational nominal
  type Alt :: forall {k}. (k -> *) -> k -> *
  newtype Alt f a = ...
  Any :: GHC.Types.Bool -> Any
  type Any :: *
  newtype Any = ...
  Ap :: forall {k} (f :: k -> *) (a :: k). f a -> Ap f a
  type role Ap representational nominal
  type Ap :: forall {k}. (k -> *) -> k -> *
  newtype Ap f a = ...
  Dual :: a -> Dual a
  type Dual :: * -> *
  newtype Dual a = ...
  Endo :: (a -> a) -> Endo a
  type Endo :: * -> *
  newtype Endo a = ...
  First :: GHC.Maybe.Maybe a -> First a
  type First :: * -> *
  newtype First a = ...
  Last :: GHC.Maybe.Maybe a -> Last a
  type Last :: * -> *
  newtype Last a = ...
  type Monoid :: * -> Constraint
  class GHC.Base.Semigroup a => Monoid a
    ...
  Product :: a -> Product a
  type Product :: * -> *
  newtype Product a = ...
  Sum :: a -> Sum a
  type Sum :: * -> *
  newtype Sum a = ...
  appEndo :: Endo a -> a -> a
  getAll :: All -> GHC.Types.Bool
  getAlt :: forall {k} (f :: k -> *) (a :: k). Alt f a -> f a
  getAny :: Any -> GHC.Types.Bool
  getAp :: forall {k} (f :: k -> *) (a :: k). Ap f a -> f a
  getDual :: Dual a -> a
  getFirst :: First a -> GHC.Maybe.Maybe a
  getLast :: Last a -> GHC.Maybe.Maybe a
  getProduct :: Product a -> a
  getSum :: Sum a -> a
  mappend :: Monoid a => a -> a -> a
  mconcat :: Monoid a => [a] -> a
  mempty :: Monoid a => a

module Data.Ord where
  (<) :: Ord a => a -> a -> GHC.Types.Bool
  (<=) :: Ord a => a -> a -> GHC.Types.Bool
  (>) :: Ord a => a -> a -> GHC.Types.Bool
  (>=) :: Ord a => a -> a -> GHC.Types.Bool
  Down :: a -> Down a
  type Down :: * -> *
  newtype Down a = ...
  EQ :: Ordering
  GT :: Ordering
  LT :: Ordering
  type Ord :: * -> Constraint
  class GHC.Classes.Eq a => Ord a
    ...
  type Ordering :: *
  data Ordering = ...
  clamp :: Ord a => (a, a) -> a -> a
  compare :: Ord a => a -> a -> Ordering
  comparing :: Ord a => (b -> a) -> b -> b -> Ordering
  getDown :: Down a -> a
  max :: Ord a => a -> a -> a
  min :: Ord a => a -> a -> a

module Data.Proxy where
  KProxy :: KProxy t
  type role KProxy phantom
  type KProxy :: * -> *
  data KProxy t = ...
  Proxy :: forall {k} (t :: k). Proxy t
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = ...
  asProxyTypeOf :: a -> proxy a -> a

module Data.Ratio where
  (%) :: GHC.Real.Integral a => a -> a -> Ratio a
  type Ratio :: * -> *
  data Ratio a = ...
  type Rational :: *
  type Rational = Ratio GHC.Num.Integer.Integer
  approxRational :: GHC.Real.RealFrac a => a -> a -> Rational
  denominator :: Ratio a -> a
  numerator :: Ratio a -> a

module Data.STRef where
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: STRef s a -> (a -> a) -> GHC.ST.ST s ()
  modifySTRef' :: STRef s a -> (a -> a) -> GHC.ST.ST s ()
  newSTRef :: a -> GHC.ST.ST s (STRef s a)
  readSTRef :: STRef s a -> GHC.ST.ST s a
  writeSTRef :: STRef s a -> a -> GHC.ST.ST s ()

module Data.STRef.Lazy where
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: STRef s a -> (a -> a) -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s ()
  newSTRef :: a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s (STRef s a)
  readSTRef :: STRef s a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a
  writeSTRef :: STRef s a -> a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s ()

module Data.STRef.Strict where
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: STRef s a -> (a -> a) -> GHC.ST.ST s ()
  modifySTRef' :: STRef s a -> (a -> a) -> GHC.ST.ST s ()
  newSTRef :: a -> GHC.ST.ST s (STRef s a)
  readSTRef :: STRef s a -> GHC.ST.ST s a
  writeSTRef :: STRef s a -> a -> GHC.ST.ST s ()

module Data.Semigroup where
  (<>) :: Semigroup a => a -> a -> a
  All :: GHC.Types.Bool -> All
  type All :: *
  newtype All = ...
  Any :: GHC.Types.Bool -> Any
  type Any :: *
  newtype Any = ...
  Arg :: a -> b -> Arg a b
  type Arg :: * -> * -> *
  data Arg a b = ...
  type ArgMax :: * -> * -> *
  type ArgMax a b = Max (Arg a b)
  type ArgMin :: * -> * -> *
  type ArgMin a b = Min (Arg a b)
  Dual :: a -> Dual a
  type Dual :: * -> *
  newtype Dual a = ...
  Endo :: (a -> a) -> Endo a
  type Endo :: * -> *
  newtype Endo a = ...
  First :: a -> First a
  type First :: * -> *
  newtype First a = ...
  Last :: a -> Last a
  type Last :: * -> *
  newtype Last a = ...
  Max :: a -> Max a
  type Max :: * -> *
  newtype Max a = ...
  Min :: a -> Min a
  type Min :: * -> *
  newtype Min a = ...
  Product :: a -> Product a
  type Product :: * -> *
  newtype Product a = ...
  type Semigroup :: * -> Constraint
  class Semigroup a
    ...
  Sum :: a -> Sum a
  type Sum :: * -> *
  newtype Sum a = ...
  WrapMonoid :: m -> WrappedMonoid m
  type WrappedMonoid :: * -> *
  newtype WrappedMonoid m = ...
  appEndo :: Endo a -> a -> a
  cycle1 :: Semigroup m => m -> m
  diff :: Semigroup m => m -> Endo m
  getAll :: All -> GHC.Types.Bool
  getAny :: Any -> GHC.Types.Bool
  getDual :: Dual a -> a
  getFirst :: First a -> a
  getLast :: Last a -> a
  getMax :: Max a -> a
  getMin :: Min a -> a
  getProduct :: Product a -> a
  getSum :: Sum a -> a
  mtimesDefault :: (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a
  sconcat :: Semigroup a => GHC.Base.NonEmpty a -> a
  stimes :: (Semigroup a, GHC.Real.Integral b) => b -> a -> a
  stimesIdempotent :: GHC.Real.Integral b => b -> a -> a
  stimesIdempotentMonoid :: (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a
  stimesMonoid :: (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a
  unwrapMonoid :: WrappedMonoid m -> m

module Data.String where
  type IsString :: * -> Constraint
  class IsString a
    ...
  type String :: *
  type String = [GHC.Types.Char]
  fromString :: IsString a => String -> a
  lines :: String -> [String]
  unlines :: [String] -> String
  unwords :: [String] -> String
  words :: String -> [String]

module Data.Traversable where
  type Traversable :: (* -> *) -> Constraint
  class (GHC.Base.Functor t, Data.Foldable.Foldable t) => Traversable t
    ...
  fmapDefault :: Traversable t => (a -> b) -> t a -> t b
  foldMapDefault :: (Traversable t, GHC.Base.Monoid m) => (a -> m) -> t a -> m
  for :: (Traversable t, GHC.Base.Applicative f) => t a -> (a -> f b) -> f (t b)
  forAccumM :: (GHC.Base.Monad m, Traversable t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)
  forM :: (Traversable t, GHC.Base.Monad m) => t a -> (a -> m b) -> m (t b)
  mapAccumL :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  mapAccumM :: (GHC.Base.Monad m, Traversable t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)
  mapAccumR :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  mapM :: (Traversable t, GHC.Base.Monad m) => (a -> m b) -> t a -> m (t b)
  sequence :: (Traversable t, GHC.Base.Monad m) => t (m a) -> m (t a)
  sequenceA :: (Traversable t, GHC.Base.Applicative f) => t (f a) -> f (t a)
  traverse :: (Traversable t, GHC.Base.Applicative f) => (a -> f b) -> t a -> f (t b)

module Data.Tuple where
  MkSolo :: a -> Solo a
  pattern Solo :: a -> Solo a
  type Solo :: * -> *
  data Solo a = ...
  curry :: ((a, b) -> c) -> a -> b -> c
  fst :: (a, b) -> a
  snd :: (a, b) -> b
  swap :: (a, b) -> (b, a)
  uncurry :: (a -> b -> c) -> (a, b) -> c

module Data.Type.Bool where
  type (&&) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  type family (&&) a b
  type If :: forall {k}. GHC.Types.Bool -> k -> k -> k
  type family If cond tru fls
  type Not :: GHC.Types.Bool -> GHC.Types.Bool
  type family Not a = res | res -> a
  type (||) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  type family (||) a b

module Data.Type.Coercion where
  Coercion :: forall {k} (a :: k) (b :: k). Coercible a b => Coercion a b
  type Coercion :: forall {k}. k -> k -> *
  data Coercion a b where
    ...
  type TestCoercion :: forall {k}. (k -> *) -> Constraint
  class TestCoercion f
    ...
  coerceWith :: Coercion a b -> a -> b
  gcoerceWith :: forall {k} (a :: k) (b :: k) r. Coercion a b -> (Coercible a b => r) -> r
  repr :: forall {k} (a :: k) (b :: k). (a Data.Type.Equality.:~: b) -> Coercion a b
  sym :: forall {k} (a :: k) (b :: k). Coercion a b -> Coercion b a
  testCoercion :: forall {k} (f :: k -> *) (a :: k) (b :: k). TestCoercion f => f a -> f b -> GHC.Maybe.Maybe (Coercion a b)
  trans :: forall {k} (a :: k) (b :: k) (c :: k). Coercion a b -> Coercion b c -> Coercion a c

module Data.Type.Equality where
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    ...
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    ...
  type (==) :: forall k. k -> k -> GHC.Types.Bool
  type family (==) a b
  HRefl :: forall {k1} (a :: k1). a :~~: a
  Refl :: forall {k} (a :: k). a :~: a
  type TestEquality :: forall {k}. (k -> *) -> Constraint
  class TestEquality f
    ...
  apply :: forall {k1} {k2} (f :: k1 -> k2) (g :: k1 -> k2) (a :: k1) (b :: k1). (f :~: g) -> (a :~: b) -> f a :~: g b
  castWith :: (a :~: b) -> a -> b
  gcastWith :: forall {k} (a :: k) (b :: k) r. (a :~: b) -> ((a ~ b) => r) -> r
  inner :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> a :~: b
  outer :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> f :~: g
  sym :: forall {k} (a :: k) (b :: k). (a :~: b) -> b :~: a
  testEquality :: forall {k} (f :: k -> *) (a :: k) (b :: k). TestEquality f => f a -> f b -> GHC.Maybe.Maybe (a :~: b)
  trans :: forall {k} (a :: k) (b :: k) (c :: k). (a :~: b) -> (b :~: c) -> a :~: c
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b

module Data.Type.Ord where
  type (<) :: forall {t}. t -> t -> Constraint
  type (<) x y = GHC.TypeError.Assert (x <? y) (Data.Type.Ord.LtErrMsg x y) :: Constraint
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = OrdCond (Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type (<?) :: forall k. k -> k -> GHC.Types.Bool
  type (<?) m n = OrdCond (Compare m n) GHC.Types.True GHC.Types.False GHC.Types.False :: GHC.Types.Bool
  type (>) :: forall {t}. t -> t -> Constraint
  type (>) x y = GHC.TypeError.Assert (x >? y) (Data.Type.Ord.GtErrMsg x y) :: Constraint
  type (>=) :: forall {t}. t -> t -> Constraint
  type (>=) x y = GHC.TypeError.Assert (x >=? y) (Data.Type.Ord.GeErrMsg x y) :: Constraint
  type (>=?) :: forall k. k -> k -> GHC.Types.Bool
  type (>=?) m n = OrdCond (Compare m n) GHC.Types.False GHC.Types.True GHC.Types.True :: GHC.Types.Bool
  type (>?) :: forall k. k -> k -> GHC.Types.Bool
  type (>?) m n = OrdCond (Compare m n) GHC.Types.False GHC.Types.False GHC.Types.True :: GHC.Types.Bool
  type Compare :: forall k. k -> k -> GHC.Types.Ordering
  type family Compare a b
  EQI :: forall {k} (a :: k). (Compare a a ~ GHC.Types.EQ) => OrderingI a a
  GTI :: forall {k} (a :: k) (b :: k). (Compare a b ~ GHC.Types.GT) => OrderingI a b
  LTI :: forall {k} (a :: k) (b :: k). (Compare a b ~ GHC.Types.LT) => OrderingI a b
  type Max :: forall k. k -> k -> k
  type Max m n = OrdCond (Compare m n) n n m :: k
  type Min :: forall k. k -> k -> k
  type Min m n = OrdCond (Compare m n) m m n :: k
  type OrdCond :: forall k. GHC.Types.Ordering -> k -> k -> k -> k
  type family OrdCond o lt eq gt
  type role OrderingI nominal nominal
  type OrderingI :: forall {k}. k -> k -> *
  data OrderingI a b where
    ...

module Data.Typeable where
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    ...
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    ...
  HRefl :: forall {k1} (a :: k1). a :~~: a
  Proxy :: forall {k} (t :: k). Proxy t
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = ...
  Refl :: forall {k} (a :: k). a :~: a
  type TyCon :: *
  data TyCon = ...
  type TypeRep :: *
  type TypeRep = base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  type Typeable :: forall k. k -> Constraint
  class Typeable a
    ...
  cast :: (Typeable a, Typeable b) => a -> GHC.Maybe.Maybe b
  eqT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~: b)
  funResultTy :: TypeRep -> TypeRep -> GHC.Maybe.Maybe TypeRep
  gcast :: forall {k} (a :: k) (b :: k) (c :: k -> *). (Typeable a, Typeable b) => c a -> GHC.Maybe.Maybe (c b)
  gcast1 :: forall {k1} {k2} (c :: k1 -> *) (t :: k2 -> k1) (t' :: k2 -> k1) (a :: k2). (Typeable t, Typeable t') => c (t a) -> GHC.Maybe.Maybe (c (t' a))
  gcast2 :: forall {k1} {k2} {k3} (c :: k1 -> *) (t :: k2 -> k3 -> k1) (t' :: k2 -> k3 -> k1) (a :: k2) (b :: k3). (Typeable t, Typeable t') => c (t a b) -> GHC.Maybe.Maybe (c (t' a b))
  heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~~: b)
  mkFunTy :: TypeRep -> TypeRep -> TypeRep
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: TypeRep -> ()
  showsTypeRep :: TypeRep -> GHC.Show.ShowS
  splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
  trLiftedRep :: base-4.18.0.0:Data.Typeable.Internal.TypeRep GHC.Types.LiftedRep
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  typeOf :: Typeable a => a -> TypeRep
  typeOf1 :: Typeable t => t a -> TypeRep
  typeOf2 :: Typeable t => t a b -> TypeRep
  typeOf3 :: Typeable t => t a b c -> TypeRep
  typeOf4 :: Typeable t => t a b c d -> TypeRep
  typeOf5 :: Typeable t => t a b c d e -> TypeRep
  typeOf6 :: Typeable t => t a b c d e f -> TypeRep
  typeOf7 :: Typeable t => t a b c d e f g -> TypeRep
  typeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
  typeRepArgs :: TypeRep -> [TypeRep]
  typeRepFingerprint :: TypeRep -> GHC.Fingerprint.Type.Fingerprint
  typeRepTyCon :: TypeRep -> TyCon

module Data.Unique where
  type Unique :: *
  newtype Unique = ...
  hashUnique :: Unique -> GHC.Types.Int
  newUnique :: GHC.Types.IO Unique

module Data.Version where
  Version :: [GHC.Types.Int] -> [GHC.Base.String] -> Version
  type Version :: *
  data Version = ...
  makeVersion :: [GHC.Types.Int] -> Version
  parseVersion :: Text.ParserCombinators.ReadP.ReadP Version
  showVersion :: Version -> GHC.Base.String
  versionBranch :: Version -> [GHC.Types.Int]
  versionTags :: Version -> [GHC.Base.String]

module Data.Void where
  type Void :: *
  data Void
  absurd :: Void -> a
  vacuous :: GHC.Base.Functor f => f Void -> f a

module Data.Word where
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64

module Debug.Trace where
  flushEventLog :: GHC.Types.IO ()
  putTraceMsg :: GHC.Base.String -> GHC.Types.IO ()
  trace :: GHC.Base.String -> a -> a
  traceEvent :: GHC.Base.String -> a -> a
  traceEventIO :: GHC.Base.String -> GHC.Types.IO ()
  traceEventWith :: (a -> GHC.Base.String) -> a -> a
  traceIO :: GHC.Base.String -> GHC.Types.IO ()
  traceId :: GHC.Base.String -> GHC.Base.String
  traceM :: GHC.Base.Applicative f => GHC.Base.String -> f ()
  traceMarker :: GHC.Base.String -> a -> a
  traceMarkerIO :: GHC.Base.String -> GHC.Types.IO ()
  traceShow :: GHC.Show.Show a => a -> b -> b
  traceShowId :: GHC.Show.Show a => a -> a
  traceShowM :: (GHC.Show.Show a, GHC.Base.Applicative f) => a -> f ()
  traceShowWith :: GHC.Show.Show b => (a -> b) -> a -> a
  traceStack :: GHC.Base.String -> a -> a
  traceWith :: (a -> GHC.Base.String) -> a -> a

module Foreign where
  (!<<.) :: Bits a => a -> Int -> a
  (!>>.) :: Bits a => a -> Int -> a
  (.&.) :: Bits a => a -> a -> a
  (.<<.) :: Bits a => a -> Int -> a
  (.>>.) :: Bits a => a -> Int -> a
  (.^.) :: Bits a => a -> a -> a
  (.|.) :: Bits a => a -> a -> a
  And :: a -> And a
  type And :: * -> *
  newtype And a = ...
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a
    ...
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = FunPtr (Ptr a -> GHC.Types.IO ())
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b
    ...
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  Iff :: a -> Iff a
  type Iff :: * -> *
  newtype Iff a = ...
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...
  IntPtr :: Int -> IntPtr
  type IntPtr :: *
  newtype IntPtr = ...
  Ior :: a -> Ior a
  type Ior :: * -> *
  newtype Ior a = ...
  type Pool :: *
  newtype Pool = ...
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type StablePtr :: * -> *
  data StablePtr a = ...
  type Storable :: * -> Constraint
  class Storable a
    ...
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  WordPtr :: Word -> WordPtr
  type WordPtr :: *
  newtype WordPtr = ...
  Xor :: a -> Xor a
  type Xor :: * -> *
  newtype Xor a = ...
  addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  advancePtr :: Storable a => Ptr a -> Int -> Ptr a
  alignPtr :: Ptr a -> Int -> Ptr a
  alignment :: Storable a => a -> Int
  alloca :: Storable a => (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: Int -> Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  bit :: Bits a => Int -> a
  bitDefault :: (Bits a, GHC.Num.Num a) => Int -> a
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  bitSize :: Bits a => a -> Int
  bitSizeMaybe :: Bits a => a -> GHC.Maybe.Maybe Int
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  calloc :: Storable a => GHC.Types.IO (Ptr a)
  callocArray :: Storable a => Int -> GHC.Types.IO (Ptr a)
  callocArray0 :: Storable a => Int -> GHC.Types.IO (Ptr a)
  callocBytes :: Int -> GHC.Types.IO (Ptr a)
  castForeignPtr :: ForeignPtr a -> ForeignPtr b
  castFunPtr :: FunPtr a -> FunPtr b
  castFunPtrToPtr :: FunPtr a -> Ptr b
  castPtr :: Ptr a -> Ptr b
  castPtrToFunPtr :: Ptr a -> FunPtr b
  castPtrToStablePtr :: Ptr () -> StablePtr a
  castStablePtrToPtr :: StablePtr a -> Ptr ()
  clearBit :: Bits a => a -> Int -> a
  complement :: Bits a => a -> a
  complementBit :: Bits a => a -> Int -> a
  copyArray :: Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  copyBytes :: Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  countLeadingZeros :: FiniteBits b => b -> Int
  countTrailingZeros :: FiniteBits b => b -> Int
  deRefStablePtr :: StablePtr a -> GHC.Types.IO a
  fillBytes :: Ptr a -> Word8 -> Int -> GHC.Types.IO ()
  finalizeForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  finalizerFree :: FinalizerPtr a
  finiteBitSize :: FiniteBits b => b -> Int
  free :: Ptr a -> GHC.Types.IO ()
  freeHaskellFunPtr :: FunPtr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  freeStablePtr :: StablePtr a -> GHC.Types.IO ()
  fromBool :: GHC.Num.Num a => GHC.Types.Bool -> a
  getAnd :: And a -> a
  getIff :: Iff a -> a
  getIor :: Ior a -> a
  getXor :: Xor a -> a
  intPtrToPtr :: IntPtr -> Ptr a
  isSigned :: Bits a => a -> GHC.Types.Bool
  lengthArray0 :: (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO Int
  malloc :: Storable a => GHC.Types.IO (Ptr a)
  mallocArray :: Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocArray0 :: Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocBytes :: Int -> GHC.Types.IO (Ptr a)
  mallocForeignPtr :: Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: Int -> GHC.Types.IO (ForeignPtr a)
  maybeNew :: (a -> GHC.Types.IO (Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (Ptr b)
  maybePeek :: (Ptr a -> GHC.Types.IO b) -> Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: (a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  minusPtr :: Ptr a -> Ptr b -> Int
  moveArray :: Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  moveBytes :: Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  new :: Storable a => a -> GHC.Types.IO (Ptr a)
  newArray :: Storable a => [a] -> GHC.Types.IO (Ptr a)
  newArray0 :: Storable a => a -> [a] -> GHC.Types.IO (Ptr a)
  newForeignPtr :: FinalizerPtr a -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: Ptr a -> GHC.Types.IO (ForeignPtr a)
  newPool :: GHC.Types.IO Pool
  newStablePtr :: a -> GHC.Types.IO (StablePtr a)
  nullFunPtr :: FunPtr a
  nullPtr :: Ptr a
  oneBits :: FiniteBits a => a
  peek :: Storable a => Ptr a -> GHC.Types.IO a
  peekArray :: Storable a => Int -> Ptr a -> GHC.Types.IO [a]
  peekArray0 :: (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO [a]
  peekByteOff :: Storable a => Ptr b -> Int -> GHC.Types.IO a
  peekElemOff :: Storable a => Ptr a -> Int -> GHC.Types.IO a
  plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b
  plusPtr :: Ptr a -> Int -> Ptr b
  poke :: Storable a => Ptr a -> a -> GHC.Types.IO ()
  pokeArray :: Storable a => Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: Storable a => a -> Ptr a -> [a] -> GHC.Types.IO ()
  pokeByteOff :: Storable a => Ptr b -> Int -> a -> GHC.Types.IO ()
  pokeElemOff :: Storable a => Ptr a -> Int -> a -> GHC.Types.IO ()
  pooledMalloc :: Storable a => Pool -> GHC.Types.IO (Ptr a)
  pooledMallocArray :: Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocArray0 :: Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocBytes :: Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledNew :: Storable a => Pool -> a -> GHC.Types.IO (Ptr a)
  pooledNewArray :: Storable a => Pool -> [a] -> GHC.Types.IO (Ptr a)
  pooledNewArray0 :: Storable a => Pool -> a -> [a] -> GHC.Types.IO (Ptr a)
  pooledRealloc :: Storable a => Pool -> Ptr a -> GHC.Types.IO (Ptr a)
  pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocBytes :: Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  popCount :: Bits a => a -> Int
  popCountDefault :: (Bits a, GHC.Num.Num a) => a -> Int
  ptrToIntPtr :: Ptr a -> IntPtr
  ptrToWordPtr :: Ptr a -> WordPtr
  realloc :: Storable b => Ptr a -> GHC.Types.IO (Ptr b)
  reallocArray :: Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocArray0 :: Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocBytes :: Ptr a -> Int -> GHC.Types.IO (Ptr a)
  rotate :: Bits a => a -> Int -> a
  rotateL :: Bits a => a -> Int -> a
  rotateR :: Bits a => a -> Int -> a
  setBit :: Bits a => a -> Int -> a
  shift :: Bits a => a -> Int -> a
  shiftL :: Bits a => a -> Int -> a
  shiftR :: Bits a => a -> Int -> a
  sizeOf :: Storable a => a -> Int
  testBit :: Bits a => a -> Int -> GHC.Types.Bool
  testBitDefault :: (Bits a, GHC.Num.Num a) => a -> Int -> GHC.Types.Bool
  throwIf :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: GHC.Base.String -> GHC.Types.IO (Ptr a) -> GHC.Types.IO (Ptr a)
  throwIf_ :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  toIntegralSized :: (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  touchForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  unsafeShiftL :: Bits a => a -> Int -> a
  unsafeShiftR :: Bits a => a -> Int -> a
  void :: GHC.Types.IO a -> GHC.Types.IO ()
  with :: Storable a => a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: Storable a => [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: Storable a => a -> [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: ForeignPtr a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: (Pool -> GHC.Types.IO b) -> GHC.Types.IO b
  wordPtrToPtr :: WordPtr -> Ptr a
  xor :: Bits a => a -> a -> a
  zeroBits :: Bits a => a

module Foreign.C where
  CBool :: GHC.Word.Word8 -> CBool
  type CBool :: *
  newtype CBool = ...
  CChar :: GHC.Int.Int8 -> CChar
  type CChar :: *
  newtype CChar = ...
  CClock :: GHC.Int.Int64 -> CClock
  type CClock :: *
  newtype CClock = ...
  CDouble :: GHC.Types.Double -> CDouble
  type CDouble :: *
  newtype CDouble = ...
  type CFile :: *
  data CFile = ...
  CFloat :: GHC.Types.Float -> CFloat
  type CFloat :: *
  newtype CFloat = ...
  type CFpos :: *
  data CFpos = ...
  CInt :: GHC.Int.Int32 -> CInt
  type CInt :: *
  newtype CInt = ...
  CIntMax :: GHC.Int.Int64 -> CIntMax
  type CIntMax :: *
  newtype CIntMax = ...
  CIntPtr :: GHC.Int.Int64 -> CIntPtr
  type CIntPtr :: *
  newtype CIntPtr = ...
  type CJmpBuf :: *
  data CJmpBuf = ...
  CLLong :: GHC.Int.Int64 -> CLLong
  type CLLong :: *
  newtype CLLong = ...
  CLong :: GHC.Int.Int64 -> CLong
  type CLong :: *
  newtype CLong = ...
  CPtrdiff :: GHC.Int.Int64 -> CPtrdiff
  type CPtrdiff :: *
  newtype CPtrdiff = ...
  CSChar :: GHC.Int.Int8 -> CSChar
  type CSChar :: *
  newtype CSChar = ...
  CSUSeconds :: GHC.Int.Int64 -> CSUSeconds
  type CSUSeconds :: *
  newtype CSUSeconds = ...
  CShort :: GHC.Int.Int16 -> CShort
  type CShort :: *
  newtype CShort = ...
  CSigAtomic :: GHC.Int.Int32 -> CSigAtomic
  type CSigAtomic :: *
  newtype CSigAtomic = ...
  CSize :: GHC.Word.Word64 -> CSize
  type CSize :: *
  newtype CSize = ...
  type CString :: *
  type CString = GHC.Ptr.Ptr CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr CChar, GHC.Types.Int)
  CTime :: GHC.Int.Int64 -> CTime
  type CTime :: *
  newtype CTime = ...
  CUChar :: GHC.Word.Word8 -> CUChar
  type CUChar :: *
  newtype CUChar = ...
  CUInt :: GHC.Word.Word32 -> CUInt
  type CUInt :: *
  newtype CUInt = ...
  CUIntMax :: GHC.Word.Word64 -> CUIntMax
  type CUIntMax :: *
  newtype CUIntMax = ...
  CUIntPtr :: GHC.Word.Word64 -> CUIntPtr
  type CUIntPtr :: *
  newtype CUIntPtr = ...
  CULLong :: GHC.Word.Word64 -> CULLong
  type CULLong :: *
  newtype CULLong = ...
  CULong :: GHC.Word.Word64 -> CULong
  type CULong :: *
  newtype CULong = ...
  CUSeconds :: GHC.Word.Word32 -> CUSeconds
  type CUSeconds :: *
  newtype CUSeconds = ...
  CUShort :: GHC.Word.Word16 -> CUShort
  type CUShort :: *
  newtype CUShort = ...
  type CWString :: *
  type CWString = GHC.Ptr.Ptr CWchar
  type CWStringLen :: *
  type CWStringLen = (GHC.Ptr.Ptr CWchar, GHC.Types.Int)
  CWchar :: GHC.Int.Int32 -> CWchar
  type CWchar :: *
  newtype CWchar = ...
  Errno :: CInt -> Errno
  type Errno :: *
  newtype Errno = ...
  castCCharToChar :: CChar -> GHC.Types.Char
  castCSCharToChar :: CSChar -> GHC.Types.Char
  castCUCharToChar :: CUChar -> GHC.Types.Char
  castCharToCChar :: GHC.Types.Char -> CChar
  castCharToCSChar :: GHC.Types.Char -> CSChar
  castCharToCUChar :: GHC.Types.Char -> CUChar
  charIsRepresentable :: GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  e2BIG :: Errno
  eACCES :: Errno
  eADDRINUSE :: Errno
  eADDRNOTAVAIL :: Errno
  eADV :: Errno
  eAFNOSUPPORT :: Errno
  eAGAIN :: Errno
  eALREADY :: Errno
  eBADF :: Errno
  eBADMSG :: Errno
  eBADRPC :: Errno
  eBUSY :: Errno
  eCHILD :: Errno
  eCOMM :: Errno
  eCONNABORTED :: Errno
  eCONNREFUSED :: Errno
  eCONNRESET :: Errno
  eDEADLK :: Errno
  eDESTADDRREQ :: Errno
  eDIRTY :: Errno
  eDOM :: Errno
  eDQUOT :: Errno
  eEXIST :: Errno
  eFAULT :: Errno
  eFBIG :: Errno
  eFTYPE :: Errno
  eHOSTDOWN :: Errno
  eHOSTUNREACH :: Errno
  eIDRM :: Errno
  eILSEQ :: Errno
  eINPROGRESS :: Errno
  eINTR :: Errno
  eINVAL :: Errno
  eIO :: Errno
  eISCONN :: Errno
  eISDIR :: Errno
  eLOOP :: Errno
  eMFILE :: Errno
  eMLINK :: Errno
  eMSGSIZE :: Errno
  eMULTIHOP :: Errno
  eNAMETOOLONG :: Errno
  eNETDOWN :: Errno
  eNETRESET :: Errno
  eNETUNREACH :: Errno
  eNFILE :: Errno
  eNOBUFS :: Errno
  eNODATA :: Errno
  eNODEV :: Errno
  eNOENT :: Errno
  eNOEXEC :: Errno
  eNOLCK :: Errno
  eNOLINK :: Errno
  eNOMEM :: Errno
  eNOMSG :: Errno
  eNONET :: Errno
  eNOPROTOOPT :: Errno
  eNOSPC :: Errno
  eNOSR :: Errno
  eNOSTR :: Errno
  eNOSYS :: Errno
  eNOTBLK :: Errno
  eNOTCONN :: Errno
  eNOTDIR :: Errno
  eNOTEMPTY :: Errno
  eNOTSOCK :: Errno
  eNOTSUP :: Errno
  eNOTTY :: Errno
  eNXIO :: Errno
  eOK :: Errno
  eOPNOTSUPP :: Errno
  ePERM :: Errno
  ePFNOSUPPORT :: Errno
  ePIPE :: Errno
  ePROCLIM :: Errno
  ePROCUNAVAIL :: Errno
  ePROGMISMATCH :: Errno
  ePROGUNAVAIL :: Errno
  ePROTO :: Errno
  ePROTONOSUPPORT :: Errno
  ePROTOTYPE :: Errno
  eRANGE :: Errno
  eREMCHG :: Errno
  eREMOTE :: Errno
  eROFS :: Errno
  eRPCMISMATCH :: Errno
  eRREMOTE :: Errno
  eSHUTDOWN :: Errno
  eSOCKTNOSUPPORT :: Errno
  eSPIPE :: Errno
  eSRCH :: Errno
  eSRMNT :: Errno
  eSTALE :: Errno
  eTIME :: Errno
  eTIMEDOUT :: Errno
  eTOOMANYREFS :: Errno
  eTXTBSY :: Errno
  eUSERS :: Errno
  eWOULDBLOCK :: Errno
  eXDEV :: Errno
  errnoToIOError :: GHC.Base.String -> Errno -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.Base.String -> GHC.IO.Exception.IOError
  getErrno :: GHC.Types.IO Errno
  isValidErrno :: Errno -> GHC.Types.Bool
  newCAString :: GHC.Base.String -> GHC.Types.IO CString
  newCAStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCString :: GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCWString :: GHC.Base.String -> GHC.Types.IO CWString
  newCWStringLen :: GHC.Base.String -> GHC.Types.IO CWStringLen
  peekCAString :: CString -> GHC.Types.IO GHC.Base.String
  peekCAStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCString :: CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCWString :: CWString -> GHC.Types.IO GHC.Base.String
  peekCWStringLen :: CWStringLen -> GHC.Types.IO GHC.Base.String
  resetErrno :: GHC.Types.IO ()
  throwErrno :: GHC.Base.String -> GHC.Types.IO a
  throwErrnoIf :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1 :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1Retry :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfMinus1Retry_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfMinus1_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfNull :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetry :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetryMayBlock :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO b -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfRetry :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfRetry_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIf_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPath :: GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a
  throwErrnoPathIf :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1 :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPathIfNull :: GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoPathIf_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  withCAString :: GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCAStringLen :: GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCString :: GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWString :: GHC.Base.String -> (CWString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWStringLen :: GHC.Base.String -> (CWStringLen -> GHC.Types.IO a) -> GHC.Types.IO a

module Foreign.C.ConstPtr where
  ConstPtr :: GHC.Ptr.Ptr a -> ConstPtr a
  type role ConstPtr phantom
  type ConstPtr :: * -> *
  newtype ConstPtr a = ...
  unConstPtr :: ConstPtr a -> GHC.Ptr.Ptr a

module Foreign.C.Error where
  Errno :: Foreign.C.Types.CInt -> Errno
  type Errno :: *
  newtype Errno = ...
  e2BIG :: Errno
  eACCES :: Errno
  eADDRINUSE :: Errno
  eADDRNOTAVAIL :: Errno
  eADV :: Errno
  eAFNOSUPPORT :: Errno
  eAGAIN :: Errno
  eALREADY :: Errno
  eBADF :: Errno
  eBADMSG :: Errno
  eBADRPC :: Errno
  eBUSY :: Errno
  eCHILD :: Errno
  eCOMM :: Errno
  eCONNABORTED :: Errno
  eCONNREFUSED :: Errno
  eCONNRESET :: Errno
  eDEADLK :: Errno
  eDESTADDRREQ :: Errno
  eDIRTY :: Errno
  eDOM :: Errno
  eDQUOT :: Errno
  eEXIST :: Errno
  eFAULT :: Errno
  eFBIG :: Errno
  eFTYPE :: Errno
  eHOSTDOWN :: Errno
  eHOSTUNREACH :: Errno
  eIDRM :: Errno
  eILSEQ :: Errno
  eINPROGRESS :: Errno
  eINTR :: Errno
  eINVAL :: Errno
  eIO :: Errno
  eISCONN :: Errno
  eISDIR :: Errno
  eLOOP :: Errno
  eMFILE :: Errno
  eMLINK :: Errno
  eMSGSIZE :: Errno
  eMULTIHOP :: Errno
  eNAMETOOLONG :: Errno
  eNETDOWN :: Errno
  eNETRESET :: Errno
  eNETUNREACH :: Errno
  eNFILE :: Errno
  eNOBUFS :: Errno
  eNODATA :: Errno
  eNODEV :: Errno
  eNOENT :: Errno
  eNOEXEC :: Errno
  eNOLCK :: Errno
  eNOLINK :: Errno
  eNOMEM :: Errno
  eNOMSG :: Errno
  eNONET :: Errno
  eNOPROTOOPT :: Errno
  eNOSPC :: Errno
  eNOSR :: Errno
  eNOSTR :: Errno
  eNOSYS :: Errno
  eNOTBLK :: Errno
  eNOTCONN :: Errno
  eNOTDIR :: Errno
  eNOTEMPTY :: Errno
  eNOTSOCK :: Errno
  eNOTSUP :: Errno
  eNOTTY :: Errno
  eNXIO :: Errno
  eOK :: Errno
  eOPNOTSUPP :: Errno
  ePERM :: Errno
  ePFNOSUPPORT :: Errno
  ePIPE :: Errno
  ePROCLIM :: Errno
  ePROCUNAVAIL :: Errno
  ePROGMISMATCH :: Errno
  ePROGUNAVAIL :: Errno
  ePROTO :: Errno
  ePROTONOSUPPORT :: Errno
  ePROTOTYPE :: Errno
  eRANGE :: Errno
  eREMCHG :: Errno
  eREMOTE :: Errno
  eROFS :: Errno
  eRPCMISMATCH :: Errno
  eRREMOTE :: Errno
  eSHUTDOWN :: Errno
  eSOCKTNOSUPPORT :: Errno
  eSPIPE :: Errno
  eSRCH :: Errno
  eSRMNT :: Errno
  eSTALE :: Errno
  eTIME :: Errno
  eTIMEDOUT :: Errno
  eTOOMANYREFS :: Errno
  eTXTBSY :: Errno
  eUSERS :: Errno
  eWOULDBLOCK :: Errno
  eXDEV :: Errno
  errnoToIOError :: GHC.Base.String -> Errno -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.Base.String -> GHC.IO.Exception.IOError
  getErrno :: GHC.Types.IO Errno
  isValidErrno :: Errno -> GHC.Types.Bool
  resetErrno :: GHC.Types.IO ()
  throwErrno :: GHC.Base.String -> GHC.Types.IO a
  throwErrnoIf :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1 :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1Retry :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfMinus1Retry_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfMinus1_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfNull :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetry :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetryMayBlock :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO b -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfRetry :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfRetry_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIf_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPath :: GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a
  throwErrnoPathIf :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1 :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1_ :: (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPathIfNull :: GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoPathIf_ :: (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()

module Foreign.C.String where
  type CString :: *
  type CString = GHC.Ptr.Ptr Foreign.C.Types.CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CChar, GHC.Types.Int)
  type CWString :: *
  type CWString = GHC.Ptr.Ptr Foreign.C.Types.CWchar
  type CWStringLen :: *
  type CWStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CWchar, GHC.Types.Int)
  castCCharToChar :: Foreign.C.Types.CChar -> GHC.Types.Char
  castCSCharToChar :: Foreign.C.Types.CSChar -> GHC.Types.Char
  castCUCharToChar :: Foreign.C.Types.CUChar -> GHC.Types.Char
  castCharToCChar :: GHC.Types.Char -> Foreign.C.Types.CChar
  castCharToCSChar :: GHC.Types.Char -> Foreign.C.Types.CSChar
  castCharToCUChar :: GHC.Types.Char -> Foreign.C.Types.CUChar
  charIsRepresentable :: GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  newCAString :: GHC.Base.String -> GHC.Types.IO CString
  newCAStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCString :: GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCWString :: GHC.Base.String -> GHC.Types.IO CWString
  newCWStringLen :: GHC.Base.String -> GHC.Types.IO CWStringLen
  peekCAString :: CString -> GHC.Types.IO GHC.Base.String
  peekCAStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCString :: CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCWString :: CWString -> GHC.Types.IO GHC.Base.String
  peekCWStringLen :: CWStringLen -> GHC.Types.IO GHC.Base.String
  withCAString :: GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCAStringLen :: GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCString :: GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWString :: GHC.Base.String -> (CWString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWStringLen :: GHC.Base.String -> (CWStringLen -> GHC.Types.IO a) -> GHC.Types.IO a

module Foreign.C.Types where

-- ignored


module Foreign.Concurrent where
  addForeignPtrFinalizer :: GHC.ForeignPtr.ForeignPtr a -> GHC.Types.IO () -> GHC.Types.IO ()
  newForeignPtr :: GHC.Ptr.Ptr a -> GHC.Types.IO () -> GHC.Types.IO (GHC.ForeignPtr.ForeignPtr a)

module Foreign.ForeignPtr where
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr :: FinalizerPtr a -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  plusForeignPtr :: ForeignPtr a -> GHC.Types.Int -> ForeignPtr b
  touchForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  withForeignPtr :: ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.ForeignPtr.Safe where
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr :: FinalizerPtr a -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  touchForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  withForeignPtr :: ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.ForeignPtr.Unsafe where
  unsafeForeignPtrToPtr :: GHC.ForeignPtr.ForeignPtr a -> GHC.Ptr.Ptr a

module Foreign.Marshal where
  type Pool :: *
  newtype Pool = ...
  advancePtr :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  alloca :: Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  copyBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  finalizerFree :: GHC.ForeignPtr.FinalizerPtr a
  free :: GHC.Ptr.Ptr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  fromBool :: GHC.Num.Num a => GHC.Types.Bool -> a
  lengthArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  malloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  maybeNew :: (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  moveBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray :: Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newPool :: GHC.Types.IO Pool
  peekArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocBytes :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  void :: GHC.Types.IO a -> GHC.Types.IO ()
  with :: Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Alloc where
  alloca :: Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  finalizerFree :: GHC.ForeignPtr.FinalizerPtr a
  free :: GHC.Ptr.Ptr a -> GHC.Types.IO ()
  malloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocBytes :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)

module Foreign.Marshal.Array where
  advancePtr :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  allocaArray :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  callocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  lengthArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  mallocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  moveArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  newArray :: Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  peekArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  reallocArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  withArray :: Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Error where
  throwIf :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  void :: GHC.Types.IO a -> GHC.Types.IO ()

module Foreign.Marshal.Pool where
  type Pool :: *
  newtype Pool = ...
  freePool :: Pool -> GHC.Types.IO ()
  newPool :: GHC.Types.IO Pool
  pooledMalloc :: Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  withPool :: (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Safe where
  type Pool :: *
  newtype Pool = ...
  advancePtr :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  alloca :: Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  copyBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  finalizerFree :: GHC.ForeignPtr.FinalizerPtr a
  free :: GHC.Ptr.Ptr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  fromBool :: GHC.Num.Num a => GHC.Types.Bool -> a
  lengthArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  malloc :: Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  maybeNew :: (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  moveBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray :: Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newPool :: GHC.Types.IO Pool
  peekArray :: Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocArray :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocBytes :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  void :: GHC.Types.IO a -> GHC.Types.IO ()
  with :: Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Unsafe where
  unsafeLocalState :: GHC.Types.IO a -> a

module Foreign.Marshal.Utils where
  copyBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  fromBool :: GHC.Num.Num a => GHC.Types.Bool -> a
  maybeNew :: (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveBytes :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  toBool :: (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  with :: Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

module Foreign.Ptr where
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  IntPtr :: GHC.Types.Int -> IntPtr
  type IntPtr :: *
  newtype IntPtr = ...
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  WordPtr :: GHC.Types.Word -> WordPtr
  type WordPtr :: *
  newtype WordPtr = ...
  alignPtr :: Ptr a -> GHC.Types.Int -> Ptr a
  castFunPtr :: FunPtr a -> FunPtr b
  castFunPtrToPtr :: FunPtr a -> Ptr b
  castPtr :: Ptr a -> Ptr b
  castPtrToFunPtr :: Ptr a -> FunPtr b
  freeHaskellFunPtr :: FunPtr a -> GHC.Types.IO ()
  intPtrToPtr :: IntPtr -> Ptr a
  minusPtr :: Ptr a -> Ptr b -> GHC.Types.Int
  nullFunPtr :: FunPtr a
  nullPtr :: Ptr a
  plusPtr :: Ptr a -> GHC.Types.Int -> Ptr b
  ptrToIntPtr :: Ptr a -> IntPtr
  ptrToWordPtr :: Ptr a -> WordPtr
  wordPtrToPtr :: WordPtr -> Ptr a

module Foreign.Safe where
  (!<<.) :: Bits a => a -> Int -> a
  (!>>.) :: Bits a => a -> Int -> a
  (.&.) :: Bits a => a -> a -> a
  (.<<.) :: Bits a => a -> Int -> a
  (.>>.) :: Bits a => a -> Int -> a
  (.^.) :: Bits a => a -> a -> a
  (.|.) :: Bits a => a -> a -> a
  And :: a -> And a
  type And :: * -> *
  newtype And a = ...
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a
    ...
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = FunPtr (Ptr a -> GHC.Types.IO ())
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b
    ...
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  Iff :: a -> Iff a
  type Iff :: * -> *
  newtype Iff a = ...
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...
  IntPtr :: Int -> IntPtr
  type IntPtr :: *
  newtype IntPtr = ...
  Ior :: a -> Ior a
  type Ior :: * -> *
  newtype Ior a = ...
  type Pool :: *
  newtype Pool = ...
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type StablePtr :: * -> *
  data StablePtr a = ...
  type Storable :: * -> Constraint
  class Storable a
    ...
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  WordPtr :: Word -> WordPtr
  type WordPtr :: *
  newtype WordPtr = ...
  Xor :: a -> Xor a
  type Xor :: * -> *
  newtype Xor a = ...
  addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  advancePtr :: Storable a => Ptr a -> Int -> Ptr a
  alignPtr :: Ptr a -> Int -> Ptr a
  alignment :: Storable a => a -> Int
  alloca :: Storable a => (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: Int -> Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  bit :: Bits a => Int -> a
  bitDefault :: (Bits a, GHC.Num.Num a) => Int -> a
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  bitSize :: Bits a => a -> Int
  bitSizeMaybe :: Bits a => a -> GHC.Maybe.Maybe Int
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  calloc :: Storable a => GHC.Types.IO (Ptr a)
  callocArray :: Storable a => Int -> GHC.Types.IO (Ptr a)
  callocArray0 :: Storable a => Int -> GHC.Types.IO (Ptr a)
  callocBytes :: Int -> GHC.Types.IO (Ptr a)
  castForeignPtr :: ForeignPtr a -> ForeignPtr b
  castFunPtr :: FunPtr a -> FunPtr b
  castFunPtrToPtr :: FunPtr a -> Ptr b
  castPtr :: Ptr a -> Ptr b
  castPtrToFunPtr :: Ptr a -> FunPtr b
  castPtrToStablePtr :: Ptr () -> StablePtr a
  castStablePtrToPtr :: StablePtr a -> Ptr ()
  clearBit :: Bits a => a -> Int -> a
  complement :: Bits a => a -> a
  complementBit :: Bits a => a -> Int -> a
  copyArray :: Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  copyBytes :: Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  countLeadingZeros :: FiniteBits b => b -> Int
  countTrailingZeros :: FiniteBits b => b -> Int
  deRefStablePtr :: StablePtr a -> GHC.Types.IO a
  fillBytes :: Ptr a -> Word8 -> Int -> GHC.Types.IO ()
  finalizeForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  finalizerFree :: FinalizerPtr a
  finiteBitSize :: FiniteBits b => b -> Int
  free :: Ptr a -> GHC.Types.IO ()
  freeHaskellFunPtr :: FunPtr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  freeStablePtr :: StablePtr a -> GHC.Types.IO ()
  fromBool :: GHC.Num.Num a => GHC.Types.Bool -> a
  getAnd :: And a -> a
  getIff :: Iff a -> a
  getIor :: Ior a -> a
  getXor :: Xor a -> a
  intPtrToPtr :: IntPtr -> Ptr a
  isSigned :: Bits a => a -> GHC.Types.Bool
  lengthArray0 :: (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO Int
  malloc :: Storable a => GHC.Types.IO (Ptr a)
  mallocArray :: Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocArray0 :: Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocBytes :: Int -> GHC.Types.IO (Ptr a)
  mallocForeignPtr :: Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: Int -> GHC.Types.IO (ForeignPtr a)
  maybeNew :: (a -> GHC.Types.IO (Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (Ptr b)
  maybePeek :: (Ptr a -> GHC.Types.IO b) -> Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: (a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  minusPtr :: Ptr a -> Ptr b -> Int
  moveArray :: Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  moveBytes :: Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  new :: Storable a => a -> GHC.Types.IO (Ptr a)
  newArray :: Storable a => [a] -> GHC.Types.IO (Ptr a)
  newArray0 :: Storable a => a -> [a] -> GHC.Types.IO (Ptr a)
  newForeignPtr :: FinalizerPtr a -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: Ptr a -> GHC.Types.IO (ForeignPtr a)
  newPool :: GHC.Types.IO Pool
  newStablePtr :: a -> GHC.Types.IO (StablePtr a)
  nullFunPtr :: FunPtr a
  nullPtr :: Ptr a
  oneBits :: FiniteBits a => a
  peek :: Storable a => Ptr a -> GHC.Types.IO a
  peekArray :: Storable a => Int -> Ptr a -> GHC.Types.IO [a]
  peekArray0 :: (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO [a]
  peekByteOff :: Storable a => Ptr b -> Int -> GHC.Types.IO a
  peekElemOff :: Storable a => Ptr a -> Int -> GHC.Types.IO a
  plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b
  plusPtr :: Ptr a -> Int -> Ptr b
  poke :: Storable a => Ptr a -> a -> GHC.Types.IO ()
  pokeArray :: Storable a => Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: Storable a => a -> Ptr a -> [a] -> GHC.Types.IO ()
  pokeByteOff :: Storable a => Ptr b -> Int -> a -> GHC.Types.IO ()
  pokeElemOff :: Storable a => Ptr a -> Int -> a -> GHC.Types.IO ()
  pooledMalloc :: Storable a => Pool -> GHC.Types.IO (Ptr a)
  pooledMallocArray :: Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocArray0 :: Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocBytes :: Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledNew :: Storable a => Pool -> a -> GHC.Types.IO (Ptr a)
  pooledNewArray :: Storable a => Pool -> [a] -> GHC.Types.IO (Ptr a)
  pooledNewArray0 :: Storable a => Pool -> a -> [a] -> GHC.Types.IO (Ptr a)
  pooledRealloc :: Storable a => Pool -> Ptr a -> GHC.Types.IO (Ptr a)
  pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocBytes :: Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  popCount :: Bits a => a -> Int
  popCountDefault :: (Bits a, GHC.Num.Num a) => a -> Int
  ptrToIntPtr :: Ptr a -> IntPtr
  ptrToWordPtr :: Ptr a -> WordPtr
  realloc :: Storable b => Ptr a -> GHC.Types.IO (Ptr b)
  reallocArray :: Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocArray0 :: Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocBytes :: Ptr a -> Int -> GHC.Types.IO (Ptr a)
  rotate :: Bits a => a -> Int -> a
  rotateL :: Bits a => a -> Int -> a
  rotateR :: Bits a => a -> Int -> a
  setBit :: Bits a => a -> Int -> a
  shift :: Bits a => a -> Int -> a
  shiftL :: Bits a => a -> Int -> a
  shiftR :: Bits a => a -> Int -> a
  sizeOf :: Storable a => a -> Int
  testBit :: Bits a => a -> Int -> GHC.Types.Bool
  testBitDefault :: (Bits a, GHC.Num.Num a) => a -> Int -> GHC.Types.Bool
  throwIf :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: GHC.Base.String -> GHC.Types.IO (Ptr a) -> GHC.Types.IO (Ptr a)
  throwIf_ :: (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  toIntegralSized :: (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  touchForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  unsafeShiftL :: Bits a => a -> Int -> a
  unsafeShiftR :: Bits a => a -> Int -> a
  void :: GHC.Types.IO a -> GHC.Types.IO ()
  with :: Storable a => a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: Storable a => [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: Storable a => a -> [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: ForeignPtr a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: (Pool -> GHC.Types.IO b) -> GHC.Types.IO b
  wordPtrToPtr :: WordPtr -> Ptr a
  xor :: Bits a => a -> a -> a
  zeroBits :: Bits a => a

module Foreign.StablePtr where
  type StablePtr :: * -> *
  data StablePtr a = ...
  castPtrToStablePtr :: GHC.Ptr.Ptr () -> StablePtr a
  castStablePtrToPtr :: StablePtr a -> GHC.Ptr.Ptr ()
  deRefStablePtr :: StablePtr a -> GHC.Types.IO a
  freeStablePtr :: StablePtr a -> GHC.Types.IO ()
  newStablePtr :: a -> GHC.Types.IO (StablePtr a)

module Foreign.Storable where
  type Storable :: * -> Constraint
  class Storable a
    ...
  alignment :: Storable a => a -> GHC.Types.Int
  peek :: Storable a => GHC.Ptr.Ptr a -> GHC.Types.IO a
  peekByteOff :: Storable a => GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
  peekElemOff :: Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
  poke :: Storable a => GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
  pokeByteOff :: Storable a => GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
  pokeElemOff :: Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
  sizeOf :: Storable a => a -> GHC.Types.Int

module GHC.Arr where
  (!) :: Ix i => Array i e -> i -> e
  (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
  Array :: i -> i -> GHC.Types.Int -> GHC.Prim.Array# e -> Array i e
  type role Array nominal representational
  type Array :: * -> * -> *
  data Array i e = ...
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a
    ...
  STArray :: i -> i -> GHC.Types.Int -> GHC.Prim.MutableArray# s e -> STArray s i e
  type role STArray nominal nominal representational
  type STArray :: * -> * -> * -> *
  data STArray s i e = ...
  accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
  accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
  adjust :: (e -> a -> e) -> GHC.Prim.MutableArray# s e -> (GHC.Types.Int, a) -> GHC.ST.STRep s b -> GHC.ST.STRep s b
  amap :: (a -> b) -> Array i a -> Array i b
  arrEleBottom :: a
  array :: Ix i => (i, i) -> [(i, e)] -> Array i e
  assocs :: Ix i => Array i e -> [(i, e)]
  badSafeIndex :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  bounds :: Array i e -> (i, i)
  boundsSTArray :: STArray s i e -> (i, i)
  cmpArray :: (Ix i, GHC.Classes.Ord e) => Array i e -> Array i e -> GHC.Types.Ordering
  cmpIntArray :: GHC.Classes.Ord e => Array GHC.Types.Int e -> Array GHC.Types.Int e -> GHC.Types.Ordering
  done :: i -> i -> GHC.Types.Int -> GHC.Prim.MutableArray# s e -> GHC.ST.STRep s (Array i e)
  elems :: Array i e -> [e]
  eqArray :: (Ix i, GHC.Classes.Eq e) => Array i e -> Array i e -> GHC.Types.Bool
  fill :: GHC.Prim.MutableArray# s e -> (GHC.Types.Int, e) -> GHC.ST.STRep s a -> GHC.ST.STRep s a
  foldl1Elems :: (a -> a -> a) -> Array i a -> a
  foldlElems :: (b -> a -> b) -> b -> Array i a -> b
  foldlElems' :: (b -> a -> b) -> b -> Array i a -> b
  foldr1Elems :: (a -> a -> a) -> Array i a -> a
  foldrElems :: (a -> b -> b) -> b -> Array i a -> b
  foldrElems' :: (a -> b -> b) -> b -> Array i a -> b
  freezeSTArray :: STArray s i e -> GHC.ST.ST s (Array i e)
  inRange :: Ix a => (a, a) -> a -> GHC.Types.Bool
  index :: Ix a => (a, a) -> a -> GHC.Types.Int
  indices :: Ix i => Array i e -> [i]
  ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
  lessSafeIndex :: Ix i => (i, i) -> GHC.Types.Int -> i -> GHC.Types.Int
  listArray :: Ix i => (i, i) -> [e] -> Array i e
  negRange :: GHC.Types.Int
  newSTArray :: Ix i => (i, i) -> e -> GHC.ST.ST s (STArray s i e)
  numElements :: Array i e -> GHC.Types.Int
  numElementsSTArray :: STArray s i e -> GHC.Types.Int
  range :: Ix a => (a, a) -> [a]
  rangeSize :: Ix a => (a, a) -> GHC.Types.Int
  readSTArray :: Ix i => STArray s i e -> i -> GHC.ST.ST s e
  safeIndex :: Ix i => (i, i) -> GHC.Types.Int -> i -> GHC.Types.Int
  safeRangeSize :: Ix i => (i, i) -> GHC.Types.Int
  thawSTArray :: Array i e -> GHC.ST.ST s (STArray s i e)
  unsafeAccum :: (e -> a -> e) -> Array i e -> [(GHC.Types.Int, a)] -> Array i e
  unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(GHC.Types.Int, a)] -> Array i e
  unsafeAccumArray' :: (e -> a -> e) -> e -> (i, i) -> GHC.Types.Int -> [(GHC.Types.Int, a)] -> Array i e
  unsafeArray :: Ix i => (i, i) -> [(GHC.Types.Int, e)] -> Array i e
  unsafeArray' :: (i, i) -> GHC.Types.Int -> [(GHC.Types.Int, e)] -> Array i e
  unsafeAt :: Array i e -> GHC.Types.Int -> e
  unsafeFreezeSTArray :: STArray s i e -> GHC.ST.ST s (Array i e)
  unsafeIndex :: Ix a => (a, a) -> a -> GHC.Types.Int
  unsafeRangeSize :: Ix a => (a, a) -> GHC.Types.Int
  unsafeReadSTArray :: STArray s i e -> GHC.Types.Int -> GHC.ST.ST s e
  unsafeReplace :: Array i e -> [(GHC.Types.Int, e)] -> Array i e
  unsafeThawSTArray :: Array i e -> GHC.ST.ST s (STArray s i e)
  unsafeWriteSTArray :: STArray s i e -> GHC.Types.Int -> e -> GHC.ST.ST s ()
  writeSTArray :: Ix i => STArray s i e -> i -> e -> GHC.ST.ST s ()

module GHC.ArrayArray where
  ArrayArray# :: GHC.Prim.Array# GHC.Prim.ByteArray# -> ArrayArray#
  type ArrayArray# :: GHC.Types.UnliftedType
  newtype ArrayArray# = ...
  MutableArrayArray# :: GHC.Prim.MutableArray# s GHC.Prim.ByteArray# -> MutableArrayArray# s
  type role MutableArrayArray# nominal
  type MutableArrayArray# :: * -> GHC.Types.UnliftedType
  newtype MutableArrayArray# s = ...
  copyArrayArray# :: ArrayArray# -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.State# s -> GHC.Prim.State# s
  copyMutableArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.State# s -> GHC.Prim.State# s
  indexArrayArrayArray# :: ArrayArray# -> GHC.Prim.Int# -> ArrayArray#
  indexByteArrayArray# :: ArrayArray# -> GHC.Prim.Int# -> GHC.Prim.ByteArray#
  newArrayArray# :: GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, MutableArrayArray# s #)
  readArrayArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, ArrayArray# #)
  readByteArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.ByteArray# #)
  readMutableArrayArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, MutableArrayArray# s #)
  readMutableByteArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.MutableByteArray# s #)
  sameArrayArray# :: ArrayArray# -> ArrayArray# -> GHC.Prim.Int#
  sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> GHC.Prim.Int#
  sizeofArrayArray# :: ArrayArray# -> GHC.Prim.Int#
  sizeofMutableArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int#
  unsafeFreezeArrayArray# :: MutableArrayArray# s -> GHC.Prim.State# s -> (# GHC.Prim.State# s, ArrayArray# #)
  writeArrayArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> ArrayArray# -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeByteArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.ByteArray# -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeMutableArrayArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeMutableByteArrayArray# :: MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.State# s -> GHC.Prim.State# s

module GHC.Base where
  ($) :: (a -> b) -> a -> b
  ($!) :: (a -> b) -> a -> b
  (&&) :: Bool -> Bool -> Bool
  (*#) :: Int# -> Int# -> Int#
  (*##) :: Double# -> Double# -> Double#
  (**##) :: Double# -> Double# -> Double#
  (*>) :: Applicative f => f a -> f b -> f b
  (+#) :: Int# -> Int# -> Int#
  (+##) :: Double# -> Double# -> Double#
  (++) :: [a] -> [a] -> [a]
  (-#) :: Int# -> Int# -> Int#
  (-##) :: Double# -> Double# -> Double#
  (.) :: (b -> c) -> (a -> b) -> a -> c
  (/##) :: Double# -> Double# -> Double#
  (/=) :: Eq a => a -> a -> Bool
  (/=#) :: Int# -> Int# -> Int#
  (/=##) :: Double# -> Double# -> Int#
  (:|) :: a -> [a] -> NonEmpty a
  (<) :: Ord a => a -> a -> Bool
  (<#) :: Int# -> Int# -> Int#
  (<##) :: Double# -> Double# -> Int#
  (<$) :: Functor f => a -> f b -> f a
  (<*) :: Applicative f => f a -> f b -> f a
  (<**>) :: Applicative f => f a -> f (a -> b) -> f b
  (<*>) :: Applicative f => f (a -> b) -> f a -> f b
  (<=) :: Ord a => a -> a -> Bool
  (<=#) :: Int# -> Int# -> Int#
  (<=##) :: Double# -> Double# -> Int#
  (<>) :: Semigroup a => a -> a -> a
  (<|>) :: Alternative f => f a -> f a -> f a
  (=<<) :: Monad m => (a -> m b) -> m a -> m b
  (==) :: Eq a => a -> a -> Bool
  (==#) :: Int# -> Int# -> Int#
  (==##) :: Double# -> Double# -> Int#
  (>) :: Ord a => a -> a -> Bool
  (>#) :: Int# -> Int# -> Int#
  (>##) :: Double# -> Double# -> Int#
  (>=) :: Ord a => a -> a -> Bool
  (>=#) :: Int# -> Int# -> Int#
  (>=##) :: Double# -> Double# -> Int#
  (>>) :: Monad m => m a -> m b -> m b
  (>>=) :: Monad m => m a -> (a -> m b) -> m b
  type Addr# :: TYPE AddrRep
  data Addr#
  AddrRep :: RuntimeRep
  type Alternative :: (* -> *) -> Constraint
  class Applicative f => Alternative f
    ...
  type Any :: forall k. k
  type family Any
  type Applicative :: (* -> *) -> Constraint
  class Functor f => Applicative f
    ...
  type Array# :: * -> UnliftedType
  data Array# a
  type BCO :: *
  data BCO
  type Bool :: *
  data Bool = ...
  BoxedRep :: Levity -> RuntimeRep
  type ByteArray# :: UnliftedType
  data ByteArray#
  C# :: Char# -> Char
  type role CONSTRAINT nominal
  type CONSTRAINT :: RuntimeRep -> *
  data CONSTRAINT a
  type Char :: *
  data Char = ...
  type Char# :: TYPE WordRep
  data Char#
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
  type Compact# :: UnliftedType
  data Compact#
  type Constraint :: *
  type Constraint = CONSTRAINT LiftedRep
  D# :: Double# -> Double
  type DictBox :: Constraint -> *
  data DictBox a = ...
  type Double :: *
  data Double = ...
  type Double# :: TYPE DoubleRep
  data Double#
  type DoubleBox :: TYPE DoubleRep -> *
  data DoubleBox a = ...
  DoubleElemRep :: VecElem
  DoubleRep :: RuntimeRep
  type DoubleX2# :: TYPE (VecRep Vec2 DoubleElemRep)
  data DoubleX2#
  type DoubleX4# :: TYPE (VecRep Vec4 DoubleElemRep)
  data DoubleX4#
  type DoubleX8# :: TYPE (VecRep Vec8 DoubleElemRep)
  data DoubleX8#
  EQ :: Ordering
  type Eq :: * -> Constraint
  class Eq a
    ...
  F# :: Float# -> Float
  type role FUN nominal representational representational
  type FUN :: forall (n :: Multiplicity) -> * -> * -> *
  data FUN n a b
  False :: Bool
  type Float :: *
  data Float = ...
  type Float# :: TYPE FloatRep
  data Float#
  type FloatBox :: TYPE FloatRep -> *
  data FloatBox a = ...
  FloatElemRep :: VecElem
  FloatRep :: RuntimeRep
  type FloatX16# :: TYPE (VecRep Vec16 FloatElemRep)
  data FloatX16#
  type FloatX4# :: TYPE (VecRep Vec4 FloatElemRep)
  data FloatX4#
  type FloatX8# :: TYPE (VecRep Vec8 FloatElemRep)
  data FloatX8#
  type Functor :: (* -> *) -> Constraint
  class Functor f
    ...
  GT :: Ordering
  I# :: Int# -> Int
  IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a
  type IO :: * -> *
  newtype IO a = ...
  type role IOPort# nominal representational
  type IOPort# :: * -> * -> UnliftedType
  data IOPort# a b
  type IP :: Symbol -> * -> Constraint
  class IP x a | x -> a
    ...
  type Int :: *
  data Int = ...
  type Int# :: TYPE IntRep
  data Int#
  type Int16# :: TYPE Int16Rep
  data Int16#
  Int16ElemRep :: VecElem
  Int16Rep :: RuntimeRep
  type Int16X16# :: TYPE (VecRep Vec16 Int16ElemRep)
  data Int16X16#
  type Int16X32# :: TYPE (VecRep Vec32 Int16ElemRep)
  data Int16X32#
  type Int16X8# :: TYPE (VecRep Vec8 Int16ElemRep)
  data Int16X8#
  type Int32# :: TYPE Int32Rep
  data Int32#
  Int32ElemRep :: VecElem
  Int32Rep :: RuntimeRep
  type Int32X16# :: TYPE (VecRep Vec16 Int32ElemRep)
  data Int32X16#
  type Int32X4# :: TYPE (VecRep Vec4 Int32ElemRep)
  data Int32X4#
  type Int32X8# :: TYPE (VecRep Vec8 Int32ElemRep)
  data Int32X8#
  type Int64# :: TYPE Int64Rep
  data Int64#
  Int64ElemRep :: VecElem
  Int64Rep :: RuntimeRep
  type Int64X2# :: TYPE (VecRep Vec2 Int64ElemRep)
  data Int64X2#
  type Int64X4# :: TYPE (VecRep Vec4 Int64ElemRep)
  data Int64X4#
  type Int64X8# :: TYPE (VecRep Vec8 Int64ElemRep)
  data Int64X8#
  type Int8# :: TYPE Int8Rep
  data Int8#
  Int8ElemRep :: VecElem
  Int8Rep :: RuntimeRep
  type Int8X16# :: TYPE (VecRep Vec16 Int8ElemRep)
  data Int8X16#
  type Int8X32# :: TYPE (VecRep Vec32 Int8ElemRep)
  data Int8X32#
  type Int8X64# :: TYPE (VecRep Vec64 Int8ElemRep)
  data Int8X64#
  type IntBox :: TYPE IntRep -> *
  data IntBox a = ...
  IntRep :: RuntimeRep
  Just :: a -> Maybe a
  type KindBndr :: *
  type KindBndr = Int
  type KindRep :: *
  data KindRep = ...
  KindRepApp :: KindRep -> KindRep -> KindRep
  KindRepFun :: KindRep -> KindRep -> KindRep
  KindRepTYPE :: RuntimeRep -> KindRep
  KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
  KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
  KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
  KindRepVar :: KindBndr -> KindRep
  LT :: Ordering
  type Levity :: *
  data Levity = ...
  Lifted :: Levity
  type LiftedRep :: RuntimeRep
  type LiftedRep = BoxedRep Lifted :: RuntimeRep
  type List :: * -> *
  data List a = ...
  type role MVar# nominal representational
  type MVar# :: * -> * -> UnliftedType
  data MVar# a b
  Many :: Multiplicity
  type Maybe :: * -> *
  data Maybe a = ...
  MkDictBox :: a => DictBox a
  MkDoubleBox :: a -> DoubleBox a
  MkFloatBox :: a -> FloatBox a
  MkIntBox :: a -> IntBox a
  MkWordBox :: a -> WordBox a
  Module :: TrName -> TrName -> Module
  type Module :: *
  data Module = ...
  type Monad :: (* -> *) -> Constraint
  class Applicative m => Monad m
    ...
  type MonadPlus :: (* -> *) -> Constraint
  class (Alternative m, Monad m) => MonadPlus m
    ...
  type Monoid :: * -> Constraint
  class Semigroup a => Monoid a
    ...
  type MultMul :: Multiplicity -> Multiplicity -> Multiplicity
  type family MultMul a b
  type Multiplicity :: *
  data Multiplicity = ...
  type role MutVar# nominal representational
  type MutVar# :: * -> * -> UnliftedType
  data MutVar# a b
  type role MutableArray# nominal representational
  type MutableArray# :: * -> * -> UnliftedType
  data MutableArray# a b
  type role MutableByteArray# nominal
  type MutableByteArray# :: * -> UnliftedType
  data MutableByteArray# a
  type NonEmpty :: * -> *
  data NonEmpty a = ...
  Nothing :: Maybe a
  O :: a -> Opaque
  One :: Multiplicity
  type Opaque :: *
  data Opaque = ...
  type Ord :: * -> Constraint
  class Eq a => Ord a
    ...
  type Ordering :: *
  data Ordering = ...
  type PromptTag# :: * -> UnliftedType
  data PromptTag# a
  type role Proxy# phantom
  type Proxy# :: forall k. k -> ZeroBitType
  data Proxy# a
  type RealWorld :: *
  data RealWorld
  type RuntimeRep :: *
  data RuntimeRep = ...
  SPEC :: SPEC
  type SPEC :: *
  data SPEC = ...
  SPEC2 :: SPEC
  type Semigroup :: * -> Constraint
  class Semigroup a
    ...
  type SmallArray# :: * -> UnliftedType
  data SmallArray# a
  type role SmallMutableArray# nominal representational
  type SmallMutableArray# :: * -> * -> UnliftedType
  data SmallMutableArray# a b
  type role StableName# phantom
  type StableName# :: * -> UnliftedType
  data StableName# a
  type StablePtr# :: * -> TYPE AddrRep
  data StablePtr# a
  type StackSnapshot# :: UnliftedType
  data StackSnapshot#
  type role State# nominal
  type State# :: * -> ZeroBitType
  data State# a
  type String :: *
  type String = [Char]
  SumRep :: [RuntimeRep] -> RuntimeRep
  type Symbol :: *
  data Symbol
  type role TVar# nominal representational
  type TVar# :: * -> * -> UnliftedType
  data TVar# a b
  type role TYPE nominal
  type TYPE :: RuntimeRep -> *
  data TYPE a
  type ThreadId# :: UnliftedType
  data ThreadId#
  type TrName :: *
  data TrName = ...
  TrNameD :: [Char] -> TrName
  TrNameS :: Addr# -> TrName
  True :: Bool
  TupleRep :: [RuntimeRep] -> RuntimeRep
  TyCon :: Word64# -> Word64# -> Module -> TrName -> Int# -> KindRep -> TyCon
  type TyCon :: *
  data TyCon = ...
  type Type :: *
  type Type = TYPE LiftedRep
  TypeLitChar :: TypeLitSort
  TypeLitNat :: TypeLitSort
  type TypeLitSort :: *
  data TypeLitSort = ...
  TypeLitSymbol :: TypeLitSort
  Unlifted :: Levity
  type UnliftedRep :: RuntimeRep
  type UnliftedRep = BoxedRep Unlifted :: RuntimeRep
  type UnliftedType :: *
  type UnliftedType = TYPE UnliftedRep
  Vec16 :: VecCount
  Vec2 :: VecCount
  Vec32 :: VecCount
  Vec4 :: VecCount
  Vec64 :: VecCount
  Vec8 :: VecCount
  type VecCount :: *
  data VecCount = ...
  type VecElem :: *
  data VecElem = ...
  VecRep :: VecCount -> VecElem -> RuntimeRep
  type Void :: *
  data Void
  type Void# :: ZeroBitType
  type Void# = (# #) :: ZeroBitType
  W# :: Word# -> Word
  type Weak# :: * -> UnliftedType
  data Weak# a
  type WithDict :: Constraint -> * -> Constraint
  class WithDict cls meth
    ...
  type Word :: *
  data Word = ...
  type Word# :: TYPE WordRep
  data Word#
  type Word16# :: TYPE Word16Rep
  data Word16#
  Word16ElemRep :: VecElem
  Word16Rep :: RuntimeRep
  type Word16X16# :: TYPE (VecRep Vec16 Word16ElemRep)
  data Word16X16#
  type Word16X32# :: TYPE (VecRep Vec32 Word16ElemRep)
  data Word16X32#
  type Word16X8# :: TYPE (VecRep Vec8 Word16ElemRep)
  data Word16X8#
  type Word32# :: TYPE Word32Rep
  data Word32#
  Word32ElemRep :: VecElem
  Word32Rep :: RuntimeRep
  type Word32X16# :: TYPE (VecRep Vec16 Word32ElemRep)
  data Word32X16#
  type Word32X4# :: TYPE (VecRep Vec4 Word32ElemRep)
  data Word32X4#
  type Word32X8# :: TYPE (VecRep Vec8 Word32ElemRep)
  data Word32X8#
  type Word64# :: TYPE Word64Rep
  data Word64#
  Word64ElemRep :: VecElem
  Word64Rep :: RuntimeRep
  type Word64X2# :: TYPE (VecRep Vec2 Word64ElemRep)
  data Word64X2#
  type Word64X4# :: TYPE (VecRep Vec4 Word64ElemRep)
  data Word64X4#
  type Word64X8# :: TYPE (VecRep Vec8 Word64ElemRep)
  data Word64X8#
  type Word8# :: TYPE Word8Rep
  data Word8#
  Word8ElemRep :: VecElem
  Word8Rep :: RuntimeRep
  type Word8X16# :: TYPE (VecRep Vec16 Word8ElemRep)
  data Word8X16#
  type Word8X32# :: TYPE (VecRep Vec32 Word8ElemRep)
  data Word8X32#
  type Word8X64# :: TYPE (VecRep Vec64 Word8ElemRep)
  data Word8X64#
  type WordBox :: TYPE WordRep -> *
  data WordBox a = ...
  WordRep :: RuntimeRep
  type ZeroBitRep :: RuntimeRep
  type ZeroBitRep = TupleRep '[] :: RuntimeRep
  type ZeroBitType :: *
  type ZeroBitType = TYPE ZeroBitRep
  absentErr :: a
  absurd :: Void -> a
  acosDouble# :: Double# -> Double#
  acosFloat# :: Float# -> Float#
  acoshDouble# :: Double# -> Double#
  acoshFloat# :: Float# -> Float#
  addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
  addIntC# :: Int# -> Int# -> (# Int#, Int# #)
  addWordC# :: Word# -> Word# -> (# Word#, Int# #)
  addr2Int# :: Addr# -> Int#
  addrToAny# :: Addr# -> (# a #)
  and# :: Word# -> Word# -> Word#
  and64# :: Word64# -> Word64# -> Word64#
  andI# :: Int# -> Int# -> Int#
  andWord16# :: Word16# -> Word16# -> Word16#
  andWord32# :: Word32# -> Word32# -> Word32#
  andWord8# :: Word8# -> Word8# -> Word8#
  anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
  ap :: Monad m => m (a -> b) -> m a -> m b
  asTypeOf :: a -> a -> a
  asinDouble# :: Double# -> Double#
  asinFloat# :: Float# -> Float#
  asinhDouble# :: Double# -> Double#
  asinhFloat# :: Float# -> Float#
  assert :: Bool -> a -> a
  atanDouble# :: Double# -> Double#
  atanFloat# :: Float# -> Float#
  atanhDouble# :: Double# -> Double#
  atanhFloat# :: Float# -> Float#
  atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)
  atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)
  atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)
  atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)
  atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)
  atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)
  atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)
  atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)
  atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d
  atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  augment :: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  bindIO :: IO a -> (a -> IO b) -> IO b
  bitReverse# :: Word# -> Word#
  bitReverse16# :: Word# -> Word#
  bitReverse32# :: Word# -> Word#
  bitReverse64# :: Word64# -> Word64#
  bitReverse8# :: Word# -> Word#
  breakpoint :: a -> a
  breakpointCond :: Bool -> a -> a
  broadcastDoubleX2# :: Double# -> DoubleX2#
  broadcastDoubleX4# :: Double# -> DoubleX4#
  broadcastDoubleX8# :: Double# -> DoubleX8#
  broadcastFloatX16# :: Float# -> FloatX16#
  broadcastFloatX4# :: Float# -> FloatX4#
  broadcastFloatX8# :: Float# -> FloatX8#
  broadcastInt16X16# :: Int16# -> Int16X16#
  broadcastInt16X32# :: Int16# -> Int16X32#
  broadcastInt16X8# :: Int16# -> Int16X8#
  broadcastInt32X16# :: Int32# -> Int32X16#
  broadcastInt32X4# :: Int32# -> Int32X4#
  broadcastInt32X8# :: Int32# -> Int32X8#
  broadcastInt64X2# :: Int64# -> Int64X2#
  broadcastInt64X4# :: Int64# -> Int64X4#
  broadcastInt64X8# :: Int64# -> Int64X8#
  broadcastInt8X16# :: Int8# -> Int8X16#
  broadcastInt8X32# :: Int8# -> Int8X32#
  broadcastInt8X64# :: Int8# -> Int8X64#
  broadcastWord16X16# :: Word16# -> Word16X16#
  broadcastWord16X32# :: Word16# -> Word16X32#
  broadcastWord16X8# :: Word16# -> Word16X8#
  broadcastWord32X16# :: Word32# -> Word32X16#
  broadcastWord32X4# :: Word32# -> Word32X4#
  broadcastWord32X8# :: Word32# -> Word32X8#
  broadcastWord64X2# :: Word64# -> Word64X2#
  broadcastWord64X4# :: Word64# -> Word64X4#
  broadcastWord64X8# :: Word64# -> Word64X8#
  broadcastWord8X16# :: Word8# -> Word8X16#
  broadcastWord8X32# :: Word8# -> Word8X32#
  broadcastWord8X64# :: Word8# -> Word8X64#
  build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
  byteArrayContents# :: ByteArray# -> Addr#
  byteSwap# :: Word# -> Word#
  byteSwap16# :: Word# -> Word#
  byteSwap32# :: Word# -> Word#
  byteSwap64# :: Word64# -> Word64#
  casArray# :: MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)
  casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)
  casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)
  casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)
  casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  casMutVar# :: MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
  casSmallArray# :: SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  chr# :: Int# -> Char#
  clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)
  cloneArray# :: Array# a -> Int# -> Int# -> Array# a
  cloneMutableArray# :: MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
  cloneSmallMutableArray# :: SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  closureSize# :: a -> Int#
  clz# :: Word# -> Word#
  clz16# :: Word# -> Word#
  clz32# :: Word# -> Word#
  clz64# :: Word64# -> Word#
  clz8# :: Word# -> Word#
  coerce :: Coercible a b => a -> b
  compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
  compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
  compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
  compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
  compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
  compare :: Ord a => a -> a -> Ordering
  compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
  compareInt :: Int -> Int -> Ordering
  compareInt# :: Int# -> Int# -> Ordering
  compareWord :: Word -> Word -> Ordering
  compareWord# :: Word# -> Word# -> Ordering
  const :: a -> b -> a
  control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)
  copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyArray# :: Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
  copyMutableArray# :: MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d
  copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copySmallMutableArray# :: SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  cosDouble# :: Double# -> Double#
  cosFloat# :: Float# -> Float#
  coshDouble# :: Double# -> Double#
  coshFloat# :: Float# -> Float#
  cstringLength# :: Addr# -> Int#
  ctz# :: Word# -> Word#
  ctz16# :: Word# -> Word#
  ctz32# :: Word# -> Word#
  ctz64# :: Word64# -> Word#
  ctz8# :: Word# -> Word#
  dataToTag# :: a -> Int#
  deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
  deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
  decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
  decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
  decodeFloat_Int# :: Float# -> (# Int#, Int# #)
  delay# :: Int# -> State# d -> State# d
  divInt :: Int -> Int -> Int
  divInt# :: Int# -> Int# -> Int#
  divInt16# :: Int16# -> Int16# -> Int16#
  divInt32# :: Int32# -> Int32# -> Int32#
  divInt8# :: Int8# -> Int8# -> Int8#
  divModInt :: Int -> Int -> (Int, Int)
  divModInt# :: Int# -> Int# -> (# Int#, Int# #)
  divModInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  divModInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  divModInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  divideFloat# :: Float# -> Float# -> Float#
  divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  double2Float# :: Double# -> Float#
  double2Int# :: Double# -> Int#
  empty :: Alternative f => f a
  eqAddr# :: Addr# -> Addr# -> Int#
  eqChar :: Char -> Char -> Bool
  eqChar# :: Char# -> Char# -> Int#
  eqDouble :: Double -> Double -> Bool
  eqFloat :: Float -> Float -> Bool
  eqFloat# :: Float# -> Float# -> Int#
  eqInt :: Int -> Int -> Bool
  eqInt16# :: Int16# -> Int16# -> Int#
  eqInt32# :: Int32# -> Int32# -> Int#
  eqInt64# :: Int64# -> Int64# -> Int#
  eqInt8# :: Int8# -> Int8# -> Int#
  eqStableName# :: StableName# a -> StableName# b -> Int#
  eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
  eqString :: String -> String -> Bool
  eqWord :: Word -> Word -> Bool
  eqWord# :: Word# -> Word# -> Int#
  eqWord16# :: Word16# -> Word16# -> Int#
  eqWord32# :: Word32# -> Word32# -> Int#
  eqWord64# :: Word64# -> Word64# -> Int#
  eqWord8# :: Word8# -> Word8# -> Int#
  error :: GHC.Stack.Types.HasCallStack => [Char] -> a
  errorWithoutStackTrace :: [Char] -> a
  expDouble# :: Double# -> Double#
  expFloat# :: Float# -> Float#
  expm1Double# :: Double# -> Double#
  expm1Float# :: Float# -> Float#
  fabsDouble# :: Double# -> Double#
  fabsFloat# :: Float# -> Float#
  failIO :: String -> IO a
  fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
  flip :: (a -> b -> c) -> b -> a -> c
  float2Double# :: Float# -> Double#
  float2Int# :: Float# -> Int#
  fmap :: Functor f => (a -> b) -> f a -> f b
  foldr :: (a -> b -> b) -> b -> [a] -> b
  fork# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  freezeArray# :: MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)
  freezeSmallArray# :: SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
  geAddr# :: Addr# -> Addr# -> Int#
  geChar# :: Char# -> Char# -> Int#
  geFloat# :: Float# -> Float# -> Int#
  geInt :: Int -> Int -> Bool
  geInt16# :: Int16# -> Int16# -> Int#
  geInt32# :: Int32# -> Int32# -> Int#
  geInt64# :: Int64# -> Int64# -> Int#
  geInt8# :: Int8# -> Int8# -> Int#
  geWord :: Word -> Word -> Bool
  geWord# :: Word# -> Word# -> Int#
  geWord16# :: Word16# -> Word16# -> Int#
  geWord32# :: Word32# -> Word32# -> Int#
  geWord64# :: Word64# -> Word64# -> Int#
  geWord8# :: Word8# -> Word8# -> Int#
  getApStackVal# :: a -> Int# -> (# Int#, b #)
  getCCSOf# :: a -> State# d -> (# State# d, Addr# #)
  getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)
  getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
  getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)
  getSizeofSmallMutableArray# :: SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
  getSpark# :: State# d -> (# State# d, Int#, a #)
  getTag :: a -> Int#
  getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)
  gtAddr# :: Addr# -> Addr# -> Int#
  gtChar# :: Char# -> Char# -> Int#
  gtFloat# :: Float# -> Float# -> Int#
  gtInt :: Int -> Int -> Bool
  gtInt16# :: Int16# -> Int16# -> Int#
  gtInt32# :: Int32# -> Int32# -> Int#
  gtInt64# :: Int64# -> Int64# -> Int#
  gtInt8# :: Int8# -> Int8# -> Int#
  gtWord :: Word -> Word -> Bool
  gtWord# :: Word# -> Word# -> Int#
  gtWord16# :: Word16# -> Word16# -> Int#
  gtWord32# :: Word32# -> Word32# -> Int#
  gtWord64# :: Word64# -> Word64# -> Int#
  gtWord8# :: Word8# -> Word8# -> Int#
  iShiftL# :: Int# -> Int# -> Int#
  iShiftRA# :: Int# -> Int# -> Int#
  iShiftRL# :: Int# -> Int# -> Int#
  id :: a -> a
  indexAddrArray# :: ByteArray# -> Int# -> Addr#
  indexAddrOffAddr# :: Addr# -> Int# -> Addr#
  indexArray# :: Array# a -> Int# -> (# a #)
  indexCharArray# :: ByteArray# -> Int# -> Char#
  indexCharOffAddr# :: Addr# -> Int# -> Char#
  indexDoubleArray# :: ByteArray# -> Int# -> Double#
  indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleOffAddr# :: Addr# -> Int# -> Double#
  indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
  indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
  indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
  indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
  indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
  indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
  indexFloatArray# :: ByteArray# -> Int# -> Float#
  indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
  indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
  indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
  indexFloatOffAddr# :: Addr# -> Int# -> Float#
  indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
  indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
  indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
  indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
  indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
  indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
  indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
  indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
  indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
  indexInt16Array# :: ByteArray# -> Int# -> Int16#
  indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
  indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
  indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
  indexInt16OffAddr# :: Addr# -> Int# -> Int16#
  indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
  indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
  indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
  indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
  indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
  indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
  indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
  indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
  indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
  indexInt32Array# :: ByteArray# -> Int# -> Int32#
  indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
  indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
  indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
  indexInt32OffAddr# :: Addr# -> Int# -> Int32#
  indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
  indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
  indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
  indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
  indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
  indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
  indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
  indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
  indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
  indexInt64Array# :: ByteArray# -> Int# -> Int64#
  indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
  indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
  indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
  indexInt64OffAddr# :: Addr# -> Int# -> Int64#
  indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
  indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
  indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
  indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
  indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
  indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
  indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
  indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
  indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
  indexInt8Array# :: ByteArray# -> Int# -> Int8#
  indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
  indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
  indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
  indexInt8OffAddr# :: Addr# -> Int# -> Int8#
  indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
  indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
  indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
  indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
  indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
  indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
  indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
  indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
  indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
  indexIntArray# :: ByteArray# -> Int# -> Int#
  indexIntOffAddr# :: Addr# -> Int# -> Int#
  indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
  indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
  indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
  indexWideCharArray# :: ByteArray# -> Int# -> Char#
  indexWideCharOffAddr# :: Addr# -> Int# -> Char#
  indexWord16Array# :: ByteArray# -> Int# -> Word16#
  indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
  indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
  indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
  indexWord16OffAddr# :: Addr# -> Int# -> Word16#
  indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
  indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
  indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
  indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
  indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
  indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
  indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
  indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
  indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
  indexWord32Array# :: ByteArray# -> Int# -> Word32#
  indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
  indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
  indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
  indexWord32OffAddr# :: Addr# -> Int# -> Word32#
  indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
  indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
  indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
  indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
  indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
  indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
  indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
  indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
  indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
  indexWord64Array# :: ByteArray# -> Int# -> Word64#
  indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
  indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
  indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
  indexWord64OffAddr# :: Addr# -> Int# -> Word64#
  indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
  indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
  indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
  indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
  indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
  indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
  indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
  indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
  indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
  indexWord8Array# :: ByteArray# -> Int# -> Word8#
  indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
  indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
  indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
  indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
  indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
  indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
  indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
  indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
  indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
  indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
  indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
  indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
  indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
  indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
  indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
  indexWord8OffAddr# :: Addr# -> Int# -> Word8#
  indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
  indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
  indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
  indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
  indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
  indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
  indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
  indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
  indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
  indexWordArray# :: ByteArray# -> Int# -> Word#
  indexWordOffAddr# :: Addr# -> Int# -> Word#
  inline :: a -> a
  insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
  insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
  insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
  insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
  insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
  insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
  insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#
  insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#
  insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#
  insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#
  insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#
  insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#
  insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#
  insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#
  insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#
  insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#
  insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#
  insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#
  insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#
  insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#
  insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#
  insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#
  insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#
  insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#
  insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#
  insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#
  insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#
  insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#
  insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#
  insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
  int16ToInt# :: Int16# -> Int#
  int16ToWord16# :: Int16# -> Word16#
  int2Addr# :: Int# -> Addr#
  int2Double# :: Int# -> Double#
  int2Float# :: Int# -> Float#
  int2Word# :: Int# -> Word#
  int32ToInt# :: Int32# -> Int#
  int32ToWord32# :: Int32# -> Word32#
  int64ToInt# :: Int64# -> Int#
  int64ToWord64# :: Int64# -> Word64#
  int8ToInt# :: Int8# -> Int#
  int8ToWord8# :: Int8# -> Word8#
  intToInt16# :: Int# -> Int16#
  intToInt32# :: Int# -> Int32#
  intToInt64# :: Int# -> Int64#
  intToInt8# :: Int# -> Int8#
  ip :: IP x a => a
  isByteArrayPinned# :: ByteArray# -> Int#
  isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
  isEmptyMVar# :: MVar# d a -> State# d -> (# State# d, Int# #)
  isMutableByteArrayPinned# :: MutableByteArray# d -> Int#
  isTrue# :: Int# -> Bool
  join :: Monad m => m (m a) -> m a
  keepAlive# :: a -> State# RealWorld -> (State# RealWorld -> b) -> b
  killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
  labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
  lazy :: a -> a
  leAddr# :: Addr# -> Addr# -> Int#
  leChar# :: Char# -> Char# -> Int#
  leFloat# :: Float# -> Float# -> Int#
  leInt :: Int -> Int -> Bool
  leInt16# :: Int16# -> Int16# -> Int#
  leInt32# :: Int32# -> Int32# -> Int#
  leInt64# :: Int64# -> Int64# -> Int#
  leInt8# :: Int8# -> Int8# -> Int#
  leWord :: Word -> Word -> Bool
  leWord# :: Word# -> Word# -> Int#
  leWord16# :: Word16# -> Word16# -> Int#
  leWord32# :: Word32# -> Word32# -> Int#
  leWord64# :: Word64# -> Word64# -> Int#
  leWord8# :: Word8# -> Word8# -> Int#
  leftSection :: (a -> b) -> a -> b
  liftA :: Applicative f => (a -> b) -> f a -> f b
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  liftM :: Monad m => (a1 -> r) -> m a1 -> m r
  liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
  liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
  liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
  liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
  listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
  log1pDouble# :: Double# -> Double#
  log1pFloat# :: Float# -> Float#
  logDouble# :: Double# -> Double#
  logFloat# :: Float# -> Float#
  ltAddr# :: Addr# -> Addr# -> Int#
  ltChar# :: Char# -> Char# -> Int#
  ltFloat# :: Float# -> Float# -> Int#
  ltInt :: Int -> Int -> Bool
  ltInt16# :: Int16# -> Int16# -> Int#
  ltInt32# :: Int32# -> Int32# -> Int#
  ltInt64# :: Int64# -> Int64# -> Int#
  ltInt8# :: Int8# -> Int8# -> Int#
  ltWord :: Word -> Word -> Bool
  ltWord# :: Word# -> Word# -> Int#
  ltWord16# :: Word16# -> Word16# -> Int#
  ltWord32# :: Word32# -> Word32# -> Int#
  ltWord64# :: Word64# -> Word64# -> Int#
  ltWord8# :: Word8# -> Word8# -> Int#
  makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
  makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
  many :: Alternative f => f a -> f [a]
  map :: (a -> b) -> [a] -> [b]
  mapFB :: (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
  mapM :: Monad m => (a -> m b) -> [a] -> m [b]
  mappend :: Monoid a => a -> a -> a
  maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  max :: Ord a => a -> a -> a
  maxInt :: Int
  mconcat :: Monoid a => [a] -> a
  mempty :: Monoid a => a
  min :: Ord a => a -> a -> a
  minInt :: Int
  minusAddr# :: Addr# -> Addr# -> Int#
  minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  minusFloat# :: Float# -> Float# -> Float#
  minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  minusWord# :: Word# -> Word# -> Word#
  minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  mkApUpd0# :: BCO -> (# a #)
  mkWeak# :: a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mkWeakNoFinalizer# :: a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  modInt :: Int -> Int -> Int
  modInt# :: Int# -> Int# -> Int#
  modInt16# :: Int16# -> Int16# -> Int16#
  modInt32# :: Int32# -> Int32# -> Int32#
  modInt8# :: Int8# -> Int8# -> Int8#
  mplus :: MonadPlus m => m a -> m a -> m a
  mulIntMayOflo# :: Int# -> Int# -> Int#
  mutableByteArrayContents# :: MutableByteArray# d -> Addr#
  myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
  mzero :: MonadPlus m => m a
  narrow16Int# :: Int# -> Int#
  narrow16Word# :: Word# -> Word#
  narrow32Int# :: Int# -> Int#
  narrow32Word# :: Word# -> Word#
  narrow8Int# :: Int# -> Int#
  narrow8Word# :: Word# -> Word#
  neAddr# :: Addr# -> Addr# -> Int#
  neChar :: Char -> Char -> Bool
  neChar# :: Char# -> Char# -> Int#
  neFloat# :: Float# -> Float# -> Int#
  neInt :: Int -> Int -> Bool
  neInt16# :: Int16# -> Int16# -> Int#
  neInt32# :: Int32# -> Int32# -> Int#
  neInt64# :: Int64# -> Int64# -> Int#
  neInt8# :: Int8# -> Int8# -> Int#
  neWord :: Word -> Word -> Bool
  neWord# :: Word# -> Word# -> Int#
  neWord16# :: Word16# -> Word16# -> Int#
  neWord32# :: Word32# -> Word32# -> Int#
  neWord64# :: Word64# -> Word64# -> Int#
  neWord8# :: Word8# -> Word8# -> Int#
  negateDouble# :: Double# -> Double#
  negateDoubleX2# :: DoubleX2# -> DoubleX2#
  negateDoubleX4# :: DoubleX4# -> DoubleX4#
  negateDoubleX8# :: DoubleX8# -> DoubleX8#
  negateFloat# :: Float# -> Float#
  negateFloatX16# :: FloatX16# -> FloatX16#
  negateFloatX4# :: FloatX4# -> FloatX4#
  negateFloatX8# :: FloatX8# -> FloatX8#
  negateInt# :: Int# -> Int#
  negateInt16# :: Int16# -> Int16#
  negateInt16X16# :: Int16X16# -> Int16X16#
  negateInt16X32# :: Int16X32# -> Int16X32#
  negateInt16X8# :: Int16X8# -> Int16X8#
  negateInt32# :: Int32# -> Int32#
  negateInt32X16# :: Int32X16# -> Int32X16#
  negateInt32X4# :: Int32X4# -> Int32X4#
  negateInt32X8# :: Int32X8# -> Int32X8#
  negateInt64# :: Int64# -> Int64#
  negateInt64X2# :: Int64X2# -> Int64X2#
  negateInt64X4# :: Int64X4# -> Int64X4#
  negateInt64X8# :: Int64X8# -> Int64X8#
  negateInt8# :: Int8# -> Int8#
  negateInt8X16# :: Int8X16# -> Int8X16#
  negateInt8X32# :: Int8X32# -> Int8X32#
  negateInt8X64# :: Int8X64# -> Int8X64#
  newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newArray# :: Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
  newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)
  newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newIOPort# :: State# d -> (# State# d, IOPort# d a #)
  newMVar# :: State# d -> (# State# d, MVar# d a #)
  newMutVar# :: a -> State# d -> (# State# d, MutVar# d a #)
  newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)
  newSmallArray# :: Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
  newTVar# :: a -> State# d -> (# State# d, TVar# d a #)
  noDuplicate# :: State# d -> State# d
  noinline :: a -> a
  not :: Bool -> Bool
  not# :: Word# -> Word#
  not64# :: Word64# -> Word64#
  notI# :: Int# -> Int#
  notWord16# :: Word16# -> Word16#
  notWord32# :: Word32# -> Word32#
  notWord8# :: Word8# -> Word8#
  nullAddr# :: Addr#
  numSparks# :: State# d -> (# State# d, Int# #)
  oneShot :: (a -> b) -> a -> b
  or# :: Word# -> Word# -> Word#
  or64# :: Word64# -> Word64# -> Word64#
  orI# :: Int# -> Int# -> Int#
  orWord16# :: Word16# -> Word16# -> Word16#
  orWord32# :: Word32# -> Word32# -> Word32#
  orWord8# :: Word8# -> Word8# -> Word8#
  ord :: Char -> Int
  ord# :: Char# -> Int#
  otherwise :: Bool
  packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#
  packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#
  packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#
  packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#
  packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#
  packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#
  packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#
  packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#
  packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#
  packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#
  packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#
  packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#
  packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#
  packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#
  packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#
  packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#
  packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#
  packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#
  packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#
  packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#
  packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#
  packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#
  packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#
  packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#
  packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#
  packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#
  packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#
  packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#
  packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#
  packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#
  par# :: a -> Int#
  pdep# :: Word# -> Word# -> Word#
  pdep16# :: Word# -> Word# -> Word#
  pdep32# :: Word# -> Word# -> Word#
  pdep64# :: Word64# -> Word64# -> Word64#
  pdep8# :: Word# -> Word# -> Word#
  pext# :: Word# -> Word# -> Word#
  pext16# :: Word# -> Word# -> Word#
  pext32# :: Word# -> Word# -> Word#
  pext64# :: Word64# -> Word64# -> Word64#
  pext8# :: Word# -> Word# -> Word#
  plusAddr# :: Addr# -> Int# -> Addr#
  plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  plusFloat# :: Float# -> Float# -> Float#
  plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  plusInt16# :: Int16# -> Int16# -> Int16#
  plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  plusInt32# :: Int32# -> Int32# -> Int32#
  plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  plusInt64# :: Int64# -> Int64# -> Int64#
  plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  plusInt8# :: Int8# -> Int8# -> Int8#
  plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  plusWord# :: Word# -> Word# -> Word#
  plusWord16# :: Word16# -> Word16# -> Word16#
  plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
  plusWord32# :: Word32# -> Word32# -> Word32#
  plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  plusWord64# :: Word64# -> Word64# -> Word64#
  plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  plusWord8# :: Word8# -> Word8# -> Word8#
  plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  popCnt# :: Word# -> Word#
  popCnt16# :: Word# -> Word#
  popCnt32# :: Word# -> Word#
  popCnt64# :: Word64# -> Word#
  popCnt8# :: Word# -> Word#
  powerFloat# :: Float# -> Float# -> Float#
  prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
  prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchValue0# :: a -> State# d -> State# d
  prefetchValue1# :: a -> State# d -> State# d
  prefetchValue2# :: a -> State# d -> State# d
  prefetchValue3# :: a -> State# d -> State# d
  prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  proxy# :: forall {k} (a :: k). Proxy# a
  pure :: Applicative f => a -> f a
  putMVar# :: MVar# d a -> a -> State# d -> State# d
  quotInt :: Int -> Int -> Int
  quotInt# :: Int# -> Int# -> Int#
  quotInt16# :: Int16# -> Int16# -> Int16#
  quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  quotInt32# :: Int32# -> Int32# -> Int32#
  quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  quotInt64# :: Int64# -> Int64# -> Int64#
  quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  quotInt8# :: Int8# -> Int8# -> Int8#
  quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  quotRemInt :: Int -> Int -> (Int, Int)
  quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
  quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
  quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
  quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
  quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
  quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
  quotWord# :: Word# -> Word# -> Word#
  quotWord16# :: Word16# -> Word16# -> Word16#
  quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  quotWord32# :: Word32# -> Word32# -> Word32#
  quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  quotWord64# :: Word64# -> Word64# -> Word64#
  quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  quotWord8# :: Word8# -> Word8# -> Word8#
  quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  raise# :: a -> b
  raiseDivZero# :: (# #) -> b
  raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
  raiseOverflow# :: (# #) -> b
  raiseUnderflow# :: (# #) -> b
  readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)
  readArray# :: MutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)
  readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readIOPort# :: IOPort# d a -> State# d -> (# State# d, a #)
  readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)
  readMVar# :: MVar# d a -> State# d -> (# State# d, a #)
  readMutVar# :: MutVar# d a -> State# d -> (# State# d, a #)
  readSmallArray# :: SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readTVar# :: TVar# d a -> State# d -> (# State# d, a #)
  readTVarIO# :: TVar# d a -> State# d -> (# State# d, a #)
  readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)
  realWorld# :: State# RealWorld
  reallyUnsafePtrEquality :: a -> a -> Int#
  reallyUnsafePtrEquality# :: a -> b -> Int#
  remAddr# :: Addr# -> Int# -> Int#
  remInt :: Int -> Int -> Int
  remInt# :: Int# -> Int# -> Int#
  remInt16# :: Int16# -> Int16# -> Int16#
  remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  remInt32# :: Int32# -> Int32# -> Int32#
  remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  remInt64# :: Int64# -> Int64# -> Int64#
  remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  remInt8# :: Int8# -> Int8# -> Int8#
  remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  remWord# :: Word# -> Word# -> Word#
  remWord16# :: Word16# -> Word16# -> Word16#
  remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  remWord32# :: Word32# -> Word32# -> Word32#
  remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  remWord64# :: Word64# -> Word64# -> Word64#
  remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  remWord8# :: Word8# -> Word8# -> Word8#
  remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  retry# :: State# RealWorld -> (# State# RealWorld, a #)
  return :: Monad m => a -> m a
  returnIO :: a -> IO a
  rightSection :: (a -> b -> c) -> b -> a -> c
  runRW# :: (State# RealWorld -> o) -> o
  sameArray# :: Array# a -> Array# a -> Int#
  sameByteArray# :: ByteArray# -> ByteArray# -> Int#
  sameIOPort# :: IOPort# s a -> IOPort# s a -> Int#
  sameMVar# :: MVar# s a -> MVar# s a -> Int#
  sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
  sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
  sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
  samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#
  sameSmallArray# :: SmallArray# a -> SmallArray# a -> Int#
  sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
  sameTVar# :: TVar# s a -> TVar# s a -> Int#
  sconcat :: Semigroup a => NonEmpty a -> a
  seq :: a -> b -> b
  seq# :: a -> State# d -> (# State# d, a #)
  sequence :: Monad m => [m a] -> m [a]
  setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d
  setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
  shiftL# :: Word# -> Int# -> Word#
  shiftRL# :: Word# -> Int# -> Word#
  shift_mask :: Int# -> Int# -> Int#
  shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d
  shrinkSmallMutableArray# :: SmallMutableArray# d a -> Int# -> State# d -> State# d
  sinDouble# :: Double# -> Double#
  sinFloat# :: Float# -> Float#
  sinhDouble# :: Double# -> Double#
  sinhFloat# :: Float# -> Float#
  sizeofArray# :: Array# a -> Int#
  sizeofByteArray# :: ByteArray# -> Int#
  sizeofMutableArray# :: MutableArray# d a -> Int#
  sizeofMutableByteArray# :: MutableByteArray# d -> Int#
  sizeofSmallArray# :: SmallArray# a -> Int#
  sizeofSmallMutableArray# :: SmallMutableArray# d a -> Int#
  some :: Alternative f => f a -> f [a]
  spark# :: a -> State# d -> (# State# d, a #)
  sqrtDouble# :: Double# -> Double#
  sqrtFloat# :: Float# -> Float#
  stableNameToInt# :: StableName# a -> Int#
  stimes :: (Semigroup a, GHC.Real.Integral b) => b -> a -> a
  subInt16# :: Int16# -> Int16# -> Int16#
  subInt32# :: Int32# -> Int32# -> Int32#
  subInt64# :: Int64# -> Int64# -> Int64#
  subInt8# :: Int8# -> Int8# -> Int8#
  subIntC# :: Int# -> Int# -> (# Int#, Int# #)
  subWord16# :: Word16# -> Word16# -> Word16#
  subWord32# :: Word32# -> Word32# -> Word32#
  subWord64# :: Word64# -> Word64# -> Word64#
  subWord8# :: Word8# -> Word8# -> Word8#
  subWordC# :: Word# -> Word# -> (# Word#, Int# #)
  tagToEnum# :: Int# -> a
  takeMVar# :: MVar# d a -> State# d -> (# State# d, a #)
  tanDouble# :: Double# -> Double#
  tanFloat# :: Float# -> Float#
  tanhDouble# :: Double# -> Double#
  tanhFloat# :: Float# -> Float#
  thawArray# :: Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  thenIO :: IO a -> IO b -> IO b
  threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
  threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
  timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  timesFloat# :: Float# -> Float# -> Float#
  timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  timesInt16# :: Int16# -> Int16# -> Int16#
  timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
  timesInt32# :: Int32# -> Int32# -> Int32#
  timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  timesInt64# :: Int64# -> Int64# -> Int64#
  timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  timesInt8# :: Int8# -> Int8# -> Int8#
  timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  timesWord# :: Word# -> Word# -> Word#
  timesWord16# :: Word16# -> Word16# -> Word16#
  timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
  timesWord32# :: Word32# -> Word32# -> Word32#
  timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  timesWord64# :: Word64# -> Word64# -> Word64#
  timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  timesWord8# :: Word8# -> Word8# -> Word8#
  timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  touch# :: a -> State# RealWorld -> State# RealWorld
  traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d
  traceEvent# :: Addr# -> State# d -> State# d
  traceMarker# :: Addr# -> State# d -> State# d
  tryPutMVar# :: MVar# d a -> a -> State# d -> (# State# d, Int# #)
  tryReadMVar# :: MVar# d a -> State# d -> (# State# d, Int#, a #)
  tryTakeMVar# :: MVar# d a -> State# d -> (# State# d, Int#, a #)
  unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
  uncheckedIShiftL# :: Int# -> Int# -> Int#
  uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRA# :: Int# -> Int# -> Int#
  uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRL# :: Int# -> Int# -> Int#
  uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
  uncheckedShiftL# :: Word# -> Int# -> Word#
  uncheckedShiftL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
  uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRL# :: Word# -> Int# -> Word#
  uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
  undefined :: GHC.Stack.Types.HasCallStack => a
  unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  unpackAppendCString# :: Addr# -> [Char] -> [Char]
  unpackAppendCStringUtf8# :: Addr# -> [Char] -> [Char]
  unpackCString# :: Addr# -> [Char]
  unpackCStringUtf8# :: Addr# -> [Char]
  unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
  unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)
  unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)
  unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)
  unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)
  unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
  unpackFoldrCStringUtf8# :: Addr# -> (Char -> a -> a) -> a -> a
  unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)
  unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)
  unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)
  unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackNBytes# :: Addr# -> Int# -> [Char]
  unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)
  unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)
  unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)
  unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unsafeChr :: Int -> Char
  unsafeFreezeArray# :: MutableArray# d a -> State# d -> (# State# d, Array# a #)
  unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
  unsafeFreezeSmallArray# :: SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)
  unsafePtrEquality# :: a -> b -> Int#
  unsafeThawArray# :: Array# a -> State# d -> (# State# d, MutableArray# d a #)
  unsafeThawSmallArray# :: SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)
  until :: (a -> Bool) -> (a -> a) -> a -> a
  vacuous :: Functor f => f Void -> f a
  void# :: (# #)
  waitRead# :: Int# -> State# d -> State# d
  waitWrite# :: Int# -> State# d -> State# d
  when :: Applicative f => Bool -> f () -> f ()
  whereFrom# :: a -> State# d -> (# State# d, Addr# #)
  withDict :: WithDict cls meth => meth -> (cls => r) -> r
  word16ToInt16# :: Word16# -> Int16#
  word16ToWord# :: Word16# -> Word#
  word2Double# :: Word# -> Double#
  word2Float# :: Word# -> Float#
  word2Int# :: Word# -> Int#
  word32ToInt32# :: Word32# -> Int32#
  word32ToWord# :: Word32# -> Word#
  word64ToInt64# :: Word64# -> Int64#
  word64ToWord# :: Word64# -> Word#
  word8ToInt8# :: Word8# -> Int8#
  word8ToWord# :: Word8# -> Word#
  wordToWord16# :: Word# -> Word16#
  wordToWord32# :: Word# -> Word32#
  wordToWord64# :: Word# -> Word64#
  wordToWord8# :: Word# -> Word8#
  writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d
  writeArray# :: MutableArray# d a -> Int# -> a -> State# d -> State# d
  writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d
  writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d
  writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeIOPort# :: IOPort# d a -> a -> State# d -> (# State# d, Int# #)
  writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d
  writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d
  writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d
  writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d
  writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d
  writeMutVar# :: MutVar# d a -> a -> State# d -> State# d
  writeSmallArray# :: SmallMutableArray# d a -> Int# -> a -> State# d -> State# d
  writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d
  writeTVar# :: TVar# d a -> a -> State# d -> State# d
  writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d
  writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d
  writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d
  writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d
  writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d
  writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d
  xor# :: Word# -> Word# -> Word#
  xor64# :: Word64# -> Word64# -> Word64#
  xorI# :: Int# -> Int# -> Int#
  xorWord16# :: Word16# -> Word16# -> Word16#
  xorWord32# :: Word32# -> Word32# -> Word32#
  xorWord8# :: Word8# -> Word8# -> Word8#
  yield# :: State# RealWorld -> State# RealWorld
  (||) :: Bool -> Bool -> Bool
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b

module GHC.Bits where
  (.&.) :: Bits a => a -> a -> a
  (.|.) :: Bits a => a -> a -> a
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a
    ...
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b
    ...
  bit :: Bits a => GHC.Types.Int -> a
  bitDefault :: (Bits a, GHC.Num.Num a) => GHC.Types.Int -> a
  bitSize :: Bits a => a -> GHC.Types.Int
  bitSizeMaybe :: Bits a => a -> GHC.Maybe.Maybe GHC.Types.Int
  clearBit :: Bits a => a -> GHC.Types.Int -> a
  complement :: Bits a => a -> a
  complementBit :: Bits a => a -> GHC.Types.Int -> a
  countLeadingZeros :: FiniteBits b => b -> GHC.Types.Int
  countTrailingZeros :: FiniteBits b => b -> GHC.Types.Int
  finiteBitSize :: FiniteBits b => b -> GHC.Types.Int
  isSigned :: Bits a => a -> GHC.Types.Bool
  popCount :: Bits a => a -> GHC.Types.Int
  popCountDefault :: (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int
  rotate :: Bits a => a -> GHC.Types.Int -> a
  rotateL :: Bits a => a -> GHC.Types.Int -> a
  rotateR :: Bits a => a -> GHC.Types.Int -> a
  setBit :: Bits a => a -> GHC.Types.Int -> a
  shift :: Bits a => a -> GHC.Types.Int -> a
  shiftL :: Bits a => a -> GHC.Types.Int -> a
  shiftR :: Bits a => a -> GHC.Types.Int -> a
  testBit :: Bits a => a -> GHC.Types.Int -> GHC.Types.Bool
  testBitDefault :: (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int -> GHC.Types.Bool
  toIntegralSized :: (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  unsafeShiftL :: Bits a => a -> GHC.Types.Int -> a
  unsafeShiftR :: Bits a => a -> GHC.Types.Int -> a
  xor :: Bits a => a -> a -> a
  zeroBits :: Bits a => a

module GHC.ByteOrder where
  BigEndian :: ByteOrder
  type ByteOrder :: *
  data ByteOrder = ...
  LittleEndian :: ByteOrder
  targetByteOrder :: ByteOrder

module GHC.Char where
  chr :: GHC.Types.Int -> GHC.Types.Char
  eqChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool
  neChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool

module GHC.Clock where
  getMonotonicTime :: GHC.Types.IO GHC.Types.Double
  getMonotonicTimeNSec :: GHC.Types.IO GHC.Word.Word64

module GHC.Conc where
  type BlockReason :: *
  data BlockReason = ...
  BlockedOnBlackHole :: BlockReason
  BlockedOnException :: BlockReason
  BlockedOnForeignCall :: BlockReason
  BlockedOnMVar :: BlockReason
  BlockedOnOther :: BlockReason
  BlockedOnSTM :: BlockReason
  type HandlerFun :: *
  type HandlerFun = GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.IO ()
  type PrimMVar :: *
  data PrimMVar
  STM :: (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> STM a
  type STM :: * -> *
  newtype STM a = ...
  type Signal :: *
  type Signal = Foreign.C.Types.CInt
  TVar :: GHC.Prim.TVar# GHC.Prim.RealWorld a -> TVar a
  type TVar :: * -> *
  data TVar a = ...
  ThreadBlocked :: BlockReason -> ThreadStatus
  ThreadDied :: ThreadStatus
  ThreadFinished :: ThreadStatus
  ThreadId :: GHC.Prim.ThreadId# -> ThreadId
  type ThreadId :: *
  data ThreadId = ...
  ThreadRunning :: ThreadStatus
  type ThreadStatus :: *
  data ThreadStatus = ...
  atomically :: STM a -> GHC.Types.IO a
  catchSTM :: GHC.Exception.Type.Exception e => STM a -> (e -> STM a) -> STM a
  childHandler :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  closeFdWith :: (System.Posix.Types.Fd -> GHC.Types.IO ()) -> System.Posix.Types.Fd -> GHC.Types.IO ()
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  ensureIOManagerIsRunning :: GHC.Types.IO ()
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  getNumProcessors :: GHC.Types.IO GHC.Types.Int
  getUncaughtExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  ioManagerCapabilitiesChanged :: GHC.Types.IO ()
  killThread :: ThreadId -> GHC.Types.IO ()
  labelThread :: ThreadId -> GHC.Base.String -> GHC.Types.IO ()
  listThreads :: GHC.Types.IO [ThreadId]
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  myThreadId :: GHC.Types.IO ThreadId
  newStablePtrPrimMVar :: GHC.MVar.MVar a -> GHC.Types.IO (GHC.Stable.StablePtr PrimMVar)
  newTVar :: a -> STM (TVar a)
  newTVarIO :: a -> GHC.Types.IO (TVar a)
  numCapabilities :: GHC.Types.Int
  numSparks :: GHC.Types.IO GHC.Types.Int
  orElse :: STM a -> STM a -> STM a
  par :: a -> b -> b
  pseq :: a -> b -> b
  readTVar :: TVar a -> STM a
  readTVarIO :: TVar a -> GHC.Types.IO a
  registerDelay :: GHC.Types.Int -> GHC.Types.IO (TVar GHC.Types.Bool)
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportHeapOverflow :: GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  retry :: STM a
  runHandlers :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  runSparks :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()
  setHandler :: Signal -> GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic) -> GHC.Types.IO (GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic))
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  setUncaughtExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadDelay :: GHC.Types.Int -> GHC.Types.IO ()
  threadStatus :: ThreadId -> GHC.Types.IO ThreadStatus
  threadWaitRead :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitReadSTM :: System.Posix.Types.Fd -> GHC.Types.IO (STM (), GHC.Types.IO ())
  threadWaitWrite :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitWriteSTM :: System.Posix.Types.Fd -> GHC.Types.IO (STM (), GHC.Types.IO ())
  throwSTM :: GHC.Exception.Type.Exception e => e -> STM a
  throwTo :: GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  unsafeIOToSTM :: GHC.Types.IO a -> STM a
  withMVar :: GHC.MVar.MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeTVar :: TVar a -> a -> STM ()
  yield :: GHC.Types.IO ()

module GHC.Conc.IO where

-- ignored


module GHC.Conc.Signal where
  type HandlerFun :: *
  type HandlerFun = GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.IO ()
  type Signal :: *
  type Signal = Foreign.C.Types.CInt
  runHandlers :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  runHandlersPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  setHandler :: Signal -> GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic) -> GHC.Types.IO (GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic))

module GHC.Conc.Sync where
  type BlockReason :: *
  data BlockReason = ...
  BlockedOnBlackHole :: BlockReason
  BlockedOnException :: BlockReason
  BlockedOnForeignCall :: BlockReason
  BlockedOnMVar :: BlockReason
  BlockedOnOther :: BlockReason
  BlockedOnSTM :: BlockReason
  type PrimMVar :: *
  data PrimMVar
  STM :: (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> STM a
  type STM :: * -> *
  newtype STM a = ...
  TVar :: GHC.Prim.TVar# GHC.Prim.RealWorld a -> TVar a
  type TVar :: * -> *
  data TVar a = ...
  ThreadBlocked :: BlockReason -> ThreadStatus
  ThreadDied :: ThreadStatus
  ThreadFinished :: ThreadStatus
  ThreadId :: GHC.Prim.ThreadId# -> ThreadId
  type ThreadId :: *
  data ThreadId = ...
  ThreadRunning :: ThreadStatus
  type ThreadStatus :: *
  data ThreadStatus = ...
  atomically :: STM a -> GHC.Types.IO a
  catchSTM :: GHC.Exception.Type.Exception e => STM a -> (e -> STM a) -> STM a
  childHandler :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  getNumProcessors :: GHC.Types.IO GHC.Types.Int
  getUncaughtExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  killThread :: ThreadId -> GHC.Types.IO ()
  labelThread :: ThreadId -> GHC.Base.String -> GHC.Types.IO ()
  labelThreadByteArray# :: ThreadId -> GHC.Prim.ByteArray# -> GHC.Types.IO ()
  listThreads :: GHC.Types.IO [ThreadId]
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  modifyMVar_ :: GHC.MVar.MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  myThreadId :: GHC.Types.IO ThreadId
  newStablePtrPrimMVar :: GHC.MVar.MVar a -> GHC.Types.IO (GHC.Stable.StablePtr PrimMVar)
  newTVar :: a -> STM (TVar a)
  newTVarIO :: a -> GHC.Types.IO (TVar a)
  numCapabilities :: GHC.Types.Int
  numSparks :: GHC.Types.IO GHC.Types.Int
  orElse :: STM a -> STM a -> STM a
  par :: a -> b -> b
  pseq :: a -> b -> b
  readTVar :: TVar a -> STM a
  readTVarIO :: TVar a -> GHC.Types.IO a
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportHeapOverflow :: GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  retry :: STM a
  runSparks :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  setUncaughtExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()
  sharedCAF :: a -> (GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)) -> GHC.Types.IO a
  showThreadId :: ThreadId -> GHC.Base.String
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadLabel :: ThreadId -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  threadStatus :: ThreadId -> GHC.Types.IO ThreadStatus
  throwSTM :: GHC.Exception.Type.Exception e => e -> STM a
  throwTo :: GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  unsafeIOToSTM :: GHC.Types.IO a -> STM a
  withMVar :: GHC.MVar.MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeTVar :: TVar a -> a -> STM ()
  yield :: GHC.Types.IO ()

module GHC.ConsoleHandler where


module GHC.Constants where


module GHC.Desugar where
  (>>>) :: Control.Arrow.Arrow arr => arr a b -> arr b c -> arr a c
  AnnotationWrapper :: Data.Data.Data a => a -> AnnotationWrapper
  type AnnotationWrapper :: *
  data AnnotationWrapper = ...
  toAnnotationWrapper :: Data.Data.Data a => a -> AnnotationWrapper

module GHC.Encoding.UTF8 where
  utf8CompareByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.ByteArray# -> GHC.Types.Ordering
  utf8CountCharsByteArray# :: GHC.Prim.ByteArray# -> GHC.Types.Int
  utf8DecodeByteArray# :: GHC.Prim.ByteArray# -> [GHC.Types.Char]
  utf8DecodeCharAddr# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> (# GHC.Prim.Char#, GHC.Prim.Int# #)
  utf8DecodeCharByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.Int# -> (# GHC.Prim.Char#, GHC.Prim.Int# #)
  utf8DecodeCharPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> (GHC.Types.Char, GHC.Types.Int)
  utf8DecodeForeignPtr :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Char]
  utf8EncodeByteArray# :: GHC.Base.String -> GHC.Prim.ByteArray#
  utf8EncodePtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Base.String -> GHC.Types.IO ()
  utf8EncodedLength :: GHC.Base.String -> GHC.Types.Int

module GHC.Enum where
  type Bounded :: * -> Constraint
  class Bounded a
    ...
  type Enum :: * -> Constraint
  class Enum a
    ...
  boundedEnumFrom :: (Enum a, Bounded a) => a -> [a]
  boundedEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
  enumFrom :: Enum a => a -> [a]
  enumFromThen :: Enum a => a -> a -> [a]
  enumFromThenTo :: Enum a => a -> a -> a -> [a]
  enumFromTo :: Enum a => a -> a -> [a]
  fromEnum :: Enum a => a -> GHC.Types.Int
  fromEnumError :: GHC.Show.Show a => GHC.Base.String -> a -> b
  maxBound :: Bounded a => a
  minBound :: Bounded a => a
  pred :: Enum a => a -> a
  predError :: GHC.Base.String -> a
  succ :: Enum a => a -> a
  succError :: GHC.Base.String -> a
  toEnum :: Enum a => GHC.Types.Int -> a
  toEnumError :: GHC.Show.Show a => GHC.Base.String -> GHC.Types.Int -> (a, a) -> b

module GHC.Environment where
  getFullArgs :: GHC.Types.IO [GHC.Base.String]

module GHC.Err where
  absentErr :: a
  error :: GHC.Stack.Types.HasCallStack => [GHC.Types.Char] -> a
  errorWithoutStackTrace :: [GHC.Types.Char] -> a
  undefined :: GHC.Stack.Types.HasCallStack => a

module GHC.Event where
  type Event :: *
  newtype Event = ...
  type EventManager :: *
  data EventManager = ...
  type FdKey :: *
  data FdKey = ...
  type IOCallback :: *
  type IOCallback = FdKey -> Event -> GHC.Types.IO ()
  type Lifetime :: *
  data Lifetime = ...
  MultiShot :: Lifetime
  OneShot :: Lifetime
  type TimeoutCallback :: *
  type TimeoutCallback = GHC.Types.IO ()
  type TimeoutKey :: *
  newtype TimeoutKey = ...
  type TimerManager :: *
  data TimerManager = ...
  closeFd :: EventManager -> (System.Posix.Types.Fd -> GHC.Types.IO ()) -> System.Posix.Types.Fd -> GHC.Types.IO ()
  evtRead :: Event
  evtWrite :: Event
  getSystemEventManager :: GHC.Types.IO (GHC.Maybe.Maybe EventManager)
  getSystemTimerManager :: GHC.Types.IO TimerManager
  keyFd :: FdKey -> System.Posix.Types.Fd
  new :: GHC.Types.IO EventManager
  registerFd :: EventManager -> IOCallback -> System.Posix.Types.Fd -> Event -> Lifetime -> GHC.Types.IO FdKey
  registerTimeout :: TimerManager -> GHC.Types.Int -> TimeoutCallback -> GHC.Types.IO TimeoutKey
  unregisterFd :: EventManager -> FdKey -> GHC.Types.IO ()
  unregisterFd_ :: EventManager -> FdKey -> GHC.Types.IO GHC.Types.Bool
  unregisterTimeout :: TimerManager -> TimeoutKey -> GHC.Types.IO ()
  updateTimeout :: TimerManager -> TimeoutKey -> GHC.Types.Int -> GHC.Types.IO ()

module GHC.Event.TimeOut where
  TK :: base-4.18.0.0:GHC.Event.Unique.Unique -> TimeoutKey
  type TimeoutCallback :: *
  type TimeoutCallback = GHC.Types.IO ()
  type TimeoutEdit :: *
  type TimeoutEdit = TimeoutQueue -> TimeoutQueue
  type TimeoutKey :: *
  newtype TimeoutKey = ...
  type TimeoutQueue :: *
  type TimeoutQueue = base-4.18.0.0:GHC.Event.PSQ.PSQ TimeoutCallback

module GHC.Exception where
  type ArithException :: *
  data ArithException = ...
  type CallStack :: *
  data CallStack = ...
  Denormal :: ArithException
  DivideByZero :: ArithException
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ...
  ErrorCallWithLocation :: GHC.Base.String -> GHC.Base.String -> ErrorCall
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e
    ...
  LossOfPrecision :: ArithException
  Overflow :: ArithException
  RatioZeroDenominator :: ArithException
  SomeException :: Exception e => e -> SomeException
  type SomeException :: *
  data SomeException = ...
  SrcLoc :: [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> SrcLoc
  type SrcLoc :: *
  data SrcLoc = ...
  Underflow :: ArithException
  displayException :: Exception e => e -> GHC.Base.String
  divZeroException :: SomeException
  errorCallException :: GHC.Base.String -> SomeException
  errorCallWithCallStackException :: GHC.Base.String -> CallStack -> SomeException
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  fromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  overflowException :: SomeException
  prettyCallStack :: CallStack -> GHC.Base.String
  prettyCallStackLines :: CallStack -> [GHC.Base.String]
  prettySrcLoc :: SrcLoc -> GHC.Base.String
  ratioZeroDenomException :: SomeException
  showCCSStack :: [GHC.Base.String] -> [GHC.Base.String]
  srcLocEndCol :: SrcLoc -> GHC.Types.Int
  srcLocEndLine :: SrcLoc -> GHC.Types.Int
  srcLocFile :: SrcLoc -> [GHC.Types.Char]
  srcLocModule :: SrcLoc -> [GHC.Types.Char]
  srcLocPackage :: SrcLoc -> [GHC.Types.Char]
  srcLocStartCol :: SrcLoc -> GHC.Types.Int
  srcLocStartLine :: SrcLoc -> GHC.Types.Int
  throw :: Exception e => e -> a
  toException :: Exception e => e -> SomeException
  underflowException :: SomeException

module GHC.Exception.Type where
  type ArithException :: *
  data ArithException = ...
  Denormal :: ArithException
  DivideByZero :: ArithException
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e
    ...
  LossOfPrecision :: ArithException
  Overflow :: ArithException
  RatioZeroDenominator :: ArithException
  SomeException :: Exception e => e -> SomeException
  type SomeException :: *
  data SomeException = ...
  Underflow :: ArithException
  displayException :: Exception e => e -> GHC.Base.String
  divZeroException :: SomeException
  fromException :: Exception e => SomeException -> GHC.Maybe.Maybe e
  overflowException :: SomeException
  ratioZeroDenomException :: SomeException
  toException :: Exception e => e -> SomeException
  underflowException :: SomeException

module GHC.ExecutionStack where
  Location :: GHC.Base.String -> GHC.Base.String -> GHC.Maybe.Maybe SrcLoc -> Location
  type Location :: *
  data Location = ...
  SrcLoc :: GHC.Base.String -> GHC.Types.Int -> GHC.Types.Int -> SrcLoc
  type SrcLoc :: *
  data SrcLoc = ...
  functionName :: Location -> GHC.Base.String
  getStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe [Location])
  objectName :: Location -> GHC.Base.String
  showStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  sourceColumn :: SrcLoc -> GHC.Types.Int
  sourceFile :: SrcLoc -> GHC.Base.String
  sourceLine :: SrcLoc -> GHC.Types.Int
  srcLoc :: Location -> GHC.Maybe.Maybe SrcLoc

module GHC.ExecutionStack.Internal where
  Location :: GHC.Base.String -> GHC.Base.String -> GHC.Maybe.Maybe SrcLoc -> Location
  type Location :: *
  data Location = ...
  SrcLoc :: GHC.Base.String -> GHC.Types.Int -> GHC.Types.Int -> SrcLoc
  type SrcLoc :: *
  data SrcLoc = ...
  type StackTrace :: *
  newtype StackTrace = ...
  collectStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe StackTrace)
  functionName :: Location -> GHC.Base.String
  invalidateDebugCache :: GHC.Types.IO ()
  objectName :: Location -> GHC.Base.String
  showStackFrames :: [Location] -> GHC.Show.ShowS
  sourceColumn :: SrcLoc -> GHC.Types.Int
  sourceFile :: SrcLoc -> GHC.Base.String
  sourceLine :: SrcLoc -> GHC.Types.Int
  srcLoc :: Location -> GHC.Maybe.Maybe SrcLoc
  stackDepth :: StackTrace -> GHC.Types.Int
  stackFrames :: StackTrace -> GHC.Maybe.Maybe [Location]

module GHC.Exts where
  (*#) :: Int# -> Int# -> Int#
  (*##) :: Double# -> Double# -> Double#
  (**##) :: Double# -> Double# -> Double#
  (+#) :: Int# -> Int# -> Int#
  (+##) :: Double# -> Double# -> Double#
  (-#) :: Int# -> Int# -> Int#
  (-##) :: Double# -> Double# -> Double#
  (/##) :: Double# -> Double# -> Double#
  (/=#) :: Int# -> Int# -> Int#
  (/=##) :: Double# -> Double# -> Int#
  (<#) :: Int# -> Int# -> Int#
  (<##) :: Double# -> Double# -> Int#
  (<=#) :: Int# -> Int# -> Int#
  (<=##) :: Double# -> Double# -> Int#
  (==#) :: Int# -> Int# -> Int#
  (==##) :: Double# -> Double# -> Int#
  (>#) :: Int# -> Int# -> Int#
  (>##) :: Double# -> Double# -> Int#
  (>=#) :: Int# -> Int# -> Int#
  (>=##) :: Double# -> Double# -> Int#
  type Addr# :: TYPE AddrRep
  data Addr#
  AddrRep :: RuntimeRep
  type Any :: forall k. k
  type family Any
  type Array# :: * -> UnliftedType
  data Array# a
  ArrayArray# :: Array# ByteArray# -> ArrayArray#
  type ArrayArray# :: UnliftedType
  newtype ArrayArray# = ...
  type BCO :: *
  data BCO
  type Bool :: *
  data Bool = ...
  BoxedRep :: Levity -> RuntimeRep
  type ByteArray# :: UnliftedType
  data ByteArray#
  C# :: Char# -> Char
  type role CONSTRAINT nominal
  type CONSTRAINT :: RuntimeRep -> *
  data CONSTRAINT a
  type Char :: *
  data Char = ...
  type Char# :: TYPE WordRep
  data Char#
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
  type Compact# :: UnliftedType
  data Compact#
  type Constraint :: *
  type Constraint = CONSTRAINT LiftedRep
  D# :: Double# -> Double
  type DictBox :: Constraint -> *
  data DictBox a = ...
  type Double :: *
  data Double = ...
  type Double# :: TYPE DoubleRep
  data Double#
  type DoubleBox :: TYPE DoubleRep -> *
  data DoubleBox a = ...
  DoubleElemRep :: VecElem
  DoubleRep :: RuntimeRep
  type DoubleX2# :: TYPE (VecRep Vec2 DoubleElemRep)
  data DoubleX2#
  type DoubleX4# :: TYPE (VecRep Vec4 DoubleElemRep)
  data DoubleX4#
  type DoubleX8# :: TYPE (VecRep Vec8 DoubleElemRep)
  data DoubleX8#
  Down :: a -> Down a
  type Down :: * -> *
  newtype Down a = ...
  EQ :: Ordering
  F# :: Float# -> Float
  type role FUN nominal representational representational
  type FUN :: forall (n :: Multiplicity) -> * -> * -> *
  data FUN n a b
  False :: Bool
  type Float :: *
  data Float = ...
  type Float# :: TYPE FloatRep
  data Float#
  type FloatBox :: TYPE FloatRep -> *
  data FloatBox a = ...
  FloatElemRep :: VecElem
  FloatRep :: RuntimeRep
  type FloatX16# :: TYPE (VecRep Vec16 FloatElemRep)
  data FloatX16#
  type FloatX4# :: TYPE (VecRep Vec4 FloatElemRep)
  data FloatX4#
  type FloatX8# :: TYPE (VecRep Vec8 FloatElemRep)
  data FloatX8#
  ForceSpecConstr :: SpecConstrAnnotation
  FunPtr :: Addr# -> FunPtr a
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  GT :: Ordering
  I# :: Int# -> Int
  type role IOPort# nominal representational
  type IOPort# :: * -> * -> UnliftedType
  data IOPort# a b
  type Int :: *
  data Int = ...
  type Int# :: TYPE IntRep
  data Int#
  type Int16# :: TYPE Int16Rep
  data Int16#
  Int16ElemRep :: VecElem
  Int16Rep :: RuntimeRep
  type Int16X16# :: TYPE (VecRep Vec16 Int16ElemRep)
  data Int16X16#
  type Int16X32# :: TYPE (VecRep Vec32 Int16ElemRep)
  data Int16X32#
  type Int16X8# :: TYPE (VecRep Vec8 Int16ElemRep)
  data Int16X8#
  type Int32# :: TYPE Int32Rep
  data Int32#
  Int32ElemRep :: VecElem
  Int32Rep :: RuntimeRep
  type Int32X16# :: TYPE (VecRep Vec16 Int32ElemRep)
  data Int32X16#
  type Int32X4# :: TYPE (VecRep Vec4 Int32ElemRep)
  data Int32X4#
  type Int32X8# :: TYPE (VecRep Vec8 Int32ElemRep)
  data Int32X8#
  type Int64# :: TYPE Int64Rep
  data Int64#
  Int64ElemRep :: VecElem
  Int64Rep :: RuntimeRep
  type Int64X2# :: TYPE (VecRep Vec2 Int64ElemRep)
  data Int64X2#
  type Int64X4# :: TYPE (VecRep Vec4 Int64ElemRep)
  data Int64X4#
  type Int64X8# :: TYPE (VecRep Vec8 Int64ElemRep)
  data Int64X8#
  type Int8# :: TYPE Int8Rep
  data Int8#
  Int8ElemRep :: VecElem
  Int8Rep :: RuntimeRep
  type Int8X16# :: TYPE (VecRep Vec16 Int8ElemRep)
  data Int8X16#
  type Int8X32# :: TYPE (VecRep Vec32 Int8ElemRep)
  data Int8X32#
  type Int8X64# :: TYPE (VecRep Vec64 Int8ElemRep)
  data Int8X64#
  type IntBox :: TYPE IntRep -> *
  data IntBox a = ...
  IntRep :: RuntimeRep
  type IsList :: * -> Constraint
  class IsList l
    ...
    ...
  type IsString :: * -> Constraint
  class IsString a
    ...
  type Item :: * -> *
  type family Item l
  KindRepApp :: GHC.Types.KindRep -> GHC.Types.KindRep -> GHC.Types.KindRep
  KindRepFun :: GHC.Types.KindRep -> GHC.Types.KindRep -> GHC.Types.KindRep
  KindRepTYPE :: RuntimeRep -> GHC.Types.KindRep
  KindRepTyConApp :: GHC.Types.TyCon -> [GHC.Types.KindRep] -> GHC.Types.KindRep
  KindRepTypeLitD :: GHC.Types.TypeLitSort -> [Char] -> GHC.Types.KindRep
  KindRepTypeLitS :: GHC.Types.TypeLitSort -> Addr# -> GHC.Types.KindRep
  KindRepVar :: GHC.Types.KindBndr -> GHC.Types.KindRep
  LT :: Ordering
  type Levity :: *
  data Levity = ...
  Lifted :: Levity
  type LiftedRep :: RuntimeRep
  type LiftedRep = BoxedRep Lifted :: RuntimeRep
  type List :: * -> *
  data List a = ...
  type role MVar# nominal representational
  type MVar# :: * -> * -> UnliftedType
  data MVar# a b
  Many :: Multiplicity
  MkDictBox :: a => DictBox a
  MkDoubleBox :: a -> DoubleBox a
  MkFloatBox :: a -> FloatBox a
  MkIntBox :: a -> IntBox a
  MkWordBox :: a -> WordBox a
  type MultMul :: Multiplicity -> Multiplicity -> Multiplicity
  type family MultMul a b
  type Multiplicity :: *
  data Multiplicity = ...
  type role MutVar# nominal representational
  type MutVar# :: * -> * -> UnliftedType
  data MutVar# a b
  type role MutableArray# nominal representational
  type MutableArray# :: * -> * -> UnliftedType
  data MutableArray# a b
  MutableArrayArray# :: MutableArray# s ByteArray# -> MutableArrayArray# s
  type role MutableArrayArray# nominal
  type MutableArrayArray# :: * -> UnliftedType
  newtype MutableArrayArray# s = ...
  type role MutableByteArray# nominal
  type MutableByteArray# :: * -> UnliftedType
  data MutableByteArray# a
  NoSpecConstr :: SpecConstrAnnotation
  One :: Multiplicity
  type Ordering :: *
  data Ordering = ...
  type PromptTag# :: * -> UnliftedType
  data PromptTag# a
  type role Proxy# phantom
  type Proxy# :: forall k. k -> ZeroBitType
  data Proxy# a
  Ptr :: Addr# -> Ptr a
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type RealWorld :: *
  data RealWorld
  type RuntimeRep :: *
  data RuntimeRep = ...
  SPEC :: SPEC
  type SPEC :: *
  data SPEC = ...
  SPEC2 :: SPEC
  type SmallArray# :: * -> UnliftedType
  data SmallArray# a
  type role SmallMutableArray# nominal representational
  type SmallMutableArray# :: * -> * -> UnliftedType
  data SmallMutableArray# a b
  type SpecConstrAnnotation :: *
  data SpecConstrAnnotation = ...
  type role StableName# phantom
  type StableName# :: * -> UnliftedType
  data StableName# a
  type StablePtr# :: * -> TYPE AddrRep
  data StablePtr# a
  type StackSnapshot# :: UnliftedType
  data StackSnapshot#
  type role State# nominal
  type State# :: * -> ZeroBitType
  data State# a
  SumRep :: [RuntimeRep] -> RuntimeRep
  type Symbol :: *
  data Symbol
  type role TVar# nominal representational
  type TVar# :: * -> * -> UnliftedType
  data TVar# a b
  type role TYPE nominal
  type TYPE :: RuntimeRep -> *
  data TYPE a
  type ThreadId# :: UnliftedType
  data ThreadId#
  TrNameD :: [Char] -> GHC.Types.TrName
  TrNameS :: Addr# -> GHC.Types.TrName
  True :: Bool
  TupleRep :: [RuntimeRep] -> RuntimeRep
  TypeLitChar :: GHC.Types.TypeLitSort
  TypeLitNat :: GHC.Types.TypeLitSort
  TypeLitSymbol :: GHC.Types.TypeLitSort
  Unlifted :: Levity
  type UnliftedRep :: RuntimeRep
  type UnliftedRep = BoxedRep Unlifted :: RuntimeRep
  type UnliftedType :: *
  type UnliftedType = TYPE UnliftedRep
  Vec16 :: VecCount
  Vec2 :: VecCount
  Vec32 :: VecCount
  Vec4 :: VecCount
  Vec64 :: VecCount
  Vec8 :: VecCount
  type VecCount :: *
  data VecCount = ...
  type VecElem :: *
  data VecElem = ...
  VecRep :: VecCount -> VecElem -> RuntimeRep
  type Void# :: ZeroBitType
  type Void# = (# #) :: ZeroBitType
  W# :: Word# -> Word
  type Weak# :: * -> UnliftedType
  data Weak# a
  type WithDict :: Constraint -> * -> Constraint
  class WithDict cls meth
    ...
  type Word :: *
  data Word = ...
  type Word# :: TYPE WordRep
  data Word#
  type Word16# :: TYPE Word16Rep
  data Word16#
  Word16ElemRep :: VecElem
  Word16Rep :: RuntimeRep
  type Word16X16# :: TYPE (VecRep Vec16 Word16ElemRep)
  data Word16X16#
  type Word16X32# :: TYPE (VecRep Vec32 Word16ElemRep)
  data Word16X32#
  type Word16X8# :: TYPE (VecRep Vec8 Word16ElemRep)
  data Word16X8#
  type Word32# :: TYPE Word32Rep
  data Word32#
  Word32ElemRep :: VecElem
  Word32Rep :: RuntimeRep
  type Word32X16# :: TYPE (VecRep Vec16 Word32ElemRep)
  data Word32X16#
  type Word32X4# :: TYPE (VecRep Vec4 Word32ElemRep)
  data Word32X4#
  type Word32X8# :: TYPE (VecRep Vec8 Word32ElemRep)
  data Word32X8#
  type Word64# :: TYPE Word64Rep
  data Word64#
  Word64ElemRep :: VecElem
  Word64Rep :: RuntimeRep
  type Word64X2# :: TYPE (VecRep Vec2 Word64ElemRep)
  data Word64X2#
  type Word64X4# :: TYPE (VecRep Vec4 Word64ElemRep)
  data Word64X4#
  type Word64X8# :: TYPE (VecRep Vec8 Word64ElemRep)
  data Word64X8#
  type Word8# :: TYPE Word8Rep
  data Word8#
  Word8ElemRep :: VecElem
  Word8Rep :: RuntimeRep
  type Word8X16# :: TYPE (VecRep Vec16 Word8ElemRep)
  data Word8X16#
  type Word8X32# :: TYPE (VecRep Vec32 Word8ElemRep)
  data Word8X32#
  type Word8X64# :: TYPE (VecRep Vec64 Word8ElemRep)
  data Word8X64#
  type WordBox :: TYPE WordRep -> *
  data WordBox a = ...
  WordRep :: RuntimeRep
  type ZeroBitRep :: RuntimeRep
  type ZeroBitRep = TupleRep '[] :: RuntimeRep
  type ZeroBitType :: *
  type ZeroBitType = TYPE ZeroBitRep
  acosDouble# :: Double# -> Double#
  acosFloat# :: Float# -> Float#
  acoshDouble# :: Double# -> Double#
  acoshFloat# :: Float# -> Float#
  addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
  addIntC# :: Int# -> Int# -> (# Int#, Int# #)
  addWordC# :: Word# -> Word# -> (# Word#, Int# #)
  addr2Int# :: Addr# -> Int#
  addrToAny# :: Addr# -> (# a #)
  and# :: Word# -> Word# -> Word#
  and64# :: Word64# -> Word64# -> Word64#
  andI# :: Int# -> Int# -> Int#
  andWord16# :: Word16# -> Word16# -> Word16#
  andWord32# :: Word32# -> Word32# -> Word32#
  andWord8# :: Word8# -> Word8# -> Word8#
  anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
  asinDouble# :: Double# -> Double#
  asinFloat# :: Float# -> Float#
  asinhDouble# :: Double# -> Double#
  asinhFloat# :: Float# -> Float#
  atanDouble# :: Double# -> Double#
  atanFloat# :: Float# -> Float#
  atanhDouble# :: Double# -> Double#
  atanhFloat# :: Float# -> Float#
  atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)
  atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)
  atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)
  atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)
  atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)
  atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
  atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)
  atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)
  atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)
  atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d
  atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  augment :: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  bitReverse# :: Word# -> Word#
  bitReverse16# :: Word# -> Word#
  bitReverse32# :: Word# -> Word#
  bitReverse64# :: Word64# -> Word64#
  bitReverse8# :: Word# -> Word#
  breakpoint :: a -> a
  breakpointCond :: Bool -> a -> a
  broadcastDoubleX2# :: Double# -> DoubleX2#
  broadcastDoubleX4# :: Double# -> DoubleX4#
  broadcastDoubleX8# :: Double# -> DoubleX8#
  broadcastFloatX16# :: Float# -> FloatX16#
  broadcastFloatX4# :: Float# -> FloatX4#
  broadcastFloatX8# :: Float# -> FloatX8#
  broadcastInt16X16# :: Int16# -> Int16X16#
  broadcastInt16X32# :: Int16# -> Int16X32#
  broadcastInt16X8# :: Int16# -> Int16X8#
  broadcastInt32X16# :: Int32# -> Int32X16#
  broadcastInt32X4# :: Int32# -> Int32X4#
  broadcastInt32X8# :: Int32# -> Int32X8#
  broadcastInt64X2# :: Int64# -> Int64X2#
  broadcastInt64X4# :: Int64# -> Int64X4#
  broadcastInt64X8# :: Int64# -> Int64X8#
  broadcastInt8X16# :: Int8# -> Int8X16#
  broadcastInt8X32# :: Int8# -> Int8X32#
  broadcastInt8X64# :: Int8# -> Int8X64#
  broadcastWord16X16# :: Word16# -> Word16X16#
  broadcastWord16X32# :: Word16# -> Word16X32#
  broadcastWord16X8# :: Word16# -> Word16X8#
  broadcastWord32X16# :: Word32# -> Word32X16#
  broadcastWord32X4# :: Word32# -> Word32X4#
  broadcastWord32X8# :: Word32# -> Word32X8#
  broadcastWord64X2# :: Word64# -> Word64X2#
  broadcastWord64X4# :: Word64# -> Word64X4#
  broadcastWord64X8# :: Word64# -> Word64X8#
  broadcastWord8X16# :: Word8# -> Word8X16#
  broadcastWord8X32# :: Word8# -> Word8X32#
  broadcastWord8X64# :: Word8# -> Word8X64#
  build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
  byteArrayContents# :: ByteArray# -> Addr#
  byteSwap# :: Word# -> Word#
  byteSwap16# :: Word# -> Word#
  byteSwap32# :: Word# -> Word#
  byteSwap64# :: Word64# -> Word64#
  casArray# :: MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)
  casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)
  casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)
  casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)
  casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  casMutVar# :: MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
  casSmallArray# :: SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  chr# :: Int# -> Char#
  clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)
  cloneArray# :: Array# a -> Int# -> Int# -> Array# a
  cloneMutableArray# :: MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
  cloneSmallMutableArray# :: SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  closureSize# :: a -> Int#
  clz# :: Word# -> Word#
  clz16# :: Word# -> Word#
  clz32# :: Word# -> Word#
  clz64# :: Word64# -> Word#
  clz8# :: Word# -> Word#
  coerce :: Coercible a b => a -> b
  compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
  compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
  compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
  compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
  compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
  compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
  considerAccessible :: Bool
  control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)
  copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyArray# :: Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
  copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
  copyMutableArray# :: MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
  copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d
  copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copySmallMutableArray# :: SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  cosDouble# :: Double# -> Double#
  cosFloat# :: Float# -> Float#
  coshDouble# :: Double# -> Double#
  coshFloat# :: Float# -> Float#
  cstringLength# :: Addr# -> Int#
  ctz# :: Word# -> Word#
  ctz16# :: Word# -> Word#
  ctz32# :: Word# -> Word#
  ctz64# :: Word64# -> Word#
  ctz8# :: Word# -> Word#
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  dataToTag# :: a -> Int#
  deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
  deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
  decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
  decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
  decodeFloat_Int# :: Float# -> (# Int#, Int# #)
  delay# :: Int# -> State# d -> State# d
  divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  divideFloat# :: Float# -> Float# -> Float#
  divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  double2Float# :: Double# -> Float#
  double2Int# :: Double# -> Int#
  eqAddr# :: Addr# -> Addr# -> Int#
  eqChar# :: Char# -> Char# -> Int#
  eqFloat# :: Float# -> Float# -> Int#
  eqInt16# :: Int16# -> Int16# -> Int#
  eqInt32# :: Int32# -> Int32# -> Int#
  eqInt64# :: Int64# -> Int64# -> Int#
  eqInt8# :: Int8# -> Int8# -> Int#
  eqStableName# :: StableName# a -> StableName# b -> Int#
  eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
  eqWord# :: Word# -> Word# -> Int#
  eqWord16# :: Word16# -> Word16# -> Int#
  eqWord32# :: Word32# -> Word32# -> Int#
  eqWord64# :: Word64# -> Word64# -> Int#
  eqWord8# :: Word8# -> Word8# -> Int#
  expDouble# :: Double# -> Double#
  expFloat# :: Float# -> Float#
  expm1Double# :: Double# -> Double#
  expm1Float# :: Float# -> Float#
  fabsDouble# :: Double# -> Double#
  fabsFloat# :: Float# -> Float#
  fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)
  finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
  float2Double# :: Float# -> Double#
  float2Int# :: Float# -> Int#
  fork# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  freezeArray# :: MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)
  freezeSmallArray# :: SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
  fromList :: IsList l => [Item l] -> l
  fromListN :: IsList l => Int -> [Item l] -> l
  fromString :: IsString a => GHC.Base.String -> a
  geAddr# :: Addr# -> Addr# -> Int#
  geChar# :: Char# -> Char# -> Int#
  geFloat# :: Float# -> Float# -> Int#
  geInt16# :: Int16# -> Int16# -> Int#
  geInt32# :: Int32# -> Int32# -> Int#
  geInt64# :: Int64# -> Int64# -> Int#
  geInt8# :: Int8# -> Int8# -> Int#
  geWord# :: Word# -> Word# -> Int#
  geWord16# :: Word16# -> Word16# -> Int#
  geWord32# :: Word32# -> Word32# -> Int#
  geWord64# :: Word64# -> Word64# -> Int#
  geWord8# :: Word8# -> Word8# -> Int#
  getApStackVal# :: a -> Int# -> (# Int#, b #)
  getCCSOf# :: a -> State# d -> (# State# d, Addr# #)
  getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)
  getDown :: Down a -> a
  getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
  getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)
  getSizeofSmallMutableArray# :: SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
  getSpark# :: State# d -> (# State# d, Int#, a #)
  getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)
  groupWith :: GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
  gtAddr# :: Addr# -> Addr# -> Int#
  gtChar# :: Char# -> Char# -> Int#
  gtFloat# :: Float# -> Float# -> Int#
  gtInt16# :: Int16# -> Int16# -> Int#
  gtInt32# :: Int32# -> Int32# -> Int#
  gtInt64# :: Int64# -> Int64# -> Int#
  gtInt8# :: Int8# -> Int8# -> Int#
  gtWord# :: Word# -> Word# -> Int#
  gtWord16# :: Word16# -> Word16# -> Int#
  gtWord32# :: Word32# -> Word32# -> Int#
  gtWord64# :: Word64# -> Word64# -> Int#
  gtWord8# :: Word8# -> Word8# -> Int#
  iShiftL# :: Int# -> Int# -> Int#
  iShiftRA# :: Int# -> Int# -> Int#
  iShiftRL# :: Int# -> Int# -> Int#
  indexAddrArray# :: ByteArray# -> Int# -> Addr#
  indexAddrOffAddr# :: Addr# -> Int# -> Addr#
  indexArray# :: Array# a -> Int# -> (# a #)
  indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
  indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
  indexCharArray# :: ByteArray# -> Int# -> Char#
  indexCharOffAddr# :: Addr# -> Int# -> Char#
  indexDoubleArray# :: ByteArray# -> Int# -> Double#
  indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleOffAddr# :: Addr# -> Int# -> Double#
  indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
  indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
  indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
  indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
  indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
  indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
  indexFloatArray# :: ByteArray# -> Int# -> Float#
  indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
  indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
  indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
  indexFloatOffAddr# :: Addr# -> Int# -> Float#
  indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
  indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
  indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
  indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
  indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
  indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
  indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
  indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
  indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
  indexInt16Array# :: ByteArray# -> Int# -> Int16#
  indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
  indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
  indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
  indexInt16OffAddr# :: Addr# -> Int# -> Int16#
  indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
  indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
  indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
  indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
  indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
  indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
  indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
  indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
  indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
  indexInt32Array# :: ByteArray# -> Int# -> Int32#
  indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
  indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
  indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
  indexInt32OffAddr# :: Addr# -> Int# -> Int32#
  indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
  indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
  indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
  indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
  indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
  indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
  indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
  indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
  indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
  indexInt64Array# :: ByteArray# -> Int# -> Int64#
  indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
  indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
  indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
  indexInt64OffAddr# :: Addr# -> Int# -> Int64#
  indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
  indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
  indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
  indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
  indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
  indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
  indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
  indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
  indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
  indexInt8Array# :: ByteArray# -> Int# -> Int8#
  indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
  indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
  indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
  indexInt8OffAddr# :: Addr# -> Int# -> Int8#
  indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
  indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
  indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
  indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
  indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
  indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
  indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
  indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
  indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
  indexIntArray# :: ByteArray# -> Int# -> Int#
  indexIntOffAddr# :: Addr# -> Int# -> Int#
  indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
  indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
  indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
  indexWideCharArray# :: ByteArray# -> Int# -> Char#
  indexWideCharOffAddr# :: Addr# -> Int# -> Char#
  indexWord16Array# :: ByteArray# -> Int# -> Word16#
  indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
  indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
  indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
  indexWord16OffAddr# :: Addr# -> Int# -> Word16#
  indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
  indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
  indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
  indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
  indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
  indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
  indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
  indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
  indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
  indexWord32Array# :: ByteArray# -> Int# -> Word32#
  indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
  indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
  indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
  indexWord32OffAddr# :: Addr# -> Int# -> Word32#
  indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
  indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
  indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
  indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
  indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
  indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
  indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
  indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
  indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
  indexWord64Array# :: ByteArray# -> Int# -> Word64#
  indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
  indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
  indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
  indexWord64OffAddr# :: Addr# -> Int# -> Word64#
  indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
  indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
  indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
  indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
  indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
  indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
  indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
  indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
  indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
  indexWord8Array# :: ByteArray# -> Int# -> Word8#
  indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
  indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
  indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
  indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
  indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
  indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
  indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
  indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
  indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
  indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
  indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
  indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
  indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
  indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
  indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
  indexWord8OffAddr# :: Addr# -> Int# -> Word8#
  indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
  indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
  indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
  indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
  indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
  indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
  indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
  indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
  indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
  indexWordArray# :: ByteArray# -> Int# -> Word#
  indexWordOffAddr# :: Addr# -> Int# -> Word#
  inline :: a -> a
  insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
  insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
  insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
  insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
  insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
  insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
  insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#
  insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#
  insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#
  insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#
  insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#
  insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#
  insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#
  insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#
  insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#
  insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#
  insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#
  insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#
  insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#
  insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#
  insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#
  insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#
  insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#
  insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#
  insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#
  insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#
  insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#
  insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#
  insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#
  insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
  int16ToInt# :: Int16# -> Int#
  int16ToWord16# :: Int16# -> Word16#
  int2Addr# :: Int# -> Addr#
  int2Double# :: Int# -> Double#
  int2Float# :: Int# -> Float#
  int2Word# :: Int# -> Word#
  int32ToInt# :: Int32# -> Int#
  int32ToWord32# :: Int32# -> Word32#
  int64ToInt# :: Int64# -> Int#
  int64ToWord64# :: Int64# -> Word64#
  int8ToInt# :: Int8# -> Int#
  int8ToWord8# :: Int8# -> Word8#
  intToInt16# :: Int# -> Int16#
  intToInt32# :: Int# -> Int32#
  intToInt64# :: Int# -> Int64#
  intToInt8# :: Int# -> Int8#
  isByteArrayPinned# :: ByteArray# -> Int#
  isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
  isEmptyMVar# :: MVar# d a -> State# d -> (# State# d, Int# #)
  isMutableByteArrayPinned# :: MutableByteArray# d -> Int#
  isTrue# :: Int# -> Bool
  keepAlive# :: a -> State# RealWorld -> (State# RealWorld -> b) -> b
  killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
  labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
  lazy :: a -> a
  leAddr# :: Addr# -> Addr# -> Int#
  leChar# :: Char# -> Char# -> Int#
  leFloat# :: Float# -> Float# -> Int#
  leInt16# :: Int16# -> Int16# -> Int#
  leInt32# :: Int32# -> Int32# -> Int#
  leInt64# :: Int64# -> Int64# -> Int#
  leInt8# :: Int8# -> Int8# -> Int#
  leWord# :: Word# -> Word# -> Int#
  leWord16# :: Word16# -> Word16# -> Int#
  leWord32# :: Word32# -> Word32# -> Int#
  leWord64# :: Word64# -> Word64# -> Int#
  leWord8# :: Word8# -> Word8# -> Int#
  leftSection :: (a -> b) -> a -> b
  listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
  log1pDouble# :: Double# -> Double#
  log1pFloat# :: Float# -> Float#
  logDouble# :: Double# -> Double#
  logFloat# :: Float# -> Float#
  ltAddr# :: Addr# -> Addr# -> Int#
  ltChar# :: Char# -> Char# -> Int#
  ltFloat# :: Float# -> Float# -> Int#
  ltInt16# :: Int16# -> Int16# -> Int#
  ltInt32# :: Int32# -> Int32# -> Int#
  ltInt64# :: Int64# -> Int64# -> Int#
  ltInt8# :: Int8# -> Int8# -> Int#
  ltWord# :: Word# -> Word# -> Int#
  ltWord16# :: Word16# -> Word16# -> Int#
  ltWord32# :: Word32# -> Word32# -> Int#
  ltWord64# :: Word64# -> Word64# -> Int#
  ltWord8# :: Word8# -> Word8# -> Int#
  makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
  makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
  maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maxTupleSize :: Int
  minusAddr# :: Addr# -> Addr# -> Int#
  minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  minusFloat# :: Float# -> Float# -> Float#
  minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  minusWord# :: Word# -> Word# -> Word#
  minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  mkApUpd0# :: BCO -> (# a #)
  mkWeak# :: a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mkWeakNoFinalizer# :: a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mulIntMayOflo# :: Int# -> Int# -> Int#
  mutableByteArrayContents# :: MutableByteArray# d -> Addr#
  myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
  narrow16Int# :: Int# -> Int#
  narrow16Word# :: Word# -> Word#
  narrow32Int# :: Int# -> Int#
  narrow32Word# :: Word# -> Word#
  narrow8Int# :: Int# -> Int#
  narrow8Word# :: Word# -> Word#
  neAddr# :: Addr# -> Addr# -> Int#
  neChar# :: Char# -> Char# -> Int#
  neFloat# :: Float# -> Float# -> Int#
  neInt16# :: Int16# -> Int16# -> Int#
  neInt32# :: Int32# -> Int32# -> Int#
  neInt64# :: Int64# -> Int64# -> Int#
  neInt8# :: Int8# -> Int8# -> Int#
  neWord# :: Word# -> Word# -> Int#
  neWord16# :: Word16# -> Word16# -> Int#
  neWord32# :: Word32# -> Word32# -> Int#
  neWord64# :: Word64# -> Word64# -> Int#
  neWord8# :: Word8# -> Word8# -> Int#
  negateDouble# :: Double# -> Double#
  negateDoubleX2# :: DoubleX2# -> DoubleX2#
  negateDoubleX4# :: DoubleX4# -> DoubleX4#
  negateDoubleX8# :: DoubleX8# -> DoubleX8#
  negateFloat# :: Float# -> Float#
  negateFloatX16# :: FloatX16# -> FloatX16#
  negateFloatX4# :: FloatX4# -> FloatX4#
  negateFloatX8# :: FloatX8# -> FloatX8#
  negateInt# :: Int# -> Int#
  negateInt16# :: Int16# -> Int16#
  negateInt16X16# :: Int16X16# -> Int16X16#
  negateInt16X32# :: Int16X32# -> Int16X32#
  negateInt16X8# :: Int16X8# -> Int16X8#
  negateInt32# :: Int32# -> Int32#
  negateInt32X16# :: Int32X16# -> Int32X16#
  negateInt32X4# :: Int32X4# -> Int32X4#
  negateInt32X8# :: Int32X8# -> Int32X8#
  negateInt64# :: Int64# -> Int64#
  negateInt64X2# :: Int64X2# -> Int64X2#
  negateInt64X4# :: Int64X4# -> Int64X4#
  negateInt64X8# :: Int64X8# -> Int64X8#
  negateInt8# :: Int8# -> Int8#
  negateInt8X16# :: Int8X16# -> Int8X16#
  negateInt8X32# :: Int8X32# -> Int8X32#
  negateInt8X64# :: Int8X64# -> Int8X64#
  newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newArray# :: Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
  newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
  newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)
  newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newIOPort# :: State# d -> (# State# d, IOPort# d a #)
  newMVar# :: State# d -> (# State# d, MVar# d a #)
  newMutVar# :: a -> State# d -> (# State# d, MutVar# d a #)
  newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)
  newSmallArray# :: Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
  newTVar# :: a -> State# d -> (# State# d, TVar# d a #)
  noDuplicate# :: State# d -> State# d
  noinline :: a -> a
  not# :: Word# -> Word#
  not64# :: Word64# -> Word64#
  notI# :: Int# -> Int#
  notWord16# :: Word16# -> Word16#
  notWord32# :: Word32# -> Word32#
  notWord8# :: Word8# -> Word8#
  nullAddr# :: Addr#
  numSparks# :: State# d -> (# State# d, Int# #)
  oneShot :: (a -> b) -> a -> b
  or# :: Word# -> Word# -> Word#
  or64# :: Word64# -> Word64# -> Word64#
  orI# :: Int# -> Int# -> Int#
  orWord16# :: Word16# -> Word16# -> Word16#
  orWord32# :: Word32# -> Word32# -> Word32#
  orWord8# :: Word8# -> Word8# -> Word8#
  ord# :: Char# -> Int#
  packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#
  packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#
  packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#
  packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#
  packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#
  packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#
  packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#
  packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#
  packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#
  packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#
  packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#
  packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#
  packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#
  packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#
  packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#
  packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#
  packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#
  packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#
  packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#
  packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#
  packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#
  packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#
  packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#
  packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#
  packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#
  packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#
  packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#
  packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#
  packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#
  packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#
  par# :: a -> Int#
  pdep# :: Word# -> Word# -> Word#
  pdep16# :: Word# -> Word# -> Word#
  pdep32# :: Word# -> Word# -> Word#
  pdep64# :: Word64# -> Word64# -> Word64#
  pdep8# :: Word# -> Word# -> Word#
  pext# :: Word# -> Word# -> Word#
  pext16# :: Word# -> Word# -> Word#
  pext32# :: Word# -> Word# -> Word#
  pext64# :: Word64# -> Word64# -> Word64#
  pext8# :: Word# -> Word# -> Word#
  plusAddr# :: Addr# -> Int# -> Addr#
  plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  plusFloat# :: Float# -> Float# -> Float#
  plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  plusInt16# :: Int16# -> Int16# -> Int16#
  plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  plusInt32# :: Int32# -> Int32# -> Int32#
  plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  plusInt64# :: Int64# -> Int64# -> Int64#
  plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  plusInt8# :: Int8# -> Int8# -> Int8#
  plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  plusWord# :: Word# -> Word# -> Word#
  plusWord16# :: Word16# -> Word16# -> Word16#
  plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
  plusWord32# :: Word32# -> Word32# -> Word32#
  plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  plusWord64# :: Word64# -> Word64# -> Word64#
  plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  plusWord8# :: Word8# -> Word8# -> Word8#
  plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  popCnt# :: Word# -> Word#
  popCnt16# :: Word# -> Word#
  popCnt32# :: Word# -> Word#
  popCnt64# :: Word64# -> Word#
  popCnt8# :: Word# -> Word#
  powerFloat# :: Float# -> Float# -> Float#
  prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
  prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
  prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d
  prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchValue0# :: a -> State# d -> State# d
  prefetchValue1# :: a -> State# d -> State# d
  prefetchValue2# :: a -> State# d -> State# d
  prefetchValue3# :: a -> State# d -> State# d
  prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  proxy# :: forall {k} (a :: k). Proxy# a
  putMVar# :: MVar# d a -> a -> State# d -> State# d
  quotInt# :: Int# -> Int# -> Int#
  quotInt16# :: Int16# -> Int16# -> Int16#
  quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  quotInt32# :: Int32# -> Int32# -> Int32#
  quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  quotInt64# :: Int64# -> Int64# -> Int64#
  quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  quotInt8# :: Int8# -> Int8# -> Int8#
  quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
  quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
  quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
  quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
  quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
  quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
  quotWord# :: Word# -> Word# -> Word#
  quotWord16# :: Word16# -> Word16# -> Word16#
  quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  quotWord32# :: Word32# -> Word32# -> Word32#
  quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  quotWord64# :: Word64# -> Word64# -> Word64#
  quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  quotWord8# :: Word8# -> Word8# -> Word8#
  quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  raise# :: a -> b
  raiseDivZero# :: (# #) -> b
  raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
  raiseOverflow# :: (# #) -> b
  raiseUnderflow# :: (# #) -> b
  readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)
  readArray# :: MutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
  readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
  readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)
  readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readIOPort# :: IOPort# d a -> State# d -> (# State# d, a #)
  readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)
  readMVar# :: MVar# d a -> State# d -> (# State# d, a #)
  readMutVar# :: MutVar# d a -> State# d -> (# State# d, a #)
  readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
  readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
  readSmallArray# :: SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readTVar# :: TVar# d a -> State# d -> (# State# d, a #)
  readTVarIO# :: TVar# d a -> State# d -> (# State# d, a #)
  readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)
  realWorld# :: State# RealWorld
  reallyUnsafePtrEquality :: a -> a -> Int#
  reallyUnsafePtrEquality# :: a -> b -> Int#
  remAddr# :: Addr# -> Int# -> Int#
  remInt# :: Int# -> Int# -> Int#
  remInt16# :: Int16# -> Int16# -> Int16#
  remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  remInt32# :: Int32# -> Int32# -> Int32#
  remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  remInt64# :: Int64# -> Int64# -> Int64#
  remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  remInt8# :: Int8# -> Int8# -> Int8#
  remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  remWord# :: Word# -> Word# -> Word#
  remWord16# :: Word16# -> Word16# -> Word16#
  remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  remWord32# :: Word32# -> Word32# -> Word32#
  remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  remWord64# :: Word64# -> Word64# -> Word64#
  remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  remWord8# :: Word8# -> Word8# -> Word8#
  remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  resizeSmallMutableArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
  retry# :: State# RealWorld -> (# State# RealWorld, a #)
  rightSection :: (a -> b -> c) -> b -> a -> c
  runRW# :: (State# RealWorld -> o) -> o
  sameArray# :: Array# a -> Array# a -> Int#
  sameArrayArray# :: ArrayArray# -> ArrayArray# -> Int#
  sameByteArray# :: ByteArray# -> ByteArray# -> Int#
  sameIOPort# :: IOPort# s a -> IOPort# s a -> Int#
  sameMVar# :: MVar# s a -> MVar# s a -> Int#
  sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
  sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
  sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
  sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
  samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#
  sameSmallArray# :: SmallArray# a -> SmallArray# a -> Int#
  sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
  sameTVar# :: TVar# s a -> TVar# s a -> Int#
  seq :: a -> b -> b
  seq# :: a -> State# d -> (# State# d, a #)
  setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d
  setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
  shiftL# :: Word# -> Int# -> Word#
  shiftRL# :: Word# -> Int# -> Word#
  shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d
  shrinkSmallMutableArray# :: SmallMutableArray# d a -> Int# -> State# d -> State# d
  sinDouble# :: Double# -> Double#
  sinFloat# :: Float# -> Float#
  sinhDouble# :: Double# -> Double#
  sinhFloat# :: Float# -> Float#
  sizeofArray# :: Array# a -> Int#
  sizeofArrayArray# :: ArrayArray# -> Int#
  sizeofByteArray# :: ByteArray# -> Int#
  sizeofMutableArray# :: MutableArray# d a -> Int#
  sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
  sizeofMutableByteArray# :: MutableByteArray# d -> Int#
  sizeofSmallArray# :: SmallArray# a -> Int#
  sizeofSmallMutableArray# :: SmallMutableArray# d a -> Int#
  sortWith :: GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  spark# :: a -> State# d -> (# State# d, a #)
  sqrtDouble# :: Double# -> Double#
  sqrtFloat# :: Float# -> Float#
  stableNameToInt# :: StableName# a -> Int#
  subInt16# :: Int16# -> Int16# -> Int16#
  subInt32# :: Int32# -> Int32# -> Int32#
  subInt64# :: Int64# -> Int64# -> Int64#
  subInt8# :: Int8# -> Int8# -> Int8#
  subIntC# :: Int# -> Int# -> (# Int#, Int# #)
  subWord16# :: Word16# -> Word16# -> Word16#
  subWord32# :: Word32# -> Word32# -> Word32#
  subWord64# :: Word64# -> Word64# -> Word64#
  subWord8# :: Word8# -> Word8# -> Word8#
  subWordC# :: Word# -> Word# -> (# Word#, Int# #)
  tagToEnum# :: Int# -> a
  takeMVar# :: MVar# d a -> State# d -> (# State# d, a #)
  tanDouble# :: Double# -> Double#
  tanFloat# :: Float# -> Float#
  tanhDouble# :: Double# -> Double#
  tanhFloat# :: Float# -> Float#
  thawArray# :: Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  the :: GHC.Classes.Eq a => [a] -> a
  threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
  threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
  timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  timesFloat# :: Float# -> Float# -> Float#
  timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  timesInt16# :: Int16# -> Int16# -> Int16#
  timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
  timesInt32# :: Int32# -> Int32# -> Int32#
  timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  timesInt64# :: Int64# -> Int64# -> Int64#
  timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  timesInt8# :: Int8# -> Int8# -> Int8#
  timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  timesWord# :: Word# -> Word# -> Word#
  timesWord16# :: Word16# -> Word16# -> Word16#
  timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
  timesWord32# :: Word32# -> Word32# -> Word32#
  timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  timesWord64# :: Word64# -> Word64# -> Word64#
  timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  timesWord8# :: Word8# -> Word8# -> Word8#
  timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  toList :: IsList l => l -> [Item l]
  touch# :: a -> State# RealWorld -> State# RealWorld
  traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d
  traceEvent :: GHC.Base.String -> GHC.Types.IO ()
  traceEvent# :: Addr# -> State# d -> State# d
  traceMarker# :: Addr# -> State# d -> State# d
  tryPutMVar# :: MVar# d a -> a -> State# d -> (# State# d, Int# #)
  tryReadMVar# :: MVar# d a -> State# d -> (# State# d, Int#, a #)
  tryTakeMVar# :: MVar# d a -> State# d -> (# State# d, Int#, a #)
  uncheckedIShiftL# :: Int# -> Int# -> Int#
  uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRA# :: Int# -> Int# -> Int#
  uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRL# :: Int# -> Int# -> Int#
  uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
  uncheckedShiftL# :: Word# -> Int# -> Word#
  uncheckedShiftL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
  uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRL# :: Word# -> Int# -> Word#
  uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
  unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  unpackAppendCString# :: Addr# -> [Char] -> [Char]
  unpackCString# :: Addr# -> [Char]
  unpackCStringUtf8# :: Addr# -> [Char]
  unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
  unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)
  unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)
  unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)
  unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)
  unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
  unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)
  unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)
  unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)
  unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackNBytes# :: Addr# -> Int# -> [Char]
  unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)
  unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)
  unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)
  unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unsafeCoerce# :: a -> b
  unsafeFreezeArray# :: MutableArray# d a -> State# d -> (# State# d, Array# a #)
  unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
  unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
  unsafeFreezeSmallArray# :: SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)
  unsafePtrEquality# :: a -> b -> Int#
  unsafeThawArray# :: Array# a -> State# d -> (# State# d, MutableArray# d a #)
  unsafeThawSmallArray# :: SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)
  void# :: (# #)
  waitRead# :: Int# -> State# d -> State# d
  waitWrite# :: Int# -> State# d -> State# d
  whereFrom# :: a -> State# d -> (# State# d, Addr# #)
  withDict :: WithDict cls meth => meth -> (cls => r) -> r
  word16ToInt16# :: Word16# -> Int16#
  word16ToWord# :: Word16# -> Word#
  word2Double# :: Word# -> Double#
  word2Float# :: Word# -> Float#
  word2Int# :: Word# -> Int#
  word32ToInt32# :: Word32# -> Int32#
  word32ToWord# :: Word32# -> Word#
  word64ToInt64# :: Word64# -> Int64#
  word64ToWord# :: Word64# -> Word#
  word8ToInt8# :: Word8# -> Int8#
  word8ToWord# :: Word8# -> Word#
  wordToWord16# :: Word# -> Word16#
  wordToWord32# :: Word# -> Word32#
  wordToWord64# :: Word# -> Word64#
  wordToWord8# :: Word# -> Word8#
  writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d
  writeArray# :: MutableArray# d a -> Int# -> a -> State# d -> State# d
  writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
  writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
  writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d
  writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d
  writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeIOPort# :: IOPort# d a -> a -> State# d -> (# State# d, Int# #)
  writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d
  writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d
  writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d
  writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d
  writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d
  writeMutVar# :: MutVar# d a -> a -> State# d -> State# d
  writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
  writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
  writeSmallArray# :: SmallMutableArray# d a -> Int# -> a -> State# d -> State# d
  writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d
  writeTVar# :: TVar# d a -> a -> State# d -> State# d
  writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d
  writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d
  writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d
  writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d
  writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d
  writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d
  xor# :: Word# -> Word# -> Word#
  xor64# :: Word64# -> Word64# -> Word64#
  xorI# :: Int# -> Int# -> Int#
  xorWord16# :: Word16# -> Word16# -> Word16#
  xorWord32# :: Word32# -> Word32# -> Word32#
  xorWord8# :: Word8# -> Word8# -> Word8#
  yield# :: State# RealWorld -> State# RealWorld
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b

module GHC.Fingerprint where
  Fingerprint :: GHC.Word.Word64 -> GHC.Word.Word64 -> Fingerprint
  type Fingerprint :: *
  data Fingerprint = ...
  fingerprint0 :: Fingerprint
  fingerprintData :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO Fingerprint
  fingerprintFingerprints :: [Fingerprint] -> Fingerprint
  fingerprintString :: GHC.Base.String -> Fingerprint
  getFileHash :: GHC.IO.FilePath -> GHC.Types.IO Fingerprint

module GHC.Fingerprint.Type where
  Fingerprint :: GHC.Word.Word64 -> GHC.Word.Word64 -> Fingerprint
  type Fingerprint :: *
  data Fingerprint = ...

module GHC.Float where
  (**) :: Floating a => a -> a -> a
  D# :: Double# -> Double
  type Double :: *
  data Double = ...
  type Double# :: TYPE GHC.Types.DoubleRep
  data Double#
  F# :: Float# -> Float
  FFExponent :: FFFormat
  FFFixed :: FFFormat
  type FFFormat :: *
  data FFFormat = ...
  FFGeneric :: FFFormat
  type Float :: *
  data Float = ...
  type Float# :: TYPE GHC.Types.FloatRep
  data Float#
  type Floating :: * -> Constraint
  class GHC.Real.Fractional a => Floating a
    ...
  type RealFloat :: * -> Constraint
  class (GHC.Real.RealFrac a, Floating a) => RealFloat a
    ...
  acos :: Floating a => a -> a
  acosDouble :: Double -> Double
  acosFloat :: Float -> Float
  acosh :: Floating a => a -> a
  acoshDouble :: Double -> Double
  acoshFloat :: Float -> Float
  asin :: Floating a => a -> a
  asinDouble :: Double -> Double
  asinFloat :: Float -> Float
  asinh :: Floating a => a -> a
  asinhDouble :: Double -> Double
  asinhFloat :: Float -> Float
  atan :: Floating a => a -> a
  atan2 :: RealFloat a => a -> a -> a
  atanDouble :: Double -> Double
  atanFloat :: Float -> Float
  atanh :: Floating a => a -> a
  atanhDouble :: Double -> Double
  atanhFloat :: Float -> Float
  castDoubleToWord64 :: Double -> GHC.Word.Word64
  castFloatToWord32 :: Float -> GHC.Word.Word32
  castWord32ToFloat :: GHC.Word.Word32 -> Float
  castWord64ToDouble :: GHC.Word.Word64 -> Double
  ceilingDouble :: GHC.Real.Integral b => Double -> b
  ceilingFloat :: GHC.Real.Integral b => Float -> b
  clamp :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  cos :: Floating a => a -> a
  cosDouble :: Double -> Double
  cosFloat :: Float -> Float
  cosh :: Floating a => a -> a
  coshDouble :: Double -> Double
  coshFloat :: Float -> Float
  decodeFloat :: RealFloat a => a -> (GHC.Num.Integer.Integer, GHC.Types.Int)
  divideDouble :: Double -> Double -> Double
  divideFloat :: Float -> Float -> Float
  double2Float :: Double -> Float
  double2Int :: Double -> GHC.Types.Int
  encodeFloat :: RealFloat a => GHC.Num.Integer.Integer -> GHC.Types.Int -> a
  eqDouble :: Double -> Double -> GHC.Types.Bool
  eqFloat :: Float -> Float -> GHC.Types.Bool
  exp :: Floating a => a -> a
  expDouble :: Double -> Double
  expFloat :: Float -> Float
  expm1 :: Floating a => a -> a
  expm1Double :: Double -> Double
  expm1Float :: Float -> Float
  exponent :: RealFloat a => a -> GHC.Types.Int
  expt :: GHC.Num.Integer.Integer -> GHC.Types.Int -> GHC.Num.Integer.Integer
  expts :: GHC.Arr.Array GHC.Types.Int GHC.Num.Integer.Integer
  expts10 :: GHC.Arr.Array GHC.Types.Int GHC.Num.Integer.Integer
  fabsDouble :: Double -> Double
  fabsFloat :: Float -> Float
  float2Double :: Float -> Double
  float2Int :: Float -> GHC.Types.Int
  floatDigits :: RealFloat a => a -> GHC.Types.Int
  floatRadix :: RealFloat a => a -> GHC.Num.Integer.Integer
  floatRange :: RealFloat a => a -> (GHC.Types.Int, GHC.Types.Int)
  floatToDigits :: RealFloat a => GHC.Num.Integer.Integer -> a -> ([GHC.Types.Int], GHC.Types.Int)
  floorDouble :: GHC.Real.Integral b => Double -> b
  floorFloat :: GHC.Real.Integral b => Float -> b
  formatRealFloat :: RealFloat a => FFFormat -> GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Base.String
  formatRealFloatAlt :: RealFloat a => FFFormat -> GHC.Maybe.Maybe GHC.Types.Int -> GHC.Types.Bool -> a -> GHC.Base.String
  fromRat :: RealFloat a => GHC.Real.Rational -> a
  fromRat' :: RealFloat a => GHC.Real.Rational -> a
  fromRat'' :: RealFloat a => GHC.Types.Int -> GHC.Types.Int -> GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> a
  geDouble :: Double -> Double -> GHC.Types.Bool
  geFloat :: Float -> Float -> GHC.Types.Bool
  gtDouble :: Double -> Double -> GHC.Types.Bool
  gtFloat :: Float -> Float -> GHC.Types.Bool
  int2Double :: GHC.Types.Int -> Double
  int2Float :: GHC.Types.Int -> Float
  integerToBinaryFloat' :: RealFloat a => GHC.Num.Integer.Integer -> a
  integerToDouble# :: GHC.Num.Integer.Integer -> Double#
  integerToFloat# :: GHC.Num.Integer.Integer -> Float#
  isDenormalized :: RealFloat a => a -> GHC.Types.Bool
  isDoubleDenormalized :: Double -> GHC.Types.Int
  isDoubleFinite :: Double -> GHC.Types.Int
  isDoubleInfinite :: Double -> GHC.Types.Int
  isDoubleNaN :: Double -> GHC.Types.Int
  isDoubleNegativeZero :: Double -> GHC.Types.Int
  isFloatDenormalized :: Float -> GHC.Types.Int
  isFloatFinite :: Float -> GHC.Types.Int
  isFloatInfinite :: Float -> GHC.Types.Int
  isFloatNaN :: Float -> GHC.Types.Int
  isFloatNegativeZero :: Float -> GHC.Types.Int
  isIEEE :: RealFloat a => a -> GHC.Types.Bool
  isInfinite :: RealFloat a => a -> GHC.Types.Bool
  isNaN :: RealFloat a => a -> GHC.Types.Bool
  isNegativeZero :: RealFloat a => a -> GHC.Types.Bool
  leDouble :: Double -> Double -> GHC.Types.Bool
  leFloat :: Float -> Float -> GHC.Types.Bool
  log :: Floating a => a -> a
  log1mexp :: Floating a => a -> a
  log1mexpOrd :: (GHC.Classes.Ord a, Floating a) => a -> a
  log1p :: Floating a => a -> a
  log1pDouble :: Double -> Double
  log1pFloat :: Float -> Float
  log1pexp :: Floating a => a -> a
  logBase :: Floating a => a -> a -> a
  logDouble :: Double -> Double
  logFloat :: Float -> Float
  ltDouble :: Double -> Double -> GHC.Types.Bool
  ltFloat :: Float -> Float -> GHC.Types.Bool
  maxExpt :: GHC.Types.Int
  maxExpt10 :: GHC.Types.Int
  minExpt :: GHC.Types.Int
  minusDouble :: Double -> Double -> Double
  minusFloat :: Float -> Float -> Float
  naturalToDouble# :: GHC.Num.Natural.Natural -> Double#
  naturalToFloat# :: GHC.Num.Natural.Natural -> Float#
  negateDouble :: Double -> Double
  negateFloat :: Float -> Float
  pi :: Floating a => a
  plusDouble :: Double -> Double -> Double
  plusFloat :: Float -> Float -> Float
  powerDouble :: Double -> Double -> Double
  powerFloat :: Float -> Float -> Float
  properFractionDouble :: GHC.Real.Integral b => Double -> (b, Double)
  properFractionFloat :: GHC.Real.Integral b => Float -> (b, Float)
  rationalToDouble :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> Double
  rationalToFloat :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> Float
  roundDouble :: GHC.Real.Integral b => Double -> b
  roundFloat :: GHC.Real.Integral b => Float -> b
  roundTo :: GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Int] -> (GHC.Types.Int, [GHC.Types.Int])
  roundingMode# :: GHC.Num.Integer.Integer -> GHC.Prim.Int# -> GHC.Prim.Int#
  scaleFloat :: RealFloat a => GHC.Types.Int -> a -> a
  showFloat :: RealFloat a => a -> GHC.Show.ShowS
  showSignedFloat :: RealFloat a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
  significand :: RealFloat a => a -> a
  sin :: Floating a => a -> a
  sinDouble :: Double -> Double
  sinFloat :: Float -> Float
  sinh :: Floating a => a -> a
  sinhDouble :: Double -> Double
  sinhFloat :: Float -> Float
  sqrt :: Floating a => a -> a
  sqrtDouble :: Double -> Double
  sqrtFloat :: Float -> Float
  stgDoubleToWord64 :: Double# -> GHC.Prim.Word64#
  stgFloatToWord32 :: Float# -> GHC.Prim.Word32#
  stgWord32ToFloat :: GHC.Prim.Word32# -> Float#
  stgWord64ToDouble :: GHC.Prim.Word64# -> Double#
  tan :: Floating a => a -> a
  tanDouble :: Double -> Double
  tanFloat :: Float -> Float
  tanh :: Floating a => a -> a
  tanhDouble :: Double -> Double
  tanhFloat :: Float -> Float
  timesDouble :: Double -> Double -> Double
  timesFloat :: Float -> Float -> Float
  truncateDouble :: GHC.Real.Integral b => Double -> b
  truncateFloat :: GHC.Real.Integral b => Float -> b
  word2Double :: GHC.Types.Word -> Double
  word2Float :: GHC.Types.Word -> Float

module GHC.Float.ConversionUtils where
  elimZerosInt# :: GHC.Prim.Int# -> GHC.Prim.Int# -> (# GHC.Num.Integer.Integer, GHC.Prim.Int# #)
  elimZerosInteger :: GHC.Num.Integer.Integer -> GHC.Prim.Int# -> (# GHC.Num.Integer.Integer, GHC.Prim.Int# #)

module GHC.Float.RealFracMethods where
  ceilingDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  ceilingDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  ceilingFloatInt :: GHC.Types.Float -> GHC.Types.Int
  ceilingFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  double2Int :: GHC.Types.Double -> GHC.Types.Int
  float2Int :: GHC.Types.Float -> GHC.Types.Int
  floorDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  floorDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  floorFloatInt :: GHC.Types.Float -> GHC.Types.Int
  floorFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  int2Double :: GHC.Types.Int -> GHC.Types.Double
  int2Float :: GHC.Types.Int -> GHC.Types.Float
  properFractionDoubleInt :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
  properFractionDoubleInteger :: GHC.Types.Double -> (GHC.Num.Integer.Integer, GHC.Types.Double)
  properFractionFloatInt :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
  properFractionFloatInteger :: GHC.Types.Float -> (GHC.Num.Integer.Integer, GHC.Types.Float)
  roundDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  roundDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  roundFloatInt :: GHC.Types.Float -> GHC.Types.Int
  roundFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  truncateDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  truncateFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer

module GHC.Foreign where
  type CString :: *
  type CString = GHC.Ptr.Ptr Foreign.C.Types.CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CChar, GHC.Types.Int)
  charIsRepresentable :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  newCString :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> GHC.Types.IO CStringLen
  peekCString :: GHC.IO.Encoding.Types.TextEncoding -> CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: GHC.IO.Encoding.Types.TextEncoding -> CStringLen -> GHC.Types.IO GHC.Base.String
  withCString :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringsLen :: GHC.IO.Encoding.Types.TextEncoding -> [GHC.Base.String] -> (GHC.Types.Int -> GHC.Ptr.Ptr CString -> GHC.Types.IO a) -> GHC.Types.IO a

module GHC.ForeignPtr where
  CFinalizers :: GHC.Prim.Weak# () -> Finalizers
  FinalPtr :: ForeignPtrContents
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type Finalizers :: *
  data Finalizers = ...
  ForeignPtr :: GHC.Prim.Addr# -> ForeignPtrContents -> ForeignPtr a
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  type ForeignPtrContents :: *
  data ForeignPtrContents = ...
  HaskellFinalizers :: [GHC.Types.IO ()] -> Finalizers
  MallocPtr :: GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> GHC.IORef.IORef Finalizers -> ForeignPtrContents
  NoFinalizers :: Finalizers
  PlainForeignPtr :: GHC.IORef.IORef Finalizers -> ForeignPtrContents
  PlainPtr :: GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> ForeignPtrContents
  addForeignPtrConcFinalizer :: ForeignPtr a -> GHC.Types.IO () -> GHC.Types.IO ()
  addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrAlignedBytes :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtr :: Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtrAlignedBytes :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtrBytes :: GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newConcForeignPtr :: GHC.Ptr.Ptr a -> GHC.Types.IO () -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  plusForeignPtr :: ForeignPtr a -> GHC.Types.Int -> ForeignPtr b
  touchForeignPtr :: ForeignPtr a -> GHC.Types.IO ()
  unsafeForeignPtrToPtr :: ForeignPtr a -> GHC.Ptr.Ptr a
  unsafeWithForeignPtr :: ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module GHC.GHCi where
  type GHCiSandboxIO :: (* -> *) -> Constraint
  class GHC.Base.Monad m => GHCiSandboxIO m
    ...
  type NoIO :: * -> *
  newtype NoIO a = ...
  ghciStepIO :: GHCiSandboxIO m => m a -> GHC.Types.IO a

module GHC.GHCi.Helpers where
  disableBuffering :: GHC.Types.IO ()
  evalWrapper :: GHC.Base.String -> [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  flushAll :: GHC.Types.IO ()

module GHC.Generics where
  (:*:) :: forall k (f :: k -> *) (g :: k -> *) (p :: k). f p -> g p -> (:*:) f g p
  type role (:*:) representational representational nominal
  type (:*:) :: forall k. (k -> *) -> (k -> *) -> k -> *
  data (:*:) f g p = ...
  type role (:+:) representational representational nominal
  type (:+:) :: forall k. (k -> *) -> (k -> *) -> k -> *
  data (:+:) f g p = ...
  type role (:.:) representational nominal nominal
  type (:.:) :: forall k2 k1. (k2 -> *) -> (k1 -> k2) -> k1 -> *
  newtype (:.:) f g p = ...
  type Associativity :: *
  data Associativity = ...
  type C :: *
  data C
  type C1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type C1 = M1 C :: Meta -> (k -> *) -> k -> *
  Comp1 :: forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). f (g p) -> (:.:) f g p
  type Constructor :: forall {k}. k -> Constraint
  class Constructor c
    ...
  type D :: *
  data D
  type D1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type D1 = M1 D :: Meta -> (k -> *) -> k -> *
  type Datatype :: forall {k}. k -> Constraint
  class Datatype d
    ...
  DecidedLazy :: DecidedStrictness
  DecidedStrict :: DecidedStrictness
  type DecidedStrictness :: *
  data DecidedStrictness = ...
  DecidedUnpack :: DecidedStrictness
  type Fixity :: *
  data Fixity = ...
  type FixityI :: *
  data FixityI = ...
  type Generic :: * -> Constraint
  class Generic a
    ...
    ...
  type Generic1 :: forall k. (k -> *) -> Constraint
  class Generic1 f
    ...
    ...
  Generically :: a -> Generically a
  type Generically :: * -> *
  newtype Generically a = ...
  Generically1 :: forall {k} (f :: k -> *) (a :: k). f a -> Generically1 f a
  type role Generically1 representational nominal
  type Generically1 :: forall k. (k -> *) -> k -> *
  newtype Generically1 f a where
    ...
  Infix :: Associativity -> GHC.Types.Int -> Fixity
  InfixI :: Associativity -> GHC.TypeNats.Nat -> FixityI
  K1 :: forall k i c (p :: k). c -> K1 i c p
  type role K1 phantom representational phantom
  type K1 :: forall k. * -> * -> k -> *
  newtype K1 i c p = ...
  L1 :: forall k (f :: k -> *) (g :: k -> *) (p :: k). f p -> (:+:) f g p
  LeftAssociative :: Associativity
  M1 :: forall k i (c :: Meta) (f :: k -> *) (p :: k). f p -> M1 i c f p
  type role M1 phantom phantom representational nominal
  type M1 :: forall k. * -> Meta -> (k -> *) -> k -> *
  newtype M1 i c f p = ...
  type Meta :: *
  data Meta = ...
  MetaCons :: GHC.Types.Symbol -> FixityI -> GHC.Types.Bool -> Meta
  MetaData :: GHC.Types.Symbol -> GHC.Types.Symbol -> GHC.Types.Symbol -> GHC.Types.Bool -> Meta
  MetaSel :: GHC.Maybe.Maybe GHC.Types.Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta
  NoSourceStrictness :: SourceStrictness
  NoSourceUnpackedness :: SourceUnpackedness
  NotAssociative :: Associativity
  Par1 :: p -> Par1 p
  type Par1 :: * -> *
  newtype Par1 p = ...
  Prefix :: Fixity
  PrefixI :: FixityI
  type R :: *
  data R
  R1 :: forall k (f :: k -> *) (g :: k -> *) (p :: k). g p -> (:+:) f g p
  type Rec0 :: forall {k}. * -> k -> *
  type Rec0 = K1 R :: * -> k -> *
  Rec1 :: forall k (f :: k -> *) (p :: k). f p -> Rec1 f p
  type role Rec1 representational nominal
  type Rec1 :: forall k. (k -> *) -> k -> *
  newtype Rec1 f p = ...
  type Rep :: * -> * -> *
  type family Rep a
  type Rep1 :: forall k. (k -> *) -> k -> *
  type family Rep1 f
  RightAssociative :: Associativity
  type S :: *
  data S
  type S1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type S1 = M1 S :: Meta -> (k -> *) -> k -> *
  type Selector :: forall {k}. k -> Constraint
  class Selector s
    ...
  SourceLazy :: SourceStrictness
  SourceNoUnpack :: SourceUnpackedness
  SourceStrict :: SourceStrictness
  type SourceStrictness :: *
  data SourceStrictness = ...
  SourceUnpack :: SourceUnpackedness
  type SourceUnpackedness :: *
  data SourceUnpackedness = ...
  U1 :: forall k (p :: k). U1 p
  type role U1 phantom
  type U1 :: forall k. k -> *
  data U1 p = ...
  UAddr :: forall k (p :: k). GHC.Prim.Addr# -> URec (GHC.Ptr.Ptr ()) p
  type UAddr :: forall {k}. k -> *
  type UAddr = URec (GHC.Ptr.Ptr ()) :: k -> *
  UChar :: forall k (p :: k). GHC.Prim.Char# -> URec GHC.Types.Char p
  type UChar :: forall {k}. k -> *
  type UChar = URec GHC.Types.Char :: k -> *
  UDouble :: forall k (p :: k). GHC.Prim.Double# -> URec GHC.Types.Double p
  type UDouble :: forall {k}. k -> *
  type UDouble = URec GHC.Types.Double :: k -> *
  UFloat :: forall k (p :: k). GHC.Prim.Float# -> URec GHC.Types.Float p
  type UFloat :: forall {k}. k -> *
  type UFloat = URec GHC.Types.Float :: k -> *
  UInt :: forall k (p :: k). GHC.Prim.Int# -> URec GHC.Types.Int p
  type UInt :: forall {k}. k -> *
  type UInt = URec GHC.Types.Int :: k -> *
  type URec :: forall k. * -> k -> *
  data family URec a p
  UWord :: forall k (p :: k). GHC.Prim.Word# -> URec GHC.Types.Word p
  type UWord :: forall {k}. k -> *
  type UWord = URec GHC.Types.Word :: k -> *
  type role V1 phantom
  type V1 :: forall k. k -> *
  data V1 p
  conFixity :: forall {k} (c :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Constructor c => t c f a -> Fixity
  conIsRecord :: forall {k} (c :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Constructor c => t c f a -> GHC.Types.Bool
  conName :: forall {k} (c :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Constructor c => t c f a -> [GHC.Types.Char]
  datatypeName :: forall {k} (d :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Datatype d => t d f a -> [GHC.Types.Char]
  from :: Generic a => a -> Rep a x
  from1 :: forall k (f :: k -> *) (a :: k). Generic1 f => f a -> Rep1 f a
  isNewtype :: forall {k} (d :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Datatype d => t d f a -> GHC.Types.Bool
  moduleName :: forall {k} (d :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Datatype d => t d f a -> [GHC.Types.Char]
  packageName :: forall {k} (d :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Datatype d => t d f a -> [GHC.Types.Char]
  prec :: Fixity -> GHC.Types.Int
  selDecidedStrictness :: forall {k} (s :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Selector s => t s f a -> DecidedStrictness
  selName :: forall {k} (s :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Selector s => t s f a -> [GHC.Types.Char]
  selSourceStrictness :: forall {k} (s :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Selector s => t s f a -> SourceStrictness
  selSourceUnpackedness :: forall {k} (s :: k) k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). Selector s => t s f a -> SourceUnpackedness
  to :: Generic a => Rep a x -> a
  to1 :: forall k (f :: k -> *) (a :: k). Generic1 f => Rep1 f a -> f a
  uAddr# :: forall k (p :: k). URec (GHC.Ptr.Ptr ()) p -> GHC.Prim.Addr#
  uChar# :: forall k (p :: k). URec GHC.Types.Char p -> GHC.Prim.Char#
  uDouble# :: forall k (p :: k). URec GHC.Types.Double p -> GHC.Prim.Double#
  uFloat# :: forall k (p :: k). URec GHC.Types.Float p -> GHC.Prim.Float#
  uInt# :: forall k (p :: k). URec GHC.Types.Int p -> GHC.Prim.Int#
  uWord# :: forall k (p :: k). URec GHC.Types.Word p -> GHC.Prim.Word#
  unComp1 :: forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). (:.:) f g p -> f (g p)
  unK1 :: forall k i c (p :: k). K1 i c p -> c
  unM1 :: forall k i (c :: Meta) (f :: k -> *) (p :: k). M1 i c f p -> f p
  unPar1 :: Par1 p -> p
  unRec1 :: forall k (f :: k -> *) (p :: k). Rec1 f p -> f p

module GHC.IO where
  type FilePath :: *
  type FilePath = GHC.Base.String
  IO :: (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> IO a
  type IO :: * -> *
  newtype IO a = ...
  MaskedInterruptible :: MaskingState
  MaskedUninterruptible :: MaskingState
  type MaskingState :: *
  data MaskingState = ...
  Unmasked :: MaskingState
  bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
  catch :: GHC.Exception.Type.Exception e => IO a -> (e -> IO a) -> IO a
  catchAny :: IO a -> (forall e. GHC.Exception.Type.Exception e => e -> IO a) -> IO a
  catchException :: GHC.Exception.Type.Exception e => IO a -> (e -> IO a) -> IO a
  evaluate :: a -> IO a
  finally :: IO a -> IO b -> IO a
  getMaskingState :: IO MaskingState
  interruptible :: IO a -> IO a
  ioToST :: IO a -> GHC.ST.ST GHC.Prim.RealWorld a
  liftIO :: IO a -> GHC.Prim.State# GHC.Prim.RealWorld -> GHC.ST.STret GHC.Prim.RealWorld a
  mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
  mask_ :: IO a -> IO a
  mkUserError :: [GHC.Types.Char] -> GHC.Exception.Type.SomeException
  mplusIO :: IO a -> IO a -> IO a
  noDuplicate :: IO ()
  onException :: IO a -> IO b -> IO a
  stToIO :: GHC.ST.ST GHC.Prim.RealWorld a -> IO a
  throwIO :: GHC.Exception.Type.Exception e => e -> IO a
  unIO :: IO a -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
  uninterruptibleMask_ :: IO a -> IO a
  unsafeDupableInterleaveIO :: IO a -> IO a
  unsafeDupablePerformIO :: IO a -> a
  unsafeIOToST :: IO a -> GHC.ST.ST s a
  unsafeInterleaveIO :: IO a -> IO a
  unsafePerformIO :: IO a -> a
  unsafeSTToIO :: GHC.ST.ST s a -> IO a
  unsafeUnmask :: IO a -> IO a

module GHC.IO.Buffer where
  Buffer :: RawBuffer e -> BufferState -> GHC.Types.Int -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.Int -> Buffer e
  type role Buffer phantom
  type Buffer :: * -> *
  data Buffer e = ...
  type BufferState :: *
  data BufferState = ...
  type CharBufElem :: *
  type CharBufElem = GHC.Types.Char
  type CharBuffer :: *
  type CharBuffer = Buffer GHC.Types.Char
  type RawBuffer :: * -> *
  type RawBuffer e = GHC.ForeignPtr.ForeignPtr e
  type RawCharBuffer :: *
  type RawCharBuffer = RawBuffer CharBufElem
  ReadBuffer :: BufferState
  WriteBuffer :: BufferState
  bufL :: Buffer e -> GHC.Types.Int
  bufOffset :: Buffer e -> GHC.Word.Word64
  bufR :: Buffer e -> GHC.Types.Int
  bufRaw :: Buffer e -> RawBuffer e
  bufSize :: Buffer e -> GHC.Types.Int
  bufState :: Buffer e -> BufferState
  bufferAdd :: GHC.Types.Int -> Buffer e -> Buffer e
  bufferAddOffset :: GHC.Types.Int -> Buffer e -> Buffer e
  bufferAdjustL :: GHC.Types.Int -> Buffer e -> Buffer e
  bufferAdjustOffset :: GHC.Word.Word64 -> Buffer e -> Buffer e
  bufferAvailable :: Buffer e -> GHC.Types.Int
  bufferElems :: Buffer e -> GHC.Types.Int
  bufferOffset :: Buffer e -> GHC.Word.Word64
  bufferRemove :: GHC.Types.Int -> Buffer e -> Buffer e
  charSize :: GHC.Types.Int
  checkBuffer :: Buffer a -> GHC.Types.IO ()
  emptyBuffer :: RawBuffer e -> GHC.Types.Int -> BufferState -> Buffer e
  isEmptyBuffer :: Buffer e -> GHC.Types.Bool
  isFullBuffer :: Buffer e -> GHC.Types.Bool
  isFullCharBuffer :: Buffer e -> GHC.Types.Bool
  isWriteBuffer :: Buffer e -> GHC.Types.Bool
  newBuffer :: GHC.Types.Int -> GHC.Types.Int -> BufferState -> GHC.Types.IO (Buffer e)
  newByteBuffer :: GHC.Types.Int -> BufferState -> GHC.Types.IO (Buffer GHC.Word.Word8)
  newCharBuffer :: GHC.Types.Int -> BufferState -> GHC.Types.IO CharBuffer
  peekCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Char
  readCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.IO (GHC.Types.Char, GHC.Types.Int)
  readCharBufPtr :: GHC.Ptr.Ptr CharBufElem -> GHC.Types.Int -> GHC.Types.IO (GHC.Types.Char, GHC.Types.Int)
  readWord8Buf :: RawBuffer GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word8
  slideContents :: Buffer GHC.Word.Word8 -> GHC.Types.IO (Buffer GHC.Word.Word8)
  summaryBuffer :: Buffer a -> GHC.Base.String
  withBuffer :: Buffer e -> (GHC.Ptr.Ptr e -> GHC.Types.IO a) -> GHC.Types.IO a
  withRawBuffer :: RawBuffer e -> (GHC.Ptr.Ptr e -> GHC.Types.IO a) -> GHC.Types.IO a
  writeCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Int
  writeCharBufPtr :: GHC.Ptr.Ptr CharBufElem -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Int
  writeWord8Buf :: RawBuffer GHC.Word.Word8 -> GHC.Types.Int -> GHC.Word.Word8 -> GHC.Types.IO ()

module GHC.IO.BufferedIO where
  type BufferedIO :: * -> Constraint
  class BufferedIO dev
    ...
  emptyWriteBuffer :: BufferedIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  fillReadBuffer :: BufferedIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  fillReadBuffer0 :: BufferedIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  flushWriteBuffer :: BufferedIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  flushWriteBuffer0 :: BufferedIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  newBuffer :: BufferedIO dev => dev -> GHC.IO.Buffer.BufferState -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  readBuf :: GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  readBufNonBlocking :: GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  writeBuf :: GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  writeBufNonBlocking :: GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)

module GHC.IO.Device where
  AbsoluteSeek :: SeekMode
  Directory :: IODeviceType
  type IODevice :: * -> Constraint
  class IODevice a
    ...
  type IODeviceType :: *
  data IODeviceType = ...
  RawDevice :: IODeviceType
  type RawIO :: * -> Constraint
  class RawIO a
    ...
  RegularFile :: IODeviceType
  RelativeSeek :: SeekMode
  SeekFromEnd :: SeekMode
  type SeekMode :: *
  data SeekMode = ...
  Stream :: IODeviceType
  close :: IODevice a => a -> GHC.Types.IO ()
  devType :: IODevice a => a -> GHC.Types.IO IODeviceType
  dup :: IODevice a => a -> GHC.Types.IO a
  dup2 :: IODevice a => a -> a -> GHC.Types.IO a
  getEcho :: IODevice a => a -> GHC.Types.IO GHC.Types.Bool
  getSize :: IODevice a => a -> GHC.Types.IO GHC.Num.Integer.Integer
  isSeekable :: IODevice a => a -> GHC.Types.IO GHC.Types.Bool
  isTerminal :: IODevice a => a -> GHC.Types.IO GHC.Types.Bool
  read :: RawIO a => a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  readNonBlocking :: RawIO a => a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int)
  ready :: IODevice a => a -> GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
  seek :: IODevice a => a -> SeekMode -> GHC.Num.Integer.Integer -> GHC.Types.IO GHC.Num.Integer.Integer
  setEcho :: IODevice a => a -> GHC.Types.Bool -> GHC.Types.IO ()
  setRaw :: IODevice a => a -> GHC.Types.Bool -> GHC.Types.IO ()
  setSize :: IODevice a => a -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
  tell :: IODevice a => a -> GHC.Types.IO GHC.Num.Integer.Integer
  write :: RawIO a => a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO ()
  writeNonBlocking :: RawIO a => a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int

module GHC.IO.Encoding where
  BufferCodec :: GHC.IO.Encoding.Types.CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = ...
  type CodingProgress :: *
  data CodingProgress = ...
  InputUnderflow :: CodingProgress
  InvalidSequence :: CodingProgress
  OutputUnderflow :: CodingProgress
  type TextDecoder :: * -> *
  type TextDecoder state = BufferCodec GHC.Word.Word8 GHC.IO.Buffer.CharBufElem state
  type TextEncoder :: * -> *
  type TextEncoder state = BufferCodec GHC.IO.Buffer.CharBufElem GHC.Word.Word8 state
  TextEncoding :: GHC.Base.String -> GHC.Types.IO (TextDecoder dstate) -> GHC.Types.IO (TextEncoder estate) -> TextEncoding
  type TextEncoding :: *
  data TextEncoding = ...
  argvEncoding :: GHC.Types.IO TextEncoding
  char8 :: TextEncoding
  close :: BufferCodec from to state -> GHC.Types.IO ()
  encode :: BufferCodec from to state -> GHC.IO.Encoding.Types.CodeBuffer from to
  getFileSystemEncoding :: GHC.Types.IO TextEncoding
  getForeignEncoding :: GHC.Types.IO TextEncoding
  getLocaleEncoding :: GHC.Types.IO TextEncoding
  getState :: BufferCodec from to state -> GHC.Types.IO state
  initLocaleEncoding :: TextEncoding
  latin1 :: TextEncoding
  latin1_decode :: GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8, GHC.IO.Buffer.CharBuffer)
  latin1_encode :: GHC.IO.Buffer.CharBuffer -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.CharBuffer, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  mkTextDecoder :: ()
  mkTextEncoder :: ()
  mkTextEncoding :: GHC.Base.String -> GHC.Types.IO TextEncoding
  recover :: BufferCodec from to state -> GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)
  setFileSystemEncoding :: TextEncoding -> GHC.Types.IO ()
  setForeignEncoding :: TextEncoding -> GHC.Types.IO ()
  setLocaleEncoding :: TextEncoding -> GHC.Types.IO ()
  setState :: BufferCodec from to state -> state -> GHC.Types.IO ()
  textEncodingName :: TextEncoding -> GHC.Base.String
  utf16 :: TextEncoding
  utf16be :: TextEncoding
  utf16le :: TextEncoding
  utf32 :: TextEncoding
  utf32be :: TextEncoding
  utf32le :: TextEncoding
  utf8 :: TextEncoding
  utf8_bom :: TextEncoding

module GHC.IO.Encoding.CodePage where


module GHC.IO.Encoding.Failure where
  type CodingFailureMode :: *
  data CodingFailureMode = ...
  ErrorOnCodingFailure :: CodingFailureMode
  IgnoreCodingFailure :: CodingFailureMode
  RoundtripFailure :: CodingFailureMode
  TransliterateCodingFailure :: CodingFailureMode
  codingFailureModeSuffix :: CodingFailureMode -> GHC.Base.String
  isSurrogate :: GHC.Types.Char -> GHC.Types.Bool
  recoverDecode :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8, GHC.IO.Buffer.Buffer GHC.Types.Char)
  recoverEncode :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Types.Char, GHC.IO.Buffer.Buffer GHC.Word.Word8)

module GHC.IO.Encoding.Iconv where
  iconvEncoding :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)
  localeEncodingName :: GHC.Base.String
  mkIconvEncoding :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)

module GHC.IO.Encoding.Latin1 where
  ascii :: GHC.IO.Encoding.Types.TextEncoding
  ascii_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  ascii_encode :: GHC.IO.Encoding.Types.EncodeBuffer
  latin1 :: GHC.IO.Encoding.Types.TextEncoding
  latin1_checked :: GHC.IO.Encoding.Types.TextEncoding
  latin1_checked_encode :: GHC.IO.Encoding.Types.EncodeBuffer
  latin1_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  latin1_encode :: GHC.IO.Encoding.Types.EncodeBuffer
  mkAscii :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkLatin1 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkLatin1_checked :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding

module GHC.IO.Encoding.Types where
  BufferCodec :: CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = ...
  type CodeBuffer :: * -> * -> *
  type CodeBuffer from to = GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (CodingProgress, GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)
  type CodingProgress :: *
  data CodingProgress = ...
  type DecodeBuffer :: *
  type DecodeBuffer = CodeBuffer GHC.Word.Word8 GHC.Types.Char
  type EncodeBuffer :: *
  type EncodeBuffer = CodeBuffer GHC.Types.Char GHC.Word.Word8
  InputUnderflow :: CodingProgress
  InvalidSequence :: CodingProgress
  OutputUnderflow :: CodingProgress
  type TextDecoder :: * -> *
  type TextDecoder state = BufferCodec GHC.Word.Word8 GHC.IO.Buffer.CharBufElem state
  type TextEncoder :: * -> *
  type TextEncoder state = BufferCodec GHC.IO.Buffer.CharBufElem GHC.Word.Word8 state
  TextEncoding :: GHC.Base.String -> GHC.Types.IO (TextDecoder dstate) -> GHC.Types.IO (TextEncoder estate) -> TextEncoding
  type TextEncoding :: *
  data TextEncoding = ...
  close :: BufferCodec from to state -> GHC.Types.IO ()
  encode :: BufferCodec from to state -> CodeBuffer from to
  getState :: BufferCodec from to state -> GHC.Types.IO state
  mkTextDecoder :: ()
  mkTextEncoder :: ()
  recover :: BufferCodec from to state -> GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)
  setState :: BufferCodec from to state -> state -> GHC.Types.IO ()
  textEncodingName :: TextEncoding -> GHC.Base.String

module GHC.IO.Encoding.UTF16 where
  mkUTF16 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF16be :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF16le :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf16 :: GHC.IO.Encoding.Types.TextEncoding
  utf16_decode :: GHC.IORef.IORef (GHC.Maybe.Maybe GHC.IO.Encoding.Types.DecodeBuffer) -> GHC.IO.Encoding.Types.DecodeBuffer
  utf16_encode :: GHC.IORef.IORef GHC.Types.Bool -> GHC.IO.Encoding.Types.EncodeBuffer
  utf16be :: GHC.IO.Encoding.Types.TextEncoding
  utf16be_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  utf16be_encode :: GHC.IO.Encoding.Types.EncodeBuffer
  utf16le :: GHC.IO.Encoding.Types.TextEncoding
  utf16le_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  utf16le_encode :: GHC.IO.Encoding.Types.EncodeBuffer

module GHC.IO.Encoding.UTF32 where
  mkUTF32 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF32be :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF32le :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf32 :: GHC.IO.Encoding.Types.TextEncoding
  utf32_decode :: GHC.IORef.IORef (GHC.Maybe.Maybe GHC.IO.Encoding.Types.DecodeBuffer) -> GHC.IO.Encoding.Types.DecodeBuffer
  utf32_encode :: GHC.IORef.IORef GHC.Types.Bool -> GHC.IO.Encoding.Types.EncodeBuffer
  utf32be :: GHC.IO.Encoding.Types.TextEncoding
  utf32be_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  utf32be_encode :: GHC.IO.Encoding.Types.EncodeBuffer
  utf32le :: GHC.IO.Encoding.Types.TextEncoding
  utf32le_decode :: GHC.IO.Encoding.Types.DecodeBuffer
  utf32le_encode :: GHC.IO.Encoding.Types.EncodeBuffer

module GHC.IO.Encoding.UTF8 where
  mkUTF8 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF8_bom :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf8 :: GHC.IO.Encoding.Types.TextEncoding
  utf8_bom :: GHC.IO.Encoding.Types.TextEncoding

module GHC.IO.Exception where
  AllocationLimitExceeded :: AllocationLimitExceeded
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = ...
  AlreadyExists :: IOErrorType
  type ArrayException :: *
  data ArrayException = ...
  AssertionFailed :: GHC.Base.String -> AssertionFailed
  type AssertionFailed :: *
  newtype AssertionFailed = ...
  type AsyncException :: *
  data AsyncException = ...
  BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = ...
  BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = ...
  CompactionFailed :: GHC.Base.String -> CompactionFailed
  type CompactionFailed :: *
  newtype CompactionFailed = ...
  Deadlock :: Deadlock
  type Deadlock :: *
  data Deadlock = ...
  EOF :: IOErrorType
  type ExitCode :: *
  data ExitCode = ...
  ExitFailure :: GHC.Types.Int -> ExitCode
  ExitSuccess :: ExitCode
  FixIOException :: FixIOException
  type FixIOException :: *
  data FixIOException = ...
  HardwareFault :: IOErrorType
  HeapOverflow :: AsyncException
  IOError :: GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> IOErrorType -> GHC.Base.String -> GHC.Base.String -> GHC.Maybe.Maybe Foreign.C.Types.CInt -> GHC.Maybe.Maybe GHC.IO.FilePath -> IOException
  type IOError :: *
  type IOError = IOException
  type IOErrorType :: *
  data IOErrorType = ...
  type IOException :: *
  data IOException = ...
  IllegalOperation :: IOErrorType
  InappropriateType :: IOErrorType
  IndexOutOfBounds :: GHC.Base.String -> ArrayException
  Interrupted :: IOErrorType
  InvalidArgument :: IOErrorType
  NoSuchThing :: IOErrorType
  OtherError :: IOErrorType
  PermissionDenied :: IOErrorType
  ProtocolError :: IOErrorType
  ResourceBusy :: IOErrorType
  ResourceExhausted :: IOErrorType
  ResourceVanished :: IOErrorType
  SomeAsyncException :: GHC.Exception.Type.Exception e => e -> SomeAsyncException
  type SomeAsyncException :: *
  data SomeAsyncException = ...
  StackOverflow :: AsyncException
  SystemError :: IOErrorType
  ThreadKilled :: AsyncException
  TimeExpired :: IOErrorType
  UndefinedElement :: GHC.Base.String -> ArrayException
  UnsatisfiedConstraints :: IOErrorType
  UnsupportedOperation :: IOErrorType
  UserError :: IOErrorType
  UserInterrupt :: AsyncException
  allocationLimitExceeded :: GHC.Exception.Type.SomeException
  assertError :: (?callStack::GHC.Stack.Types.CallStack) => GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: GHC.Exception.Type.Exception e => GHC.Exception.Type.SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: GHC.Exception.Type.Exception e => e -> GHC.Exception.Type.SomeException
  blockedIndefinitelyOnMVar :: GHC.Exception.Type.SomeException
  blockedIndefinitelyOnSTM :: GHC.Exception.Type.SomeException
  cannotCompactFunction :: GHC.Exception.Type.SomeException
  cannotCompactMutable :: GHC.Exception.Type.SomeException
  cannotCompactPinned :: GHC.Exception.Type.SomeException
  heapOverflow :: GHC.Exception.Type.SomeException
  ioError :: IOError -> GHC.Types.IO a
  ioException :: IOException -> GHC.Types.IO a
  ioe_description :: IOException -> GHC.Base.String
  ioe_errno :: IOException -> GHC.Maybe.Maybe Foreign.C.Types.CInt
  ioe_filename :: IOException -> GHC.Maybe.Maybe GHC.IO.FilePath
  ioe_handle :: IOException -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle
  ioe_location :: IOException -> GHC.Base.String
  ioe_type :: IOException -> IOErrorType
  stackOverflow :: GHC.Exception.Type.SomeException
  unsupportedOperation :: IOError
  untangle :: GHC.Prim.Addr# -> GHC.Base.String -> GHC.Base.String
  userError :: GHC.Base.String -> IOError

module GHC.IO.FD where
  FD :: Foreign.C.Types.CInt -> GHC.Types.Int -> FD
  type FD :: *
  data FD = ...
  fdFD :: FD -> Foreign.C.Types.CInt
  fdIsNonBlocking :: FD -> GHC.Types.Int
  mkFD :: Foreign.C.Types.CInt -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe (GHC.IO.Device.IODeviceType, System.Posix.Types.CDev, System.Posix.Types.CIno) -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.IO (FD, GHC.IO.Device.IODeviceType)
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Types.IO (FD, GHC.IO.Device.IODeviceType)
  openFileWith :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> (FD -> GHC.IO.Device.IODeviceType -> GHC.Types.IO r) -> ((forall x. GHC.Types.IO x -> GHC.Types.IO x) -> r -> GHC.Types.IO s) -> GHC.Types.IO s
  readRawBufferPtr :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO GHC.Types.Int
  readRawBufferPtrNoBlock :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO GHC.Types.Int
  release :: FD -> GHC.Types.IO ()
  setNonBlockingMode :: FD -> GHC.Types.Bool -> GHC.Types.IO FD
  stderr :: FD
  stdin :: FD
  stdout :: FD
  writeRawBufferPtr :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO Foreign.C.Types.CInt

module GHC.IO.Handle where
  AbsoluteSeek :: SeekMode
  BlockBuffering :: GHC.Maybe.Maybe GHC.Types.Int -> BufferMode
  type BufferMode :: *
  data BufferMode = ...
  CRLF :: Newline
  ExclusiveLock :: LockMode
  type Handle :: *
  data Handle = ...
  type HandlePosition :: *
  type HandlePosition = GHC.Num.Integer.Integer
  HandlePosn :: Handle -> HandlePosition -> HandlePosn
  type HandlePosn :: *
  data HandlePosn = ...
  LF :: Newline
  LineBuffering :: BufferMode
  type LockMode :: *
  data LockMode = ...
  type Newline :: *
  data Newline = ...
  NewlineMode :: Newline -> Newline -> NewlineMode
  type NewlineMode :: *
  data NewlineMode = ...
  NoBuffering :: BufferMode
  RelativeSeek :: SeekMode
  SeekFromEnd :: SeekMode
  type SeekMode :: *
  data SeekMode = ...
  SharedLock :: LockMode
  hClose :: Handle -> GHC.Types.IO ()
  hClose_help :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, GHC.Maybe.Maybe GHC.Exception.Type.SomeException)
  hDuplicate :: Handle -> GHC.Types.IO Handle
  hDuplicateTo :: Handle -> Handle -> GHC.Types.IO ()
  hFileSize :: Handle -> GHC.Types.IO GHC.Num.Integer.Integer
  hFlush :: Handle -> GHC.Types.IO ()
  hFlushAll :: Handle -> GHC.Types.IO ()
  hGetBuf :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufNonBlocking :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBuffering :: Handle -> GHC.Types.IO BufferMode
  hGetChar :: Handle -> GHC.Types.IO GHC.Types.Char
  hGetContents :: Handle -> GHC.Types.IO GHC.Base.String
  hGetContents' :: Handle -> GHC.Types.IO GHC.Base.String
  hGetEcho :: Handle -> GHC.Types.IO GHC.Types.Bool
  hGetEncoding :: Handle -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)
  hGetLine :: Handle -> GHC.Types.IO GHC.Base.String
  hGetPosn :: Handle -> GHC.Types.IO HandlePosn
  hIsClosed :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsEOF :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsOpen :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsReadable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsSeekable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsTerminalDevice :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsWritable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hLock :: Handle -> LockMode -> GHC.Types.IO ()
  hLookAhead :: Handle -> GHC.Types.IO GHC.Types.Char
  hPutBuf :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  hPutBufNonBlocking :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hPutChar :: Handle -> GHC.Types.Char -> GHC.Types.IO ()
  hPutStr :: Handle -> GHC.Base.String -> GHC.Types.IO ()
  hSeek :: Handle -> SeekMode -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
  hSetBinaryMode :: Handle -> GHC.Types.Bool -> GHC.Types.IO ()
  hSetBuffering :: Handle -> BufferMode -> GHC.Types.IO ()
  hSetEcho :: Handle -> GHC.Types.Bool -> GHC.Types.IO ()
  hSetEncoding :: Handle -> GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.IO ()
  hSetFileSize :: Handle -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
  hSetNewlineMode :: Handle -> NewlineMode -> GHC.Types.IO ()
  hSetPosn :: HandlePosn -> GHC.Types.IO ()
  hShow :: Handle -> GHC.Types.IO GHC.Base.String
  hTell :: Handle -> GHC.Types.IO GHC.Num.Integer.Integer
  hTryLock :: Handle -> LockMode -> GHC.Types.IO GHC.Types.Bool
  hWaitForInput :: Handle -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
  inputNL :: NewlineMode -> Newline
  isEOF :: GHC.Types.IO GHC.Types.Bool
  mkDuplexHandle :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> NewlineMode -> GHC.Types.IO Handle
  mkFileHandle :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> NewlineMode -> GHC.Types.IO Handle
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  outputNL :: NewlineMode -> Newline
  universalNewlineMode :: NewlineMode

module GHC.IO.Handle.FD where
  fdToHandle :: System.Posix.Internals.FD -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  fdToHandle' :: Foreign.C.Types.CInt -> GHC.Maybe.Maybe GHC.IO.Device.IODeviceType -> GHC.Types.Bool -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  handleToFd :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.IO.FD.FD
  mkHandleFromFD :: GHC.IO.FD.FD -> GHC.IO.Device.IODeviceType -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  stderr :: GHC.IO.Handle.Types.Handle
  stdin :: GHC.IO.Handle.Types.Handle
  stdout :: GHC.IO.Handle.Types.Handle
  withBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r

module GHC.IO.Handle.Internals where
  type HandleFinalizer :: *
  type HandleFinalizer = GHC.IO.FilePath -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  addHandleFinalizer :: GHC.IO.Handle.Types.Handle -> HandleFinalizer -> GHC.Types.IO ()
  augmentIOError :: GHC.IO.Exception.IOException -> GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.IO.Exception.IOException
  closeTextCodecs :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  dEFAULT_CHAR_BUFFER_SIZE :: GHC.Types.Int
  debugIO :: GHC.Base.String -> GHC.Types.IO ()
  decodeByteBuf :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  flushBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushByteReadBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushByteWriteBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushCharBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushCharReadBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushWriteBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  hClose_help :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, GHC.Maybe.Maybe GHC.Exception.Type.SomeException)
  hClose_impl :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO ()
  hLookAhead_ :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.Types.Char
  handleFinalizer :: GHC.IO.FilePath -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  initBufferState :: GHC.IO.Handle.Types.HandleType -> GHC.IO.Buffer.BufferState
  ioe_EOF :: GHC.Types.IO a
  ioe_bufsiz :: GHC.Types.Int -> GHC.Types.IO a
  ioe_closedHandle :: GHC.Types.IO a
  ioe_finalizedHandle :: GHC.IO.FilePath -> GHC.IO.Handle.Types.Handle__
  ioe_notReadable :: GHC.Types.IO a
  ioe_notWritable :: GHC.Types.IO a
  ioe_semiclosedHandle :: GHC.Types.IO a
  mkDuplexHandle :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkDuplexHandleNoFinalizer :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkFileHandle :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkFileHandleNoFinalizer :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkHandle :: (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.Handle.Types.HandleType -> GHC.Types.Bool -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Maybe.Maybe HandleFinalizer -> GHC.Maybe.Maybe (GHC.MVar.MVar GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openTextEncoding :: GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.HandleType -> (forall es ds. GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextEncoder es) -> GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextDecoder ds) -> GHC.Types.IO a) -> GHC.Types.IO a
  readTextDevice :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  readTextDeviceNonBlocking :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  traceIO :: GHC.Base.String -> GHC.Types.IO ()
  wantReadableHandle :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  wantReadableHandle_ :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  wantSeekableHandle :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  wantWritableHandle :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withAllHandles__ :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO ()
  withHandle :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  withHandle' :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  withHandle_ :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withHandle_' :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withHandle__' :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO ()
  writeCharBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO ()

module GHC.IO.Handle.Lock where
  ExclusiveLock :: LockMode
  FileLockingNotSupported :: FileLockingNotSupported
  type FileLockingNotSupported :: *
  data FileLockingNotSupported = ...
  type LockMode :: *
  data LockMode = ...
  SharedLock :: LockMode
  hLock :: GHC.IO.Handle.Types.Handle -> LockMode -> GHC.Types.IO ()
  hTryLock :: GHC.IO.Handle.Types.Handle -> LockMode -> GHC.Types.IO GHC.Types.Bool
  hUnlock :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO ()

module GHC.IO.Handle.Text where
  commitBuffer' :: GHC.IO.Buffer.RawCharBuffer -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  hGetBuf :: GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufNonBlocking :: GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufSome :: GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetChar :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Types.Char
  hGetContents :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hGetContents' :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hGetLine :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hPutBuf :: GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  hPutBufNonBlocking :: GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hPutChar :: GHC.IO.Handle.Types.Handle -> GHC.Types.Char -> GHC.Types.IO ()
  hPutStr :: GHC.IO.Handle.Types.Handle -> GHC.Base.String -> GHC.Types.IO ()
  hPutStrLn :: GHC.IO.Handle.Types.Handle -> GHC.Base.String -> GHC.Types.IO ()
  hWaitForInput :: GHC.IO.Handle.Types.Handle -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
  memcpy :: GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Foreign.C.Types.CSize -> GHC.Types.IO (GHC.Ptr.Ptr ())

module GHC.IO.Handle.Types where
  AppendHandle :: HandleType
  BlockBuffering :: GHC.Maybe.Maybe GHC.Types.Int -> BufferMode
  BufferCodec :: GHC.IO.Encoding.Types.CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = ...
  type role BufferList phantom
  type BufferList :: * -> *
  data BufferList e = ...
  BufferListCons :: GHC.IO.Buffer.RawBuffer e -> BufferList e -> BufferList e
  BufferListNil :: BufferList e
  type BufferMode :: *
  data BufferMode = ...
  CRLF :: Newline
  ClosedHandle :: HandleType
  DuplexHandle :: GHC.IO.FilePath -> GHC.MVar.MVar Handle__ -> GHC.MVar.MVar Handle__ -> Handle
  FileHandle :: GHC.IO.FilePath -> GHC.MVar.MVar Handle__ -> Handle
  type Handle :: *
  data Handle = ...
  type HandleType :: *
  data HandleType = ...
  Handle__ ::
    (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) =>
    dev -> HandleType -> GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.Word.Word8) -> BufferMode -> GHC.IORef.IORef (dec_state, GHC.IO.Buffer.Buffer GHC.Word.Word8) -> GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.IO.Buffer.CharBufElem) -> GHC.IORef.IORef (BufferList GHC.IO.Buffer.CharBufElem) -> GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextEncoder enc_state) -> GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextDecoder dec_state) -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> Newline -> Newline -> GHC.Maybe.Maybe (GHC.MVar.MVar Handle__) -> Handle__
  type Handle__ :: *
  data Handle__ = ...
  LF :: Newline
  LineBuffering :: BufferMode
  type Newline :: *
  data Newline = ...
  NewlineMode :: Newline -> Newline -> NewlineMode
  type NewlineMode :: *
  data NewlineMode = ...
  NoBuffering :: BufferMode
  ReadHandle :: HandleType
  ReadWriteHandle :: HandleType
  SemiClosedHandle :: HandleType
  WriteHandle :: HandleType
  checkHandleInvariants :: Handle__ -> GHC.Types.IO ()
  close :: BufferCodec from to state -> GHC.Types.IO ()
  encode :: BufferCodec from to state -> GHC.IO.Encoding.Types.CodeBuffer from to
  getState :: BufferCodec from to state -> GHC.Types.IO state
  haBufferMode :: Handle__ -> BufferMode
  haBuffers :: Handle__ -> GHC.IORef.IORef (BufferList GHC.IO.Buffer.CharBufElem)
  haByteBuffer :: Handle__ -> GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  haCharBuffer :: Handle__ -> GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.IO.Buffer.CharBufElem)
  haCodec :: Handle__ -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding
  haDecoder :: ()
  haDevice :: ()
  haEncoder :: ()
  haInputNL :: Handle__ -> Newline
  haLastDecode :: ()
  haOtherSide :: Handle__ -> GHC.Maybe.Maybe (GHC.MVar.MVar Handle__)
  haOutputNL :: Handle__ -> Newline
  haType :: Handle__ -> HandleType
  inputNL :: NewlineMode -> Newline
  isAppendHandleType :: HandleType -> GHC.Types.Bool
  isReadWriteHandleType :: HandleType -> GHC.Types.Bool
  isReadableHandleType :: HandleType -> GHC.Types.Bool
  isWritableHandleType :: HandleType -> GHC.Types.Bool
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  outputNL :: NewlineMode -> Newline
  recover :: BufferCodec from to state -> GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)
  setState :: BufferCodec from to state -> state -> GHC.Types.IO ()
  showHandle :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Base.String
  universalNewlineMode :: NewlineMode

module GHC.IO.IOMode where
  AppendMode :: IOMode
  type IOMode :: *
  data IOMode = ...
  ReadMode :: IOMode
  ReadWriteMode :: IOMode
  WriteMode :: IOMode

module GHC.IO.StdHandles where
  openBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  stderr :: GHC.IO.Handle.Types.Handle
  stdin :: GHC.IO.Handle.Types.Handle
  stdout :: GHC.IO.Handle.Types.Handle
  withBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r

module GHC.IO.SubSystem where
  (<!>) :: a -> a -> a
  IoNative :: IoSubSystem
  IoPOSIX :: IoSubSystem
  type IoSubSystem :: *
  data IoSubSystem = ...
  conditional :: a -> a -> a
  ioSubSystem :: IoSubSystem
  isWindowsNativeIO :: GHC.Types.Bool
  whenIoSubSystem :: IoSubSystem -> GHC.Types.IO () -> GHC.Types.IO ()
  withIoSubSystem :: (IoSubSystem -> GHC.Types.IO a) -> GHC.Types.IO a
  withIoSubSystem' :: (IoSubSystem -> a) -> a

module GHC.IO.Unsafe where
  noDuplicate :: GHC.Types.IO ()
  unsafeDupableInterleaveIO :: GHC.Types.IO a -> GHC.Types.IO a
  unsafeDupablePerformIO :: GHC.Types.IO a -> a
  unsafeInterleaveIO :: GHC.Types.IO a -> GHC.Types.IO a
  unsafePerformIO :: GHC.Types.IO a -> a

module GHC.IOArray where
  IOArray :: GHC.Arr.STArray GHC.Prim.RealWorld i e -> IOArray i e
  type role IOArray nominal representational
  type IOArray :: * -> * -> *
  newtype IOArray i e = ...
  boundsIOArray :: IOArray i e -> (i, i)
  newIOArray :: GHC.Ix.Ix i => (i, i) -> e -> GHC.Types.IO (IOArray i e)
  readIOArray :: GHC.Ix.Ix i => IOArray i e -> i -> GHC.Types.IO e
  unsafeReadIOArray :: IOArray i e -> GHC.Types.Int -> GHC.Types.IO e
  unsafeWriteIOArray :: IOArray i e -> GHC.Types.Int -> e -> GHC.Types.IO ()
  writeIOArray :: GHC.Ix.Ix i => IOArray i e -> i -> e -> GHC.Types.IO ()

module GHC.IOPort where
  IOPort :: GHC.Prim.IOPort# GHC.Prim.RealWorld a -> IOPort a
  type IOPort :: * -> *
  data IOPort a = ...
  doubleReadException :: GHC.Exception.Type.SomeException
  newEmptyIOPort :: GHC.Types.IO (IOPort a)
  newIOPort :: a -> GHC.Types.IO (IOPort a)
  readIOPort :: IOPort a -> GHC.Types.IO a
  writeIOPort :: IOPort a -> a -> GHC.Types.IO GHC.Types.Bool

module GHC.IORef where
  IORef :: GHC.STRef.STRef GHC.Prim.RealWorld a -> IORef a
  type IORef :: * -> *
  newtype IORef a = ...
  atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicModifyIORef'_ :: IORef a -> (a -> a) -> GHC.Types.IO (a, a)
  atomicModifyIORef2 :: IORef a -> (a -> (a, b)) -> GHC.Types.IO (a, (a, b))
  atomicModifyIORef2Lazy :: IORef a -> (a -> (a, b)) -> GHC.Types.IO (a, (a, b))
  atomicModifyIORefLazy_ :: IORef a -> (a -> a) -> GHC.Types.IO (a, a)
  atomicModifyIORefP :: IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicSwapIORef :: IORef a -> a -> GHC.Types.IO a
  newIORef :: a -> GHC.Types.IO (IORef a)
  readIORef :: IORef a -> GHC.Types.IO a
  writeIORef :: IORef a -> a -> GHC.Types.IO ()

module GHC.InfoProv where
  InfoProv :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> InfoProv
  type InfoProv :: *
  data InfoProv = ...
  type InfoProvEnt :: *
  data InfoProvEnt
  ipDesc :: InfoProv -> GHC.Base.String
  ipLabel :: InfoProv -> GHC.Base.String
  ipLoc :: InfoProv -> GHC.Base.String
  ipMod :: InfoProv -> GHC.Base.String
  ipName :: InfoProv -> GHC.Base.String
  ipSrcFile :: InfoProv -> GHC.Base.String
  ipSrcSpan :: InfoProv -> GHC.Base.String
  ipTyDesc :: InfoProv -> GHC.Base.String
  ipeProv :: GHC.Ptr.Ptr InfoProvEnt -> GHC.Ptr.Ptr InfoProv
  peekInfoProv :: GHC.Ptr.Ptr InfoProv -> GHC.Types.IO InfoProv
  whereFrom :: a -> GHC.Types.IO (GHC.Maybe.Maybe InfoProv)

module GHC.Int where
  I# :: GHC.Prim.Int# -> Int
  I16# :: GHC.Prim.Int16# -> Int16
  I32# :: GHC.Prim.Int32# -> Int32
  I64# :: GHC.Prim.Int64# -> Int64
  I8# :: GHC.Prim.Int8# -> Int8
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...
  eqInt :: Int -> Int -> GHC.Types.Bool
  eqInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  eqInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  eqInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  eqInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  geInt :: Int -> Int -> GHC.Types.Bool
  geInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  geInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  geInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  geInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  gtInt :: Int -> Int -> GHC.Types.Bool
  gtInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  gtInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  gtInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  gtInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  leInt :: Int -> Int -> GHC.Types.Bool
  leInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  leInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  leInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  leInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  ltInt :: Int -> Int -> GHC.Types.Bool
  ltInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  ltInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  ltInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  ltInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  neInt :: Int -> Int -> GHC.Types.Bool
  neInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  neInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  neInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  neInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  shiftRLInt16# :: GHC.Prim.Int16# -> GHC.Prim.Int# -> GHC.Prim.Int16#
  shiftRLInt32# :: GHC.Prim.Int32# -> GHC.Prim.Int# -> GHC.Prim.Int32#
  shiftRLInt8# :: GHC.Prim.Int8# -> GHC.Prim.Int# -> GHC.Prim.Int8#
  uncheckedIShiftL64# :: GHC.Prim.Int64# -> GHC.Prim.Int# -> GHC.Prim.Int64#
  uncheckedIShiftRA64# :: GHC.Prim.Int64# -> GHC.Prim.Int# -> GHC.Prim.Int64#

module GHC.Integer where
  type Integer :: *
  data Integer = ...
  absInteger :: Integer -> Integer
  andInteger :: Integer -> Integer -> Integer
  bitInteger :: GHC.Prim.Int# -> Integer
  compareInteger :: Integer -> Integer -> GHC.Types.Ordering
  complementInteger :: Integer -> Integer
  decodeDoubleInteger :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  divInteger :: Integer -> Integer -> Integer
  divModInteger :: Integer -> Integer -> (# Integer, Integer #)
  encodeDoubleInteger :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  encodeFloatInteger :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  eqInteger :: Integer -> Integer -> GHC.Types.Bool
  eqInteger# :: Integer -> Integer -> GHC.Prim.Int#
  geInteger :: Integer -> Integer -> GHC.Types.Bool
  geInteger# :: Integer -> Integer -> GHC.Prim.Int#
  gtInteger :: Integer -> Integer -> GHC.Types.Bool
  gtInteger# :: Integer -> Integer -> GHC.Prim.Int#
  hashInteger :: Integer -> GHC.Prim.Int#
  integerToInt :: Integer -> GHC.Prim.Int#
  integerToWord :: Integer -> GHC.Prim.Word#
  leInteger :: Integer -> Integer -> GHC.Types.Bool
  leInteger# :: Integer -> Integer -> GHC.Prim.Int#
  ltInteger :: Integer -> Integer -> GHC.Types.Bool
  ltInteger# :: Integer -> Integer -> GHC.Prim.Int#
  minusInteger :: Integer -> Integer -> Integer
  modInteger :: Integer -> Integer -> Integer
  negateInteger :: Integer -> Integer
  neqInteger :: Integer -> Integer -> GHC.Types.Bool
  neqInteger# :: Integer -> Integer -> GHC.Prim.Int#
  orInteger :: Integer -> Integer -> Integer
  plusInteger :: Integer -> Integer -> Integer
  popCountInteger :: Integer -> GHC.Prim.Int#
  quotInteger :: Integer -> Integer -> Integer
  quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
  remInteger :: Integer -> Integer -> Integer
  shiftLInteger :: Integer -> GHC.Prim.Int# -> Integer
  shiftRInteger :: Integer -> GHC.Prim.Int# -> Integer
  signumInteger :: Integer -> Integer
  smallInteger :: GHC.Prim.Int# -> Integer
  testBitInteger :: Integer -> GHC.Prim.Int# -> GHC.Types.Bool
  timesInteger :: Integer -> Integer -> Integer
  wordToInteger :: GHC.Prim.Word# -> Integer
  xorInteger :: Integer -> Integer -> Integer

module GHC.Integer.Logarithms where
  integerLog2# :: GHC.Num.Integer.Integer -> GHC.Prim.Int#
  integerLogBase# :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> GHC.Prim.Int#
  wordLog2# :: GHC.Prim.Word# -> GHC.Prim.Int#

module GHC.IsList where
  type IsList :: * -> Constraint
  class IsList l
    ...
    ...
  type Item :: * -> *
  type family Item l
  fromList :: IsList l => [Item l] -> l
  fromListN :: IsList l => GHC.Types.Int -> [Item l] -> l
  toList :: IsList l => l -> [Item l]

module GHC.Ix where
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a
    ...
  inRange :: Ix a => (a, a) -> a -> GHC.Types.Bool
  index :: Ix a => (a, a) -> a -> GHC.Types.Int
  indexError :: GHC.Show.Show a => (a, a) -> a -> GHC.Base.String -> b
  range :: Ix a => (a, a) -> [a]
  rangeSize :: Ix a => (a, a) -> GHC.Types.Int
  unsafeIndex :: Ix a => (a, a) -> a -> GHC.Types.Int
  unsafeRangeSize :: Ix a => (a, a) -> GHC.Types.Int

module GHC.List where
  (!!) :: GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: [a] -> [a] -> [a]
  type List :: * -> *
  data List a = ...
  all :: (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  and :: [GHC.Types.Bool] -> GHC.Types.Bool
  any :: (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  augment :: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  break :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
  concat :: [[a]] -> [a]
  concatMap :: (a -> [b]) -> [a] -> [b]
  cycle :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  drop :: GHC.Types.Int -> [a] -> [a]
  dropWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  errorEmptyList :: GHC.Stack.Types.HasCallStack => GHC.Base.String -> a
  filter :: (a -> GHC.Types.Bool) -> [a] -> [a]
  foldl :: (b -> a -> b) -> b -> [a] -> b
  foldl' :: (b -> a -> b) -> b -> [a] -> b
  foldl1 :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldl1' :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr' :: (a -> b -> b) -> b -> [a] -> b
  foldr1 :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  head :: GHC.Stack.Types.HasCallStack => [a] -> a
  init :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  iterate :: (a -> a) -> a -> [a]
  iterate' :: (a -> a) -> a -> [a]
  last :: GHC.Stack.Types.HasCallStack => [a] -> a
  length :: [a] -> GHC.Types.Int
  lookup :: GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: (a -> b) -> [a] -> [b]
  maximum :: (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  minimum :: (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  notElem :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  null :: [a] -> GHC.Types.Bool
  or :: [GHC.Types.Bool] -> GHC.Types.Bool
  product :: GHC.Num.Num a => [a] -> a
  repeat :: a -> [a]
  replicate :: GHC.Types.Int -> a -> [a]
  reverse :: [a] -> [a]
  scanl :: (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: (a -> a -> a) -> [a] -> [a]
  scanr :: (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: (a -> a -> a) -> [a] -> [a]
  span :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: GHC.Types.Int -> [a] -> ([a], [a])
  sum :: GHC.Num.Num a => [a] -> a
  tail :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  take :: GHC.Types.Int -> [a] -> [a]
  takeWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  uncons :: [a] -> GHC.Maybe.Maybe (a, [a])
  unzip :: [(a, b)] -> ([a], [b])
  unzip3 :: [(a, b, c)] -> ([a], [b], [c])
  zip :: [a] -> [b] -> [(a, b)]
  zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
  zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

module GHC.MVar where
  MVar :: GHC.Prim.MVar# GHC.Prim.RealWorld a -> MVar a
  type MVar :: * -> *
  data MVar a = ...
  addMVarFinalizer :: MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  isEmptyMVar :: MVar a -> GHC.Types.IO GHC.Types.Bool
  newEmptyMVar :: GHC.Types.IO (MVar a)
  newMVar :: a -> GHC.Types.IO (MVar a)
  putMVar :: MVar a -> a -> GHC.Types.IO ()
  readMVar :: MVar a -> GHC.Types.IO a
  takeMVar :: MVar a -> GHC.Types.IO a
  tryPutMVar :: MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)

module GHC.Maybe where
  Just :: a -> Maybe a
  type Maybe :: * -> *
  data Maybe a = ...
  Nothing :: Maybe a

module GHC.Natural where
  BN# :: GHC.Num.BigNat.BigNat# -> BigNat
  type BigNat :: *
  data BigNat = ...
  pattern NatJ# :: BigNat -> Natural
  pattern NatS# :: GHC.Prim.Word# -> Natural
  type Natural :: *
  data Natural = ...
  andNatural :: Natural -> Natural -> Natural
  bitNatural :: GHC.Prim.Int# -> Natural
  gcdNatural :: Natural -> Natural -> Natural
  isValidNatural :: Natural -> GHC.Types.Bool
  lcmNatural :: Natural -> Natural -> Natural
  minusNatural :: Natural -> Natural -> Natural
  minusNaturalMaybe :: Natural -> Natural -> GHC.Maybe.Maybe Natural
  mkNatural :: [GHC.Types.Word] -> Natural
  naturalFromInteger :: GHC.Num.Integer.Integer -> Natural
  naturalToInteger :: Natural -> GHC.Num.Integer.Integer
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWordMaybe :: Natural -> GHC.Maybe.Maybe GHC.Types.Word
  negateNatural :: Natural -> Natural
  orNatural :: Natural -> Natural -> Natural
  plusNatural :: Natural -> Natural -> Natural
  popCountNatural :: Natural -> GHC.Types.Int
  powModNatural :: Natural -> Natural -> Natural -> Natural
  quotNatural :: Natural -> Natural -> Natural
  quotRemNatural :: Natural -> Natural -> (Natural, Natural)
  remNatural :: Natural -> Natural -> Natural
  shiftLNatural :: Natural -> GHC.Types.Int -> Natural
  shiftRNatural :: Natural -> GHC.Types.Int -> Natural
  signumNatural :: Natural -> Natural
  testBitNatural :: Natural -> GHC.Types.Int -> GHC.Types.Bool
  timesNatural :: Natural -> Natural -> Natural
  unBigNat :: BigNat -> GHC.Num.BigNat.BigNat#
  wordToNatural :: GHC.Types.Word -> Natural
  wordToNatural# :: GHC.Types.Word -> Natural
  xorNatural :: Natural -> Natural -> Natural

module GHC.Num where
  (*) :: Num a => a -> a -> a
  (+) :: Num a => a -> a -> a
  (-) :: Num a => a -> a -> a
  IN :: GHC.Prim.ByteArray# -> Integer
  IP :: GHC.Prim.ByteArray# -> Integer
  IS :: GHC.Prim.Int# -> Integer
  type Integer :: *
  data Integer = ...
  NB :: GHC.Prim.ByteArray# -> Natural
  NS :: GHC.Prim.Word# -> Natural
  type Natural :: *
  data Natural = ...
  type Num :: * -> Constraint
  class Num a
    ...
  abs :: Num a => a -> a
  fromInteger :: Num a => Integer -> a
  integerAbs :: Integer -> Integer
  integerAdd :: Integer -> Integer -> Integer
  integerAnd :: Integer -> Integer -> Integer
  integerBit :: GHC.Types.Word -> Integer
  integerBit# :: GHC.Prim.Word# -> Integer
  integerCheck :: Integer -> GHC.Types.Bool
  integerCheck# :: Integer -> GHC.Num.Primitives.Bool#
  integerCompare :: Integer -> Integer -> GHC.Types.Ordering
  integerComplement :: Integer -> Integer
  integerDecodeDouble# :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  integerDiv :: Integer -> Integer -> Integer
  integerDivMod :: Integer -> Integer -> (Integer, Integer)
  integerDivMod# :: Integer -> Integer -> (# Integer, Integer #)
  integerEncodeDouble :: Integer -> GHC.Types.Int -> GHC.Types.Double
  integerEncodeDouble# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  integerEncodeFloat# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  integerEq :: Integer -> Integer -> GHC.Types.Bool
  integerEq# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Integer
  integerFromAddr# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromBigNat# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatNeg# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatSign# :: GHC.Prim.Int# -> GHC.Num.BigNat.BigNat# -> Integer
  integerFromByteArray :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> Integer
  integerFromByteArray# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromInt :: GHC.Types.Int -> Integer
  integerFromInt# :: GHC.Prim.Int# -> Integer
  integerFromInt64# :: GHC.Prim.Int64# -> Integer
  integerFromNatural :: Natural -> Integer
  integerFromWord :: GHC.Types.Word -> Integer
  integerFromWord# :: GHC.Prim.Word# -> Integer
  integerFromWord64# :: GHC.Prim.Word64# -> Integer
  integerFromWordList :: GHC.Types.Bool -> [GHC.Types.Word] -> Integer
  integerFromWordNeg# :: GHC.Prim.Word# -> Integer
  integerFromWordSign# :: GHC.Prim.Int# -> GHC.Prim.Word# -> Integer
  integerGcd :: Integer -> Integer -> Integer
  integerGcde :: Integer -> Integer -> (Integer, Integer, Integer)
  integerGcde# :: Integer -> Integer -> (# Integer, Integer, Integer #)
  integerGe :: Integer -> Integer -> GHC.Types.Bool
  integerGe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerGt :: Integer -> Integer -> GHC.Types.Bool
  integerGt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerIsNegative :: Integer -> GHC.Types.Bool
  integerIsNegative# :: Integer -> GHC.Num.Primitives.Bool#
  integerIsOne :: Integer -> GHC.Types.Bool
  integerIsPowerOf2# :: Integer -> (# (# #) | GHC.Prim.Word# #)
  integerIsZero :: Integer -> GHC.Types.Bool
  integerLcm :: Integer -> Integer -> Integer
  integerLe :: Integer -> Integer -> GHC.Types.Bool
  integerLe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerLog2 :: Integer -> GHC.Types.Word
  integerLog2# :: Integer -> GHC.Prim.Word#
  integerLogBase :: Integer -> Integer -> GHC.Types.Word
  integerLogBase# :: Integer -> Integer -> GHC.Prim.Word#
  integerLogBaseWord :: GHC.Types.Word -> Integer -> GHC.Types.Word
  integerLogBaseWord# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerLt :: Integer -> Integer -> GHC.Types.Bool
  integerLt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerMod :: Integer -> Integer -> Integer
  integerMul :: Integer -> Integer -> Integer
  integerNe :: Integer -> Integer -> GHC.Types.Bool
  integerNe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerNegate :: Integer -> Integer
  integerOne :: Integer
  integerOr :: Integer -> Integer -> Integer
  integerPopCount# :: Integer -> GHC.Prim.Int#
  integerPowMod# :: Integer -> Integer -> Natural -> (# Natural | () #)
  integerQuot :: Integer -> Integer -> Integer
  integerQuotRem :: Integer -> Integer -> (Integer, Integer)
  integerQuotRem# :: Integer -> Integer -> (# Integer, Integer #)
  integerRecipMod# :: Integer -> Natural -> (# Natural | () #)
  integerRem :: Integer -> Integer -> Integer
  integerShiftL :: Integer -> GHC.Types.Word -> Integer
  integerShiftL# :: Integer -> GHC.Prim.Word# -> Integer
  integerShiftR :: Integer -> GHC.Types.Word -> Integer
  integerShiftR# :: Integer -> GHC.Prim.Word# -> Integer
  integerSignum :: Integer -> Integer
  integerSignum# :: Integer -> GHC.Prim.Int#
  integerSizeInBase# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerSqr :: Integer -> Integer
  integerSub :: Integer -> Integer -> Integer
  integerTestBit :: Integer -> GHC.Types.Word -> GHC.Types.Bool
  integerTestBit# :: Integer -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  integerToAddr :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToAddr# :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToBigNatClamp# :: Integer -> GHC.Num.BigNat.BigNat#
  integerToBigNatSign# :: Integer -> (# GHC.Prim.Int#, GHC.Num.BigNat.BigNat# #)
  integerToInt :: Integer -> GHC.Types.Int
  integerToInt# :: Integer -> GHC.Prim.Int#
  integerToInt64# :: Integer -> GHC.Prim.Int64#
  integerToMutableByteArray :: Integer -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToMutableByteArray# :: Integer -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToNatural :: Integer -> Natural
  integerToNaturalClamp :: Integer -> Natural
  integerToNaturalThrow :: Integer -> Natural
  integerToWord :: Integer -> GHC.Types.Word
  integerToWord# :: Integer -> GHC.Prim.Word#
  integerToWord64# :: Integer -> GHC.Prim.Word64#
  integerXor :: Integer -> Integer -> Integer
  integerZero :: Integer
  naturalAdd :: Natural -> Natural -> Natural
  naturalAnd :: Natural -> Natural -> Natural
  naturalAndNot :: Natural -> Natural -> Natural
  naturalBit :: GHC.Types.Word -> Natural
  naturalBit# :: GHC.Prim.Word# -> Natural
  naturalCheck :: Natural -> GHC.Types.Bool
  naturalCheck# :: Natural -> GHC.Num.Primitives.Bool#
  naturalClearBit :: Natural -> GHC.Types.Word -> Natural
  naturalClearBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalCompare :: Natural -> Natural -> GHC.Types.Ordering
  naturalComplementBit :: Natural -> GHC.Types.Word -> Natural
  naturalComplementBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalEncodeDouble# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Double#
  naturalEncodeFloat# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Float#
  naturalEq :: Natural -> Natural -> GHC.Types.Bool
  naturalEq# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Natural
  naturalFromAddr# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromBigNat# :: GHC.Num.BigNat.BigNat# -> Natural
  naturalFromByteArray# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromWord :: GHC.Types.Word -> Natural
  naturalFromWord# :: GHC.Prim.Word# -> Natural
  naturalFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> Natural
  naturalFromWordList :: [GHC.Types.Word] -> Natural
  naturalGcd :: Natural -> Natural -> Natural
  naturalGe :: Natural -> Natural -> GHC.Types.Bool
  naturalGe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalGt :: Natural -> Natural -> GHC.Types.Bool
  naturalGt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalIsOne :: Natural -> GHC.Types.Bool
  naturalIsPowerOf2# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalIsZero :: Natural -> GHC.Types.Bool
  naturalLcm :: Natural -> Natural -> Natural
  naturalLe :: Natural -> Natural -> GHC.Types.Bool
  naturalLe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalLog2 :: Natural -> GHC.Types.Word
  naturalLog2# :: Natural -> GHC.Prim.Word#
  naturalLogBase :: Natural -> Natural -> GHC.Types.Word
  naturalLogBase# :: Natural -> Natural -> GHC.Prim.Word#
  naturalLogBaseWord :: GHC.Types.Word -> Natural -> GHC.Types.Word
  naturalLogBaseWord# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalLt :: Natural -> Natural -> GHC.Types.Bool
  naturalLt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalMul :: Natural -> Natural -> Natural
  naturalNe :: Natural -> Natural -> GHC.Types.Bool
  naturalNe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalNegate :: Natural -> Natural
  naturalOne :: Natural
  naturalOr :: Natural -> Natural -> Natural
  naturalPopCount :: Natural -> GHC.Types.Word
  naturalPopCount# :: Natural -> GHC.Prim.Word#
  naturalPowMod :: Natural -> Natural -> Natural -> Natural
  naturalQuot :: Natural -> Natural -> Natural
  naturalQuotRem :: Natural -> Natural -> (Natural, Natural)
  naturalQuotRem# :: Natural -> Natural -> (# Natural, Natural #)
  naturalRem :: Natural -> Natural -> Natural
  naturalSetBit :: Natural -> GHC.Types.Word -> Natural
  naturalSetBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftL :: Natural -> GHC.Types.Word -> Natural
  naturalShiftL# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftR :: Natural -> GHC.Types.Word -> Natural
  naturalShiftR# :: Natural -> GHC.Prim.Word# -> Natural
  naturalSignum :: Natural -> Natural
  naturalSizeInBase# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalSqr :: Natural -> Natural
  naturalSub :: Natural -> Natural -> (# (# #) | Natural #)
  naturalSubThrow :: Natural -> Natural -> Natural
  naturalSubUnsafe :: Natural -> Natural -> Natural
  naturalTestBit :: Natural -> GHC.Types.Word -> GHC.Types.Bool
  naturalTestBit# :: Natural -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  naturalToAddr :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  naturalToAddr# :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToBigNat# :: Natural -> GHC.Num.BigNat.BigNat#
  naturalToMutableByteArray# :: Natural -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWord# :: Natural -> GHC.Prim.Word#
  naturalToWordClamp :: Natural -> GHC.Types.Word
  naturalToWordClamp# :: Natural -> GHC.Prim.Word#
  naturalToWordMaybe# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalXor :: Natural -> Natural -> Natural
  naturalZero :: Natural
  negate :: Num a => a -> a
  quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
  signum :: Num a => a -> a
  subtract :: Num a => a -> a -> a

module GHC.Num.BigNat where
  BN# :: BigNat# -> BigNat
  type BigNat :: *
  data BigNat = ...
  type BigNat# :: GHC.Types.UnliftedType
  type BigNat# = GHC.Num.WordArray.WordArray# :: GHC.Types.UnliftedType
  bigNatAdd :: BigNat# -> BigNat# -> BigNat#
  bigNatAddWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatAddWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatAnd :: BigNat# -> BigNat# -> BigNat#
  bigNatAndInt# :: BigNat# -> GHC.Prim.Int# -> BigNat#
  bigNatAndNot :: BigNat# -> BigNat# -> BigNat#
  bigNatAndNotWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatAndWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatBit :: GHC.Types.Word -> BigNat#
  bigNatBit# :: GHC.Prim.Word# -> BigNat#
  bigNatCheck :: BigNat# -> GHC.Types.Bool
  bigNatCheck# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatClearBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatCompare :: BigNat# -> BigNat# -> GHC.Types.Ordering
  bigNatCompareWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Ordering
  bigNatCompareWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Types.Ordering
  bigNatComplementBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatCtz :: BigNat# -> GHC.Types.Word
  bigNatCtz# :: BigNat# -> GHC.Prim.Word#
  bigNatCtzWord :: BigNat# -> GHC.Types.Word
  bigNatCtzWord# :: BigNat# -> GHC.Prim.Word#
  bigNatEncodeDouble# :: BigNat# -> GHC.Prim.Int# -> GHC.Prim.Double#
  bigNatEq :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatEq# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatEqWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatFromAbsInt# :: GHC.Prim.Int# -> BigNat#
  bigNatFromAddr# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromAddrBE# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromAddrLE# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArray# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArrayBE# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArrayLE# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromWord :: GHC.Types.Word -> BigNat#
  bigNatFromWord# :: GHC.Prim.Word# -> BigNat#
  bigNatFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> BigNat#
  bigNatFromWord64# :: GHC.Prim.Word64# -> BigNat#
  bigNatFromWordArray :: GHC.Num.WordArray.WordArray# -> GHC.Prim.Word# -> BigNat
  bigNatFromWordArray# :: GHC.Num.WordArray.WordArray# -> GHC.Prim.Word# -> BigNat#
  bigNatFromWordList :: [GHC.Types.Word] -> BigNat#
  bigNatFromWordList# :: [GHC.Types.Word] -> GHC.Num.WordArray.WordArray#
  bigNatFromWordListUnsafe :: [GHC.Types.Word] -> BigNat#
  bigNatGcd :: BigNat# -> BigNat# -> BigNat#
  bigNatGcdWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatGe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatGe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatGt :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatGt# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatGtWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatGtWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatIndex :: BigNat# -> GHC.Prim.Int# -> GHC.Types.Word
  bigNatIndex# :: BigNat# -> GHC.Prim.Int# -> GHC.Prim.Word#
  bigNatIsOne :: BigNat# -> GHC.Types.Bool
  bigNatIsOne# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatIsPowerOf2# :: BigNat# -> (# (# #) | GHC.Prim.Word# #)
  bigNatIsTwo :: BigNat# -> GHC.Types.Bool
  bigNatIsTwo# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatIsZero :: BigNat# -> GHC.Types.Bool
  bigNatIsZero# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatLcm :: BigNat# -> BigNat# -> BigNat#
  bigNatLcmWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatLcmWordWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> BigNat#
  bigNatLe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatLe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatLeWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatLeWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatLog2 :: BigNat# -> GHC.Types.Word
  bigNatLog2# :: BigNat# -> GHC.Prim.Word#
  bigNatLogBase :: BigNat# -> BigNat# -> GHC.Types.Word
  bigNatLogBase# :: BigNat# -> BigNat# -> GHC.Prim.Word#
  bigNatLogBaseWord :: GHC.Types.Word -> BigNat# -> GHC.Types.Word
  bigNatLogBaseWord# :: GHC.Prim.Word# -> BigNat# -> GHC.Prim.Word#
  bigNatLt :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatLt# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatMul :: BigNat# -> BigNat# -> BigNat#
  bigNatMulWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatMulWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatNe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatNe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatOne :: BigNat
  bigNatOne# :: (# #) -> BigNat#
  bigNatOr :: BigNat# -> BigNat# -> BigNat#
  bigNatOrWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatPopCount :: BigNat# -> GHC.Types.Word
  bigNatPopCount# :: BigNat# -> GHC.Prim.Word#
  bigNatPowMod :: BigNat# -> BigNat# -> BigNat# -> BigNat#
  bigNatPowModWord# :: BigNat# -> BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatQuot :: BigNat# -> BigNat# -> BigNat#
  bigNatQuotRem# :: BigNat# -> BigNat# -> (# BigNat#, BigNat# #)
  bigNatQuotRemWord# :: BigNat# -> GHC.Prim.Word# -> (# BigNat#, GHC.Prim.Word# #)
  bigNatQuotWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatQuotWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatRem :: BigNat# -> BigNat# -> BigNat#
  bigNatRemWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Word
  bigNatRemWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatSetBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftL :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatShiftL# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftR :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatShiftR# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftRNeg# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatSize :: BigNat# -> GHC.Types.Word
  bigNatSize# :: BigNat# -> GHC.Prim.Int#
  bigNatSizeInBase :: GHC.Types.Word -> BigNat# -> GHC.Types.Word
  bigNatSizeInBase# :: GHC.Prim.Word# -> BigNat# -> GHC.Prim.Word#
  bigNatSqr :: BigNat# -> BigNat#
  bigNatSub :: BigNat# -> BigNat# -> (# (# #) | BigNat# #)
  bigNatSubUnsafe :: BigNat# -> BigNat# -> BigNat#
  bigNatSubWord# :: BigNat# -> GHC.Prim.Word# -> (# (# #) | BigNat# #)
  bigNatSubWordUnsafe :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatSubWordUnsafe# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatTestBit :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatTestBit# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatToAddr :: BigNat# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  bigNatToAddr# :: BigNat# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToAddrBE# :: BigNat# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToAddrLE# :: BigNat# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToInt :: BigNat# -> GHC.Types.Int
  bigNatToInt# :: BigNat# -> GHC.Prim.Int#
  bigNatToMutableByteArray# :: BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToMutableByteArrayBE# :: BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToMutableByteArrayLE# :: BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToWord :: BigNat# -> GHC.Types.Word
  bigNatToWord# :: BigNat# -> GHC.Prim.Word#
  bigNatToWord64# :: BigNat# -> GHC.Prim.Word64#
  bigNatToWordList :: BigNat# -> [GHC.Types.Word]
  bigNatToWordMaybe# :: BigNat# -> (# (# #) | GHC.Prim.Word# #)
  bigNatXor :: BigNat# -> BigNat# -> BigNat#
  bigNatXorWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatZero :: BigNat
  bigNatZero# :: (# #) -> BigNat#
  gcdInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  gcdInt# :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  gcdWord :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
  gcdWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  powModWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  raiseDivZero_BigNat :: (# #) -> BigNat#
  unBigNat :: BigNat -> BigNat#

module GHC.Num.Integer where
  IN :: GHC.Prim.ByteArray# -> Integer
  IP :: GHC.Prim.ByteArray# -> Integer
  IS :: GHC.Prim.Int# -> Integer
  type Integer :: *
  data Integer = ...
  integerAbs :: Integer -> Integer
  integerAdd :: Integer -> Integer -> Integer
  integerAnd :: Integer -> Integer -> Integer
  integerBit :: GHC.Types.Word -> Integer
  integerBit# :: GHC.Prim.Word# -> Integer
  integerCheck :: Integer -> GHC.Types.Bool
  integerCheck# :: Integer -> GHC.Num.Primitives.Bool#
  integerCompare :: Integer -> Integer -> GHC.Types.Ordering
  integerComplement :: Integer -> Integer
  integerDecodeDouble# :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  integerDiv :: Integer -> Integer -> Integer
  integerDivMod :: Integer -> Integer -> (Integer, Integer)
  integerDivMod# :: Integer -> Integer -> (# Integer, Integer #)
  integerEncodeDouble :: Integer -> GHC.Types.Int -> GHC.Types.Double
  integerEncodeDouble# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  integerEncodeFloat# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  integerEq :: Integer -> Integer -> GHC.Types.Bool
  integerEq# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Integer
  integerFromAddr# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromBigNat# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatNeg# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatSign# :: GHC.Prim.Int# -> GHC.Num.BigNat.BigNat# -> Integer
  integerFromByteArray :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> Integer
  integerFromByteArray# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromInt :: GHC.Types.Int -> Integer
  integerFromInt# :: GHC.Prim.Int# -> Integer
  integerFromInt64# :: GHC.Prim.Int64# -> Integer
  integerFromNatural :: GHC.Num.Natural.Natural -> Integer
  integerFromWord :: GHC.Types.Word -> Integer
  integerFromWord# :: GHC.Prim.Word# -> Integer
  integerFromWord64# :: GHC.Prim.Word64# -> Integer
  integerFromWordList :: GHC.Types.Bool -> [GHC.Types.Word] -> Integer
  integerFromWordNeg# :: GHC.Prim.Word# -> Integer
  integerFromWordSign# :: GHC.Prim.Int# -> GHC.Prim.Word# -> Integer
  integerGcd :: Integer -> Integer -> Integer
  integerGcde :: Integer -> Integer -> (Integer, Integer, Integer)
  integerGcde# :: Integer -> Integer -> (# Integer, Integer, Integer #)
  integerGe :: Integer -> Integer -> GHC.Types.Bool
  integerGe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerGt :: Integer -> Integer -> GHC.Types.Bool
  integerGt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerIsNegative :: Integer -> GHC.Types.Bool
  integerIsNegative# :: Integer -> GHC.Num.Primitives.Bool#
  integerIsOne :: Integer -> GHC.Types.Bool
  integerIsPowerOf2# :: Integer -> (# (# #) | GHC.Prim.Word# #)
  integerIsZero :: Integer -> GHC.Types.Bool
  integerLcm :: Integer -> Integer -> Integer
  integerLe :: Integer -> Integer -> GHC.Types.Bool
  integerLe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerLog2 :: Integer -> GHC.Types.Word
  integerLog2# :: Integer -> GHC.Prim.Word#
  integerLogBase :: Integer -> Integer -> GHC.Types.Word
  integerLogBase# :: Integer -> Integer -> GHC.Prim.Word#
  integerLogBaseWord :: GHC.Types.Word -> Integer -> GHC.Types.Word
  integerLogBaseWord# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerLt :: Integer -> Integer -> GHC.Types.Bool
  integerLt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerMod :: Integer -> Integer -> Integer
  integerMul :: Integer -> Integer -> Integer
  integerNe :: Integer -> Integer -> GHC.Types.Bool
  integerNe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerNegate :: Integer -> Integer
  integerOne :: Integer
  integerOr :: Integer -> Integer -> Integer
  integerPopCount# :: Integer -> GHC.Prim.Int#
  integerPowMod# :: Integer -> Integer -> GHC.Num.Natural.Natural -> (# GHC.Num.Natural.Natural | () #)
  integerQuot :: Integer -> Integer -> Integer
  integerQuotRem :: Integer -> Integer -> (Integer, Integer)
  integerQuotRem# :: Integer -> Integer -> (# Integer, Integer #)
  integerRecipMod# :: Integer -> GHC.Num.Natural.Natural -> (# GHC.Num.Natural.Natural | () #)
  integerRem :: Integer -> Integer -> Integer
  integerShiftL :: Integer -> GHC.Types.Word -> Integer
  integerShiftL# :: Integer -> GHC.Prim.Word# -> Integer
  integerShiftR :: Integer -> GHC.Types.Word -> Integer
  integerShiftR# :: Integer -> GHC.Prim.Word# -> Integer
  integerSignum :: Integer -> Integer
  integerSignum# :: Integer -> GHC.Prim.Int#
  integerSizeInBase# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerSqr :: Integer -> Integer
  integerSub :: Integer -> Integer -> Integer
  integerTestBit :: Integer -> GHC.Types.Word -> GHC.Types.Bool
  integerTestBit# :: Integer -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  integerToAddr :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToAddr# :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToBigNatClamp# :: Integer -> GHC.Num.BigNat.BigNat#
  integerToBigNatSign# :: Integer -> (# GHC.Prim.Int#, GHC.Num.BigNat.BigNat# #)
  integerToInt :: Integer -> GHC.Types.Int
  integerToInt# :: Integer -> GHC.Prim.Int#
  integerToInt64# :: Integer -> GHC.Prim.Int64#
  integerToMutableByteArray :: Integer -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToMutableByteArray# :: Integer -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToNatural :: Integer -> GHC.Num.Natural.Natural
  integerToNaturalClamp :: Integer -> GHC.Num.Natural.Natural
  integerToNaturalThrow :: Integer -> GHC.Num.Natural.Natural
  integerToWord :: Integer -> GHC.Types.Word
  integerToWord# :: Integer -> GHC.Prim.Word#
  integerToWord64# :: Integer -> GHC.Prim.Word64#
  integerXor :: Integer -> Integer -> Integer
  integerZero :: Integer

module GHC.Num.Natural where
  NB :: GHC.Prim.ByteArray# -> Natural
  NS :: GHC.Prim.Word# -> Natural
  type Natural :: *
  data Natural = ...
  naturalAdd :: Natural -> Natural -> Natural
  naturalAnd :: Natural -> Natural -> Natural
  naturalAndNot :: Natural -> Natural -> Natural
  naturalBit :: GHC.Types.Word -> Natural
  naturalBit# :: GHC.Prim.Word# -> Natural
  naturalCheck :: Natural -> GHC.Types.Bool
  naturalCheck# :: Natural -> GHC.Num.Primitives.Bool#
  naturalClearBit :: Natural -> GHC.Types.Word -> Natural
  naturalClearBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalCompare :: Natural -> Natural -> GHC.Types.Ordering
  naturalComplementBit :: Natural -> GHC.Types.Word -> Natural
  naturalComplementBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalEncodeDouble# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Double#
  naturalEncodeFloat# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Float#
  naturalEq :: Natural -> Natural -> GHC.Types.Bool
  naturalEq# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Natural
  naturalFromAddr# :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromBigNat# :: GHC.Num.BigNat.BigNat# -> Natural
  naturalFromByteArray# :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromWord :: GHC.Types.Word -> Natural
  naturalFromWord# :: GHC.Prim.Word# -> Natural
  naturalFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> Natural
  naturalFromWordList :: [GHC.Types.Word] -> Natural
  naturalGcd :: Natural -> Natural -> Natural
  naturalGe :: Natural -> Natural -> GHC.Types.Bool
  naturalGe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalGt :: Natural -> Natural -> GHC.Types.Bool
  naturalGt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalIsOne :: Natural -> GHC.Types.Bool
  naturalIsPowerOf2# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalIsZero :: Natural -> GHC.Types.Bool
  naturalLcm :: Natural -> Natural -> Natural
  naturalLe :: Natural -> Natural -> GHC.Types.Bool
  naturalLe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalLog2 :: Natural -> GHC.Types.Word
  naturalLog2# :: Natural -> GHC.Prim.Word#
  naturalLogBase :: Natural -> Natural -> GHC.Types.Word
  naturalLogBase# :: Natural -> Natural -> GHC.Prim.Word#
  naturalLogBaseWord :: GHC.Types.Word -> Natural -> GHC.Types.Word
  naturalLogBaseWord# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalLt :: Natural -> Natural -> GHC.Types.Bool
  naturalLt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalMul :: Natural -> Natural -> Natural
  naturalNe :: Natural -> Natural -> GHC.Types.Bool
  naturalNe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalNegate :: Natural -> Natural
  naturalOne :: Natural
  naturalOr :: Natural -> Natural -> Natural
  naturalPopCount :: Natural -> GHC.Types.Word
  naturalPopCount# :: Natural -> GHC.Prim.Word#
  naturalPowMod :: Natural -> Natural -> Natural -> Natural
  naturalQuot :: Natural -> Natural -> Natural
  naturalQuotRem :: Natural -> Natural -> (Natural, Natural)
  naturalQuotRem# :: Natural -> Natural -> (# Natural, Natural #)
  naturalRem :: Natural -> Natural -> Natural
  naturalSetBit :: Natural -> GHC.Types.Word -> Natural
  naturalSetBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftL :: Natural -> GHC.Types.Word -> Natural
  naturalShiftL# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftR :: Natural -> GHC.Types.Word -> Natural
  naturalShiftR# :: Natural -> GHC.Prim.Word# -> Natural
  naturalSignum :: Natural -> Natural
  naturalSizeInBase# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalSqr :: Natural -> Natural
  naturalSub :: Natural -> Natural -> (# (# #) | Natural #)
  naturalSubThrow :: Natural -> Natural -> Natural
  naturalSubUnsafe :: Natural -> Natural -> Natural
  naturalTestBit :: Natural -> GHC.Types.Word -> GHC.Types.Bool
  naturalTestBit# :: Natural -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  naturalToAddr :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  naturalToAddr# :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToBigNat# :: Natural -> GHC.Num.BigNat.BigNat#
  naturalToMutableByteArray# :: Natural -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWord# :: Natural -> GHC.Prim.Word#
  naturalToWordClamp :: Natural -> GHC.Types.Word
  naturalToWordClamp# :: Natural -> GHC.Prim.Word#
  naturalToWordMaybe# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalXor :: Natural -> Natural -> Natural
  naturalZero :: Natural

module GHC.OldList where
  (!!) :: GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: [a] -> [a] -> [a]
  (\\) :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  all :: (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  and :: [GHC.Types.Bool] -> GHC.Types.Bool
  any :: (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  break :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  concat :: [[a]] -> [a]
  concatMap :: (a -> [b]) -> [a] -> [b]
  cycle :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  delete :: GHC.Classes.Eq a => a -> [a] -> [a]
  deleteBy :: (a -> a -> GHC.Types.Bool) -> a -> [a] -> [a]
  deleteFirstsBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  drop :: GHC.Types.Int -> [a] -> [a]
  dropWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  dropWhileEnd :: (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  elemIndex :: GHC.Classes.Eq a => a -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: GHC.Classes.Eq a => a -> [a] -> [GHC.Types.Int]
  filter :: (a -> GHC.Types.Bool) -> [a] -> [a]
  find :: (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe a
  findIndex :: (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: (a -> GHC.Types.Bool) -> [a] -> [GHC.Types.Int]
  foldl :: (b -> a -> b) -> b -> [a] -> b
  foldl' :: (b -> a -> b) -> b -> [a] -> b
  foldl1 :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldl1' :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr1 :: GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  genericDrop :: GHC.Real.Integral i => i -> [a] -> [a]
  genericIndex :: GHC.Real.Integral i => [a] -> i -> a
  genericLength :: GHC.Num.Num i => [a] -> i
  genericReplicate :: GHC.Real.Integral i => i -> a -> [a]
  genericSplitAt :: GHC.Real.Integral i => i -> [a] -> ([a], [a])
  genericTake :: GHC.Real.Integral i => i -> [a] -> [a]
  group :: GHC.Classes.Eq a => [a] -> [[a]]
  groupBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [[a]]
  head :: GHC.Stack.Types.HasCallStack => [a] -> a
  init :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  inits :: [a] -> [[a]]
  insert :: GHC.Classes.Ord a => a -> [a] -> [a]
  insertBy :: (a -> a -> GHC.Types.Ordering) -> a -> [a] -> [a]
  intercalate :: [a] -> [[a]] -> [a]
  intersect :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  intersectBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  intersperse :: a -> [a] -> [a]
  isInfixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isPrefixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSuffixOf :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  iterate :: (a -> a) -> a -> [a]
  iterate' :: (a -> a) -> a -> [a]
  last :: GHC.Stack.Types.HasCallStack => [a] -> a
  length :: [a] -> GHC.Types.Int
  lines :: GHC.Base.String -> [GHC.Base.String]
  lookup :: GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: (a -> b) -> [a] -> [b]
  mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
  mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
  maximum :: (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  maximumBy :: (a -> a -> GHC.Types.Ordering) -> [a] -> a
  minimum :: (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  minimumBy :: (a -> a -> GHC.Types.Ordering) -> [a] -> a
  notElem :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  nub :: GHC.Classes.Eq a => [a] -> [a]
  nubBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  null :: [a] -> GHC.Types.Bool
  or :: [GHC.Types.Bool] -> GHC.Types.Bool
  partition :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  permutations :: [a] -> [[a]]
  product :: GHC.Num.Num a => [a] -> a
  repeat :: a -> [a]
  replicate :: GHC.Types.Int -> a -> [a]
  reverse :: [a] -> [a]
  scanl :: (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: (a -> a -> a) -> [a] -> [a]
  scanr :: (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: (a -> a -> a) -> [a] -> [a]
  singleton :: a -> [a]
  sort :: GHC.Classes.Ord a => [a] -> [a]
  sortBy :: (a -> a -> GHC.Types.Ordering) -> [a] -> [a]
  sortOn :: GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  span :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: GHC.Types.Int -> [a] -> ([a], [a])
  stripPrefix :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Maybe.Maybe [a]
  subsequences :: [a] -> [[a]]
  sum :: GHC.Num.Num a => [a] -> a
  tail :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  tails :: [a] -> [[a]]
  take :: GHC.Types.Int -> [a] -> [a]
  takeWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
  transpose :: [[a]] -> [[a]]
  uncons :: [a] -> GHC.Maybe.Maybe (a, [a])
  unfoldr :: (b -> GHC.Maybe.Maybe (a, b)) -> b -> [a]
  union :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  unionBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  unlines :: [GHC.Base.String] -> GHC.Base.String
  unwords :: [GHC.Base.String] -> GHC.Base.String
  unzip :: [(a, b)] -> ([a], [b])
  unzip3 :: [(a, b, c)] -> ([a], [b], [c])
  unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
  unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
  unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
  unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
  words :: GHC.Base.String -> [GHC.Base.String]
  zip :: [a] -> [b] -> [(a, b)]
  zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
  zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
  zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
  zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
  zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
  zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
  zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
  zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
  zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

module GHC.OverloadedLabels where
  type IsLabel :: GHC.Types.Symbol -> * -> Constraint
  class IsLabel x a
    ...
  fromLabel :: IsLabel x a => a

module GHC.Pack where
  packCString# :: [GHC.Types.Char] -> GHC.Prim.ByteArray#
  unpackAppendCString# :: GHC.Prim.Addr# -> [GHC.Types.Char] -> [GHC.Types.Char]
  unpackCString :: GHC.Ptr.Ptr a -> [GHC.Types.Char]
  unpackCString# :: GHC.Prim.Addr# -> [GHC.Types.Char]
  unpackFoldrCString# :: GHC.Prim.Addr# -> (GHC.Types.Char -> a -> a) -> a -> a
  unpackNBytes# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> [GHC.Types.Char]

module GHC.Profiling where
  requestHeapCensus :: GHC.Types.IO ()
  startHeapProfTimer :: GHC.Types.IO ()
  startProfTimer :: GHC.Types.IO ()
  stopHeapProfTimer :: GHC.Types.IO ()
  stopProfTimer :: GHC.Types.IO ()

module GHC.Ptr where
  FunPtr :: GHC.Prim.Addr# -> FunPtr a
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  Ptr :: GHC.Prim.Addr# -> Ptr a
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  alignPtr :: Ptr a -> GHC.Types.Int -> Ptr a
  castFunPtr :: FunPtr a -> FunPtr b
  castFunPtrToPtr :: FunPtr a -> Ptr b
  castPtr :: Ptr a -> Ptr b
  castPtrToFunPtr :: Ptr a -> FunPtr b
  minusPtr :: Ptr a -> Ptr b -> GHC.Types.Int
  nullFunPtr :: FunPtr a
  nullPtr :: Ptr a
  plusPtr :: Ptr a -> GHC.Types.Int -> Ptr b

module GHC.RTS.Flags where
  CCFlags :: DoCostCentres -> GHC.Types.Int -> GHC.Types.Int -> CCFlags
  type CCFlags :: *
  data CCFlags = ...
  CollectGCStats :: GiveGCStats
  ConcFlags :: RtsTime -> GHC.Types.Int -> ConcFlags
  type ConcFlags :: *
  data ConcFlags = ...
  CostCentresAll :: DoCostCentres
  CostCentresJSON :: DoCostCentres
  CostCentresNone :: DoCostCentres
  CostCentresSummary :: DoCostCentres
  CostCentresVerbose :: DoCostCentres
  DebugFlags :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> DebugFlags
  type DebugFlags :: *
  data DebugFlags = ...
  type DoCostCentres :: *
  data DoCostCentres = ...
  type DoHeapProfile :: *
  data DoHeapProfile = ...
  type DoTrace :: *
  data DoTrace = ...
  GCFlags :: GHC.Maybe.Maybe GHC.IO.FilePath -> GiveGCStats -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Types.Bool -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double -> GHC.Word.Word32 -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Double -> GHC.Types.Bool -> GHC.Types.Bool -> RtsTime -> GHC.Types.Bool -> GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Bool -> GHC.Types.Word -> GCFlags
  type GCFlags :: *
  data GCFlags = ...
  type GiveGCStats :: *
  data GiveGCStats = ...
  HeapByCCS :: DoHeapProfile
  HeapByClosureType :: DoHeapProfile
  HeapByDescr :: DoHeapProfile
  HeapByInfoTable :: DoHeapProfile
  HeapByLDV :: DoHeapProfile
  HeapByMod :: DoHeapProfile
  HeapByRetainer :: DoHeapProfile
  HeapByType :: DoHeapProfile
  IoNative :: IoSubSystem
  IoPOSIX :: IoSubSystem
  type IoSubSystem :: *
  data IoSubSystem = ...
  MiscFlags :: RtsTime -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Word -> IoSubSystem -> GHC.Word.Word32 -> MiscFlags
  type MiscFlags :: *
  data MiscFlags = ...
  NoGCStats :: GiveGCStats
  NoHeapProfiling :: DoHeapProfile
  OneLineGCStats :: GiveGCStats
  ParFlags :: GHC.Word.Word32 -> GHC.Types.Bool -> GHC.Word.Word32 -> GHC.Types.Bool -> GHC.Word.Word32 -> GHC.Types.Bool -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Types.Bool -> ParFlags
  type ParFlags :: *
  data ParFlags = ...
  ProfFlags :: DoHeapProfile -> RtsTime -> GHC.Types.Word -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Word -> GHC.Types.Word -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> GHC.Maybe.Maybe GHC.Base.String -> ProfFlags
  type ProfFlags :: *
  data ProfFlags = ...
  RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> ParFlags -> RTSFlags
  type RTSFlags :: *
  data RTSFlags = ...
  type RtsTime :: *
  type RtsTime = GHC.Word.Word64
  SummaryGCStats :: GiveGCStats
  TickyFlags :: GHC.Types.Bool -> GHC.Maybe.Maybe GHC.IO.FilePath -> TickyFlags
  type TickyFlags :: *
  data TickyFlags = ...
  TraceEventLog :: DoTrace
  TraceFlags :: DoTrace -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool -> TraceFlags
  type TraceFlags :: *
  data TraceFlags = ...
  TraceNone :: DoTrace
  TraceStderr :: DoTrace
  VerboseGCStats :: GiveGCStats
  allocLimitGrace :: GCFlags -> GHC.Types.Word
  apply :: DebugFlags -> GHC.Types.Bool
  bioSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  block_alloc :: DebugFlags -> GHC.Types.Bool
  ccSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  ccsLength :: ProfFlags -> GHC.Types.Word
  ccsSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  compact :: GCFlags -> GHC.Types.Bool
  compactThreshold :: GCFlags -> GHC.Types.Double
  concurrentFlags :: RTSFlags -> ConcFlags
  costCentreFlags :: RTSFlags -> CCFlags
  ctxtSwitchTicks :: ConcFlags -> GHC.Types.Int
  ctxtSwitchTime :: ConcFlags -> RtsTime
  debugFlags :: RTSFlags -> DebugFlags
  descrSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  disableDelayedOsMemoryReturn :: MiscFlags -> GHC.Types.Bool
  doCostCentres :: CCFlags -> DoCostCentres
  doHeapProfile :: ProfFlags -> DoHeapProfile
  doIdleGC :: GCFlags -> GHC.Types.Bool
  gc :: DebugFlags -> GHC.Types.Bool
  gcFlags :: RTSFlags -> GCFlags
  gccafs :: DebugFlags -> GHC.Types.Bool
  generateCrashDumpFile :: MiscFlags -> GHC.Types.Bool
  generateStackTrace :: MiscFlags -> GHC.Types.Bool
  generations :: GCFlags -> GHC.Word.Word32
  getCCFlags :: GHC.Types.IO CCFlags
  getConcFlags :: GHC.Types.IO ConcFlags
  getDebugFlags :: GHC.Types.IO DebugFlags
  getGCFlags :: GHC.Types.IO GCFlags
  getIoManagerFlag :: GHC.Types.IO IoSubSystem
  getMiscFlags :: GHC.Types.IO MiscFlags
  getParFlags :: GHC.Types.IO ParFlags
  getProfFlags :: GHC.Types.IO ProfFlags
  getRTSFlags :: GHC.Types.IO RTSFlags
  getTickyFlags :: GHC.Types.IO TickyFlags
  getTraceFlags :: GHC.Types.IO TraceFlags
  giveStats :: GCFlags -> GiveGCStats
  heapBase :: GCFlags -> GHC.Types.Word
  heapProfileInterval :: ProfFlags -> RtsTime
  heapProfileIntervalTicks :: ProfFlags -> GHC.Types.Word
  heapSizeSuggestion :: GCFlags -> GHC.Word.Word32
  heapSizeSuggestionAuto :: GCFlags -> GHC.Types.Bool
  hpc :: DebugFlags -> GHC.Types.Bool
  idleGCDelayTime :: GCFlags -> RtsTime
  initialStkSize :: GCFlags -> GHC.Word.Word32
  installSEHHandlers :: MiscFlags -> GHC.Types.Bool
  installSignalHandlers :: MiscFlags -> GHC.Types.Bool
  internalCounters :: MiscFlags -> GHC.Types.Bool
  interpreter :: DebugFlags -> GHC.Types.Bool
  ioManager :: MiscFlags -> IoSubSystem
  largeAllocLim :: GCFlags -> GHC.Word.Word32
  linker :: DebugFlags -> GHC.Types.Bool
  linkerAlwaysPic :: MiscFlags -> GHC.Types.Bool
  linkerMemBase :: MiscFlags -> GHC.Types.Word
  machineReadable :: MiscFlags -> GHC.Types.Bool
  maxHeapSize :: GCFlags -> GHC.Word.Word32
  maxLocalSparks :: ParFlags -> GHC.Word.Word32
  maxRetainerSetSize :: ProfFlags -> GHC.Types.Word
  maxStkSize :: GCFlags -> GHC.Word.Word32
  migrate :: ParFlags -> GHC.Types.Bool
  minAllocAreaSize :: GCFlags -> GHC.Word.Word32
  minOldGenSize :: GCFlags -> GHC.Word.Word32
  miscFlags :: RTSFlags -> MiscFlags
  modSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  msecsPerTick :: CCFlags -> GHC.Types.Int
  nCapabilities :: ParFlags -> GHC.Word.Word32
  nonmoving_gc :: DebugFlags -> GHC.Types.Bool
  numIoWorkerThreads :: MiscFlags -> GHC.Word.Word32
  numa :: GCFlags -> GHC.Types.Bool
  numaMask :: GCFlags -> GHC.Types.Word
  nurseryChunkSize :: GCFlags -> GHC.Word.Word32
  oldGenFactor :: GCFlags -> GHC.Types.Double
  parFlags :: RTSFlags -> ParFlags
  parGcEnabled :: ParFlags -> GHC.Types.Bool
  parGcGen :: ParFlags -> GHC.Word.Word32
  parGcLoadBalancingEnabled :: ParFlags -> GHC.Types.Bool
  parGcLoadBalancingGen :: ParFlags -> GHC.Word.Word32
  parGcNoSyncWithIdle :: ParFlags -> GHC.Word.Word32
  parGcThreads :: ParFlags -> GHC.Word.Word32
  pcFreeHeap :: GCFlags -> GHC.Types.Double
  prof :: DebugFlags -> GHC.Types.Bool
  profilerTicks :: CCFlags -> GHC.Types.Int
  profilingFlags :: RTSFlags -> ProfFlags
  retainerSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  returnDecayFactor :: GCFlags -> GHC.Types.Double
  ringBell :: GCFlags -> GHC.Types.Bool
  sanity :: DebugFlags -> GHC.Types.Bool
  scheduler :: DebugFlags -> GHC.Types.Bool
  setAffinity :: ParFlags -> GHC.Types.Bool
  showCCSOnException :: ProfFlags -> GHC.Types.Bool
  showTickyStats :: TickyFlags -> GHC.Types.Bool
  sparks :: DebugFlags -> GHC.Types.Bool
  sparksFull :: TraceFlags -> GHC.Types.Bool
  sparksSampled :: TraceFlags -> GHC.Types.Bool
  squeeze :: DebugFlags -> GHC.Types.Bool
  squeezeUpdFrames :: GCFlags -> GHC.Types.Bool
  stable :: DebugFlags -> GHC.Types.Bool
  startHeapProfileAtStartup :: ProfFlags -> GHC.Types.Bool
  statsFile :: GCFlags -> GHC.Maybe.Maybe GHC.IO.FilePath
  stkChunkBufferSize :: GCFlags -> GHC.Word.Word32
  stkChunkSize :: GCFlags -> GHC.Word.Word32
  stm :: DebugFlags -> GHC.Types.Bool
  sweep :: GCFlags -> GHC.Types.Bool
  tickInterval :: MiscFlags -> RtsTime
  tickyFile :: TickyFlags -> GHC.Maybe.Maybe GHC.IO.FilePath
  tickyFlags :: RTSFlags -> TickyFlags
  timestamp :: TraceFlags -> GHC.Types.Bool
  traceFlags :: RTSFlags -> TraceFlags
  traceGc :: TraceFlags -> GHC.Types.Bool
  traceNonmovingGc :: TraceFlags -> GHC.Types.Bool
  traceScheduler :: TraceFlags -> GHC.Types.Bool
  tracing :: TraceFlags -> DoTrace
  typeSelector :: ProfFlags -> GHC.Maybe.Maybe GHC.Base.String
  user :: TraceFlags -> GHC.Types.Bool
  weak :: DebugFlags -> GHC.Types.Bool

module GHC.Read where
  type Read :: * -> Constraint
  class Read a
    ...
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  choose :: [(GHC.Base.String, Text.ParserCombinators.ReadPrec.ReadPrec a)] -> Text.ParserCombinators.ReadPrec.ReadPrec a
  expectP :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadPrec.ReadPrec ()
  lex :: ReadS GHC.Base.String
  lexDigits :: ReadS GHC.Base.String
  lexLitChar :: ReadS GHC.Base.String
  lexP :: Text.ParserCombinators.ReadPrec.ReadPrec Text.Read.Lex.Lexeme
  list :: Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
  paren :: Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  parens :: Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readField :: GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readFieldHash :: GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readList :: Read a => ReadS [a]
  readListDefault :: Read a => ReadS [a]
  readListPrec :: Read a => Text.ParserCombinators.ReadPrec.ReadPrec [a]
  readListPrecDefault :: Read a => Text.ParserCombinators.ReadPrec.ReadPrec [a]
  readLitChar :: ReadS GHC.Types.Char
  readNumber :: GHC.Num.Num a => (Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadPrec.ReadPrec a) -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readParen :: GHC.Types.Bool -> ReadS a -> ReadS a
  readPrec :: Read a => Text.ParserCombinators.ReadPrec.ReadPrec a
  readSymField :: GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readsPrec :: Read a => GHC.Types.Int -> ReadS a

module GHC.Real where
  (%) :: Integral a => a -> a -> Ratio a
  (/) :: Fractional a => a -> a -> a
  (:%) :: a -> a -> Ratio a
  Base10 :: FractionalExponentBase
  Base2 :: FractionalExponentBase
  type Fractional :: * -> Constraint
  class GHC.Num.Num a => Fractional a
    ...
  type FractionalExponentBase :: *
  data FractionalExponentBase = ...
  type Integral :: * -> Constraint
  class (Real a, GHC.Enum.Enum a) => Integral a
    ...
  type Ratio :: * -> *
  data Ratio a = ...
  type Rational :: *
  type Rational = Ratio GHC.Num.Integer.Integer
  type Real :: * -> Constraint
  class (GHC.Num.Num a, GHC.Classes.Ord a) => Real a
    ...
  type RealFrac :: * -> Constraint
  class (Real a, Fractional a) => RealFrac a
    ...
  (^) :: (GHC.Num.Num a, Integral b) => a -> b -> a
  (^%^) :: Integral a => Rational -> a -> Rational
  (^^) :: (Fractional a, Integral b) => a -> b -> a
  (^^%^^) :: Integral a => Rational -> a -> Rational
  ceiling :: (RealFrac a, Integral b) => a -> b
  denominator :: Ratio a -> a
  div :: Integral a => a -> a -> a
  divMod :: Integral a => a -> a -> (a, a)
  divZeroError :: a
  even :: Integral a => a -> GHC.Types.Bool
  floor :: (RealFrac a, Integral b) => a -> b
  fromIntegral :: (Integral a, GHC.Num.Num b) => a -> b
  fromRational :: Fractional a => Rational -> a
  gcd :: Integral a => a -> a -> a
  infinity :: Rational
  integralEnumFrom :: (Integral a, GHC.Enum.Bounded a) => a -> [a]
  integralEnumFromThen :: (Integral a, GHC.Enum.Bounded a) => a -> a -> [a]
  integralEnumFromThenTo :: Integral a => a -> a -> a -> [a]
  integralEnumFromTo :: Integral a => a -> a -> [a]
  lcm :: Integral a => a -> a -> a
  mkRationalBase10 :: Rational -> GHC.Num.Integer.Integer -> Rational
  mkRationalBase2 :: Rational -> GHC.Num.Integer.Integer -> Rational
  mkRationalWithExponentBase :: Rational -> GHC.Num.Integer.Integer -> FractionalExponentBase -> Rational
  mod :: Integral a => a -> a -> a
  notANumber :: Rational
  numerator :: Ratio a -> a
  numericEnumFrom :: Fractional a => a -> [a]
  numericEnumFromThen :: Fractional a => a -> a -> [a]
  numericEnumFromThenTo :: (GHC.Classes.Ord a, Fractional a) => a -> a -> a -> [a]
  numericEnumFromTo :: (GHC.Classes.Ord a, Fractional a) => a -> a -> [a]
  odd :: Integral a => a -> GHC.Types.Bool
  overflowError :: a
  powImpl :: (GHC.Num.Num a, Integral b) => a -> b -> a
  powImplAcc :: (GHC.Num.Num a, Integral b) => a -> b -> a -> a
  properFraction :: (RealFrac a, Integral b) => a -> (b, a)
  quot :: Integral a => a -> a -> a
  quotRem :: Integral a => a -> a -> (a, a)
  ratioPrec :: GHC.Types.Int
  ratioPrec1 :: GHC.Types.Int
  ratioZeroDenominatorError :: a
  realToFrac :: (Real a, Fractional b) => a -> b
  recip :: Fractional a => a -> a
  reduce :: Integral a => a -> a -> Ratio a
  rem :: Integral a => a -> a -> a
  round :: (RealFrac a, Integral b) => a -> b
  showSigned :: Real a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
  toInteger :: Integral a => a -> GHC.Num.Integer.Integer
  toRational :: Real a => a -> Rational
  truncate :: (RealFrac a, Integral b) => a -> b
  underflowError :: a

module GHC.Records where
  type HasField :: forall {k}. k -> * -> * -> Constraint
  class HasField x r a | x r -> a
    ...
  getField :: forall {k} (x :: k) r a. HasField x r a => r -> a

module GHC.ResponseFile where
  escapeArgs :: [GHC.Base.String] -> GHC.Base.String
  expandResponse :: [GHC.Base.String] -> GHC.Types.IO [GHC.Base.String]
  getArgsWithResponseFiles :: GHC.Types.IO [GHC.Base.String]
  unescapeArgs :: GHC.Base.String -> [GHC.Base.String]

module GHC.ST where
  ST :: STRep s a -> ST s a
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  type STRep :: * -> * -> *
  type STRep s a = GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
  STret :: GHC.Prim.State# s -> a -> STret s a
  type role STret nominal representational
  type STret :: * -> * -> *
  data STret s a = ...
  liftST :: ST s a -> GHC.Prim.State# s -> STret s a
  runST :: (forall s. ST s a) -> a
  unsafeDupableInterleaveST :: ST s a -> ST s a
  unsafeInterleaveST :: ST s a -> ST s a

module GHC.STRef where
  STRef :: GHC.Prim.MutVar# s a -> STRef s a
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  newSTRef :: a -> GHC.ST.ST s (STRef s a)
  readSTRef :: STRef s a -> GHC.ST.ST s a
  writeSTRef :: STRef s a -> a -> GHC.ST.ST s ()

module GHC.Show where
  type Show :: * -> Constraint
  class Show a
    ...
  type ShowS :: *
  type ShowS = GHC.Base.String -> GHC.Base.String
  appPrec :: GHC.Types.Int
  appPrec1 :: GHC.Types.Int
  asciiTab :: [GHC.Base.String]
  intToDigit :: GHC.Types.Int -> GHC.Types.Char
  protectEsc :: (GHC.Types.Char -> GHC.Types.Bool) -> ShowS -> ShowS
  show :: Show a => a -> GHC.Base.String
  showChar :: GHC.Types.Char -> ShowS
  showCommaSpace :: ShowS
  showList :: Show a => [a] -> ShowS
  showList__ :: (a -> ShowS) -> [a] -> ShowS
  showLitChar :: GHC.Types.Char -> ShowS
  showLitString :: GHC.Base.String -> ShowS
  showMultiLineString :: GHC.Base.String -> [GHC.Base.String]
  showParen :: GHC.Types.Bool -> ShowS -> ShowS
  showSignedInt :: GHC.Types.Int -> GHC.Types.Int -> ShowS
  showSpace :: ShowS
  showString :: GHC.Base.String -> ShowS
  shows :: Show a => a -> ShowS
  showsPrec :: Show a => GHC.Types.Int -> a -> ShowS

module GHC.Stable where
  StablePtr :: GHC.Prim.StablePtr# a -> StablePtr a
  type StablePtr :: * -> *
  data StablePtr a = ...
  castPtrToStablePtr :: GHC.Ptr.Ptr () -> StablePtr a
  castStablePtrToPtr :: StablePtr a -> GHC.Ptr.Ptr ()
  deRefStablePtr :: StablePtr a -> GHC.Types.IO a
  freeStablePtr :: StablePtr a -> GHC.Types.IO ()
  newStablePtr :: a -> GHC.Types.IO (StablePtr a)

module GHC.StableName where
  StableName :: GHC.Prim.StableName# a -> StableName a
  type role StableName phantom
  type StableName :: * -> *
  data StableName a = ...
  eqStableName :: StableName a -> StableName b -> GHC.Types.Bool
  hashStableName :: StableName a -> GHC.Types.Int
  makeStableName :: a -> GHC.Types.IO (StableName a)

module GHC.Stack where
  type CallStack :: *
  data CallStack = ...
  type CostCentre :: *
  data CostCentre
  type CostCentreStack :: *
  data CostCentreStack
  type HasCallStack :: Constraint
  type HasCallStack = ?callStack::CallStack :: Constraint
  SrcLoc :: [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> SrcLoc
  type SrcLoc :: *
  data SrcLoc = ...
  callStack :: HasCallStack => CallStack
  ccLabel :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccModule :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccSrcSpan :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccsCC :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentre)
  ccsParent :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  ccsToStrings :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO [GHC.Base.String]
  clearCCS :: GHC.Types.IO a -> GHC.Types.IO a
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  emptyCallStack :: CallStack
  errorWithStackTrace :: GHC.Base.String -> a
  freezeCallStack :: CallStack -> CallStack
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  getCCSOf :: a -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  getCurrentCCS :: dummy -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  popCallStack :: CallStack -> CallStack
  prettyCallStack :: CallStack -> GHC.Base.String
  prettySrcLoc :: SrcLoc -> GHC.Base.String
  pushCallStack :: ([GHC.Types.Char], SrcLoc) -> CallStack -> CallStack
  renderStack :: [GHC.Base.String] -> GHC.Base.String
  srcLocEndCol :: SrcLoc -> GHC.Types.Int
  srcLocEndLine :: SrcLoc -> GHC.Types.Int
  srcLocFile :: SrcLoc -> [GHC.Types.Char]
  srcLocModule :: SrcLoc -> [GHC.Types.Char]
  srcLocPackage :: SrcLoc -> [GHC.Types.Char]
  srcLocStartCol :: SrcLoc -> GHC.Types.Int
  srcLocStartLine :: SrcLoc -> GHC.Types.Int
  whoCreated :: a -> GHC.Types.IO [GHC.Base.String]
  withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a

module GHC.Stack.CCS where
  type CostCentre :: *
  data CostCentre
  type CostCentreStack :: *
  data CostCentreStack
  ccLabel :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccModule :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccSrcSpan :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO GHC.Foreign.CString
  ccsCC :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentre)
  ccsParent :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  ccsToStrings :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO [GHC.Base.String]
  clearCCS :: GHC.Types.IO a -> GHC.Types.IO a
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  getCCSOf :: a -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  getCurrentCCS :: dummy -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  renderStack :: [GHC.Base.String] -> GHC.Base.String
  whoCreated :: a -> GHC.Types.IO [GHC.Base.String]

module GHC.Stack.CloneStack where
  StackEntry :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Types.Word -> StackEntry
  type StackEntry :: *
  data StackEntry = ...
  StackSnapshot :: GHC.Prim.StackSnapshot# -> StackSnapshot
  type StackSnapshot :: *
  data StackSnapshot = ...
  cloneMyStack :: GHC.Types.IO StackSnapshot
  cloneThreadStack :: GHC.Conc.Sync.ThreadId -> GHC.Types.IO StackSnapshot
  closureType :: StackEntry -> GHC.Types.Word
  decode :: StackSnapshot -> GHC.Types.IO [StackEntry]
  functionName :: StackEntry -> GHC.Base.String
  moduleName :: StackEntry -> GHC.Base.String
  srcLoc :: StackEntry -> GHC.Base.String

module GHC.Stack.Types where
  type CallStack :: *
  data CallStack = ...
  EmptyCallStack :: CallStack
  FreezeCallStack :: CallStack -> CallStack
  type HasCallStack :: Constraint
  type HasCallStack = ?callStack::CallStack :: Constraint
  PushCallStack :: [GHC.Types.Char] -> SrcLoc -> CallStack -> CallStack
  SrcLoc :: [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> SrcLoc
  type SrcLoc :: *
  data SrcLoc = ...
  emptyCallStack :: CallStack
  freezeCallStack :: CallStack -> CallStack
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  pushCallStack :: ([GHC.Types.Char], SrcLoc) -> CallStack -> CallStack
  srcLocEndCol :: SrcLoc -> GHC.Types.Int
  srcLocEndLine :: SrcLoc -> GHC.Types.Int
  srcLocFile :: SrcLoc -> [GHC.Types.Char]
  srcLocModule :: SrcLoc -> [GHC.Types.Char]
  srcLocPackage :: SrcLoc -> [GHC.Types.Char]
  srcLocStartCol :: SrcLoc -> GHC.Types.Int
  srcLocStartLine :: SrcLoc -> GHC.Types.Int

module GHC.StaticPtr where
  type IsStatic :: (* -> *) -> Constraint
  class IsStatic p
    ...
  type StaticKey :: *
  type StaticKey = GHC.Fingerprint.Type.Fingerprint
  type StaticPtr :: * -> *
  data StaticPtr a = ...
  StaticPtrInfo :: GHC.Base.String -> GHC.Base.String -> (GHC.Types.Int, GHC.Types.Int) -> StaticPtrInfo
  type StaticPtrInfo :: *
  data StaticPtrInfo = ...
  deRefStaticPtr :: StaticPtr a -> a
  fromStaticPtr :: (IsStatic p, base-4.18.0.0:Data.Typeable.Internal.Typeable a) => StaticPtr a -> p a
  spInfoModuleName :: StaticPtrInfo -> GHC.Base.String
  spInfoSrcLoc :: StaticPtrInfo -> (GHC.Types.Int, GHC.Types.Int)
  spInfoUnitId :: StaticPtrInfo -> GHC.Base.String
  staticKey :: StaticPtr a -> StaticKey
  staticPtrInfo :: StaticPtr a -> StaticPtrInfo
  staticPtrKeys :: GHC.Types.IO [StaticKey]
  unsafeLookupStaticPtr :: StaticKey -> GHC.Types.IO (GHC.Maybe.Maybe (StaticPtr a))

module GHC.Stats where
  GCDetails :: GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails
  type GCDetails :: *
  data GCDetails = ...
  RTSStats :: GHC.Word.Word32 -> GHC.Word.Word32 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> GHC.Word.Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails -> RTSStats
  type RTSStats :: *
  data RTSStats = ...
  type RtsTime :: *
  type RtsTime = GHC.Int.Int64
  allocated_bytes :: RTSStats -> GHC.Word.Word64
  copied_bytes :: RTSStats -> GHC.Word.Word64
  cpu_ns :: RTSStats -> RtsTime
  cumulative_live_bytes :: RTSStats -> GHC.Word.Word64
  cumulative_par_balanced_copied_bytes :: RTSStats -> GHC.Word.Word64
  cumulative_par_max_copied_bytes :: RTSStats -> GHC.Word.Word64
  elapsed_ns :: RTSStats -> RtsTime
  gc :: RTSStats -> GCDetails
  gc_cpu_ns :: RTSStats -> RtsTime
  gc_elapsed_ns :: RTSStats -> RtsTime
  gcdetails_allocated_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_block_fragmentation_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_compact_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_copied_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_cpu_ns :: GCDetails -> RtsTime
  gcdetails_elapsed_ns :: GCDetails -> RtsTime
  gcdetails_gen :: GCDetails -> GHC.Word.Word32
  gcdetails_large_objects_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_live_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_mem_in_use_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_nonmoving_gc_sync_cpu_ns :: GCDetails -> RtsTime
  gcdetails_nonmoving_gc_sync_elapsed_ns :: GCDetails -> RtsTime
  gcdetails_par_balanced_copied_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_par_max_copied_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_slop_bytes :: GCDetails -> GHC.Word.Word64
  gcdetails_sync_elapsed_ns :: GCDetails -> RtsTime
  gcdetails_threads :: GCDetails -> GHC.Word.Word32
  gcs :: RTSStats -> GHC.Word.Word32
  getRTSStats :: GHC.Types.IO RTSStats
  getRTSStatsEnabled :: GHC.Types.IO GHC.Types.Bool
  init_cpu_ns :: RTSStats -> RtsTime
  init_elapsed_ns :: RTSStats -> RtsTime
  major_gcs :: RTSStats -> GHC.Word.Word32
  max_compact_bytes :: RTSStats -> GHC.Word.Word64
  max_large_objects_bytes :: RTSStats -> GHC.Word.Word64
  max_live_bytes :: RTSStats -> GHC.Word.Word64
  max_mem_in_use_bytes :: RTSStats -> GHC.Word.Word64
  max_slop_bytes :: RTSStats -> GHC.Word.Word64
  mutator_cpu_ns :: RTSStats -> RtsTime
  mutator_elapsed_ns :: RTSStats -> RtsTime
  nonmoving_gc_cpu_ns :: RTSStats -> RtsTime
  nonmoving_gc_elapsed_ns :: RTSStats -> RtsTime
  nonmoving_gc_max_elapsed_ns :: RTSStats -> RtsTime
  nonmoving_gc_sync_cpu_ns :: RTSStats -> RtsTime
  nonmoving_gc_sync_elapsed_ns :: RTSStats -> RtsTime
  nonmoving_gc_sync_max_elapsed_ns :: RTSStats -> RtsTime
  par_copied_bytes :: RTSStats -> GHC.Word.Word64

module GHC.Storable where
  readDoubleOffPtr :: GHC.Ptr.Ptr GHC.Types.Double -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Double
  readFloatOffPtr :: GHC.Ptr.Ptr GHC.Types.Float -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Float
  readFunPtrOffPtr :: GHC.Ptr.Ptr (GHC.Ptr.FunPtr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.FunPtr a)
  readInt16OffPtr :: GHC.Ptr.Ptr GHC.Int.Int16 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int16
  readInt32OffPtr :: GHC.Ptr.Ptr GHC.Int.Int32 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int32
  readInt64OffPtr :: GHC.Ptr.Ptr GHC.Int.Int64 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int64
  readInt8OffPtr :: GHC.Ptr.Ptr GHC.Int.Int8 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int8
  readIntOffPtr :: GHC.Ptr.Ptr GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  readPtrOffPtr :: GHC.Ptr.Ptr (GHC.Ptr.Ptr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  readStablePtrOffPtr :: GHC.Ptr.Ptr (GHC.Stable.StablePtr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Stable.StablePtr a)
  readWideCharOffPtr :: GHC.Ptr.Ptr GHC.Types.Char -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Char
  readWord16OffPtr :: GHC.Ptr.Ptr GHC.Word.Word16 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word16
  readWord32OffPtr :: GHC.Ptr.Ptr GHC.Word.Word32 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word32
  readWord64OffPtr :: GHC.Ptr.Ptr GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word64
  readWord8OffPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word8
  readWordOffPtr :: GHC.Ptr.Ptr GHC.Types.Word -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Word
  writeDoubleOffPtr :: GHC.Ptr.Ptr GHC.Types.Double -> GHC.Types.Int -> GHC.Types.Double -> GHC.Types.IO ()
  writeFloatOffPtr :: GHC.Ptr.Ptr GHC.Types.Float -> GHC.Types.Int -> GHC.Types.Float -> GHC.Types.IO ()
  writeFunPtrOffPtr :: GHC.Ptr.Ptr (GHC.Ptr.FunPtr a) -> GHC.Types.Int -> GHC.Ptr.FunPtr a -> GHC.Types.IO ()
  writeInt16OffPtr :: GHC.Ptr.Ptr GHC.Int.Int16 -> GHC.Types.Int -> GHC.Int.Int16 -> GHC.Types.IO ()
  writeInt32OffPtr :: GHC.Ptr.Ptr GHC.Int.Int32 -> GHC.Types.Int -> GHC.Int.Int32 -> GHC.Types.IO ()
  writeInt64OffPtr :: GHC.Ptr.Ptr GHC.Int.Int64 -> GHC.Types.Int -> GHC.Int.Int64 -> GHC.Types.IO ()
  writeInt8OffPtr :: GHC.Ptr.Ptr GHC.Int.Int8 -> GHC.Types.Int -> GHC.Int.Int8 -> GHC.Types.IO ()
  writeIntOffPtr :: GHC.Ptr.Ptr GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  writePtrOffPtr :: GHC.Ptr.Ptr (GHC.Ptr.Ptr a) -> GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO ()
  writeStablePtrOffPtr :: GHC.Ptr.Ptr (GHC.Stable.StablePtr a) -> GHC.Types.Int -> GHC.Stable.StablePtr a -> GHC.Types.IO ()
  writeWideCharOffPtr :: GHC.Ptr.Ptr GHC.Types.Char -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO ()
  writeWord16OffPtr :: GHC.Ptr.Ptr GHC.Word.Word16 -> GHC.Types.Int -> GHC.Word.Word16 -> GHC.Types.IO ()
  writeWord32OffPtr :: GHC.Ptr.Ptr GHC.Word.Word32 -> GHC.Types.Int -> GHC.Word.Word32 -> GHC.Types.IO ()
  writeWord64OffPtr :: GHC.Ptr.Ptr GHC.Word.Word64 -> GHC.Types.Int -> GHC.Word.Word64 -> GHC.Types.IO ()
  writeWord8OffPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Word.Word8 -> GHC.Types.IO ()
  writeWordOffPtr :: GHC.Ptr.Ptr GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word -> GHC.Types.IO ()

module GHC.TopHandler where
  flushStdHandles :: GHC.Types.IO ()
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  runIO :: GHC.Types.IO a -> GHC.Types.IO a
  runIOFastExit :: GHC.Types.IO a -> GHC.Types.IO a
  runMainIO :: GHC.Types.IO a -> GHC.Types.IO a
  runNonIO :: a -> GHC.Types.IO a
  topHandler :: GHC.Exception.Type.SomeException -> GHC.Types.IO a
  topHandlerFastExit :: GHC.Exception.Type.SomeException -> GHC.Types.IO a

module GHC.TypeError where
  (:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
  (:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
  type Assert :: GHC.Types.Bool -> Constraint -> Constraint
  type family Assert check errMsg
  type ErrorMessage :: *
  data ErrorMessage = ...
  ShowType :: t -> ErrorMessage
  Text :: GHC.Types.Symbol -> ErrorMessage
  type TypeError :: forall b. ErrorMessage -> b
  type family TypeError a

module GHC.TypeLits where
  type (*) :: Natural -> Natural -> Natural
  type family (*) a b
  type (+) :: Natural -> Natural -> Natural
  type family (+) a b
  type (-) :: Natural -> Natural -> Natural
  type family (-) a b
  (:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
  (:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = Data.Type.Ord.OrdCond (Data.Type.Ord.Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type AppendSymbol :: Symbol -> Symbol -> Symbol
  type family AppendSymbol a b
  type CharToNat :: GHC.Types.Char -> Natural
  type family CharToNat a
  type CmpChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Ordering
  type family CmpChar a b
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type CmpSymbol :: Symbol -> Symbol -> GHC.Types.Ordering
  type family CmpSymbol a b
  type ConsSymbol :: GHC.Types.Char -> Symbol -> Symbol
  type family ConsSymbol a b
  type Div :: Natural -> Natural -> Natural
  type family Div a b
  EQI :: forall {k} (a :: k). (Data.Type.Ord.Compare a a ~ GHC.Types.EQ) => OrderingI a a
  type ErrorMessage :: *
  data ErrorMessage = ...
  GTI :: forall {k} (a :: k) (b :: k). (Data.Type.Ord.Compare a b ~ GHC.Types.GT) => OrderingI a b
  type KnownChar :: GHC.Types.Char -> Constraint
  class KnownChar n
    ...
  type KnownNat :: Nat -> Constraint
  class KnownNat n
    ...
  type KnownSymbol :: Symbol -> Constraint
  class KnownSymbol n
    ...
  LTI :: forall {k} (a :: k) (b :: k). (Data.Type.Ord.Compare a b ~ GHC.Types.LT) => OrderingI a b
  type Log2 :: Natural -> Natural
  type family Log2 a
  type Mod :: Natural -> Natural -> Natural
  type family Mod a b
  type Nat :: *
  type Nat = Natural
  type NatToChar :: Natural -> GHC.Types.Char
  type family NatToChar a
  type Natural :: *
  data Natural = ...
  type role OrderingI nominal nominal
  type OrderingI :: forall {k}. k -> k -> *
  data OrderingI a b where
    ...
  pattern SChar :: () => KnownChar c => SChar c
  type role SChar phantom
  type SChar :: GHC.Types.Char -> *
  newtype SChar s = ...
  pattern SNat :: () => KnownNat n => SNat n
  type role SNat phantom
  type SNat :: Nat -> *
  newtype SNat n = ...
  pattern SSymbol :: () => KnownSymbol s => SSymbol s
  type role SSymbol phantom
  type SSymbol :: Symbol -> *
  newtype SSymbol s = ...
  ShowType :: t -> ErrorMessage
  SomeChar :: KnownChar n => Data.Proxy.Proxy n -> SomeChar
  type SomeChar :: *
  data SomeChar = ...
  SomeNat :: KnownNat n => Data.Proxy.Proxy n -> SomeNat
  type SomeNat :: *
  data SomeNat = ...
  SomeSymbol :: KnownSymbol n => Data.Proxy.Proxy n -> SomeSymbol
  type SomeSymbol :: *
  data SomeSymbol = ...
  type Symbol :: *
  data Symbol
  Text :: Symbol -> ErrorMessage
  type TypeError :: forall b. ErrorMessage -> b
  type family TypeError a
  type UnconsSymbol :: Symbol -> GHC.Maybe.Maybe (GHC.Types.Char, Symbol)
  type family UnconsSymbol a
  type (^) :: Natural -> Natural -> Natural
  type family (^) a b
  charSing :: KnownChar n => SChar n
  charVal :: KnownChar n => proxy n -> GHC.Types.Char
  charVal' :: KnownChar n => GHC.Prim.Proxy# n -> GHC.Types.Char
  cmpChar :: (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> OrderingI a b
  cmpNat :: (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b
  cmpSymbol :: (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> OrderingI a b
  fromSChar :: SChar c -> GHC.Types.Char
  fromSNat :: SNat n -> GHC.Num.Integer.Integer
  fromSSymbol :: SSymbol s -> GHC.Base.String
  natSing :: KnownNat n => SNat n
  natVal :: KnownNat n => proxy n -> GHC.Num.Integer.Integer
  natVal' :: KnownNat n => GHC.Prim.Proxy# n -> GHC.Num.Integer.Integer
  sameChar :: (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  sameNat :: (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  sameSymbol :: (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  someCharVal :: GHC.Types.Char -> SomeChar
  someNatVal :: GHC.Num.Integer.Integer -> GHC.Maybe.Maybe SomeNat
  someSymbolVal :: GHC.Base.String -> SomeSymbol
  symbolSing :: KnownSymbol n => SSymbol n
  symbolVal :: KnownSymbol n => proxy n -> GHC.Base.String
  symbolVal' :: KnownSymbol n => GHC.Prim.Proxy# n -> GHC.Base.String
  withKnownChar :: SChar c -> (KnownChar c => r) -> r
  withKnownNat :: SNat n -> (KnownNat n => r) -> r
  withKnownSymbol :: SSymbol s -> (KnownSymbol s => r) -> r
  withSomeSChar :: GHC.Types.Char -> (forall (c :: GHC.Types.Char). SChar c -> r) -> r
  withSomeSNat :: GHC.Num.Integer.Integer -> (forall (n :: Nat). GHC.Maybe.Maybe (SNat n) -> r) -> r
  withSomeSSymbol :: GHC.Base.String -> (forall (s :: Symbol). SSymbol s -> r) -> r

module GHC.TypeLits.Internal where
  type CmpChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Ordering
  type family CmpChar a b
  type CmpSymbol :: Symbol -> Symbol -> GHC.Types.Ordering
  type family CmpSymbol a b
  type Symbol :: *
  data Symbol

module GHC.TypeNats where
  type (*) :: Natural -> Natural -> Natural
  type family (*) a b
  type (+) :: Natural -> Natural -> Natural
  type family (+) a b
  type (-) :: Natural -> Natural -> Natural
  type family (-) a b
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = Data.Type.Ord.OrdCond (Data.Type.Ord.Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type Div :: Natural -> Natural -> Natural
  type family Div a b
  type KnownNat :: Nat -> Constraint
  class KnownNat n
    ...
  type Log2 :: Natural -> Natural
  type family Log2 a
  type Mod :: Natural -> Natural -> Natural
  type family Mod a b
  type Nat :: *
  type Nat = Natural
  type Natural :: *
  data Natural = ...
  pattern SNat :: () => KnownNat n => SNat n
  type role SNat phantom
  type SNat :: Nat -> *
  newtype SNat n = ...
  SomeNat :: KnownNat n => Data.Proxy.Proxy n -> SomeNat
  type SomeNat :: *
  data SomeNat = ...
  type (^) :: Natural -> Natural -> Natural
  type family (^) a b
  cmpNat :: (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Data.Type.Ord.OrderingI a b
  fromSNat :: SNat n -> Natural
  natSing :: KnownNat n => SNat n
  natVal :: KnownNat n => proxy n -> Natural
  natVal' :: KnownNat n => GHC.Prim.Proxy# n -> Natural
  sameNat :: (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  someNatVal :: Natural -> SomeNat
  withKnownNat :: SNat n -> (KnownNat n => r) -> r
  withSomeSNat :: Natural -> (forall (n :: Nat). SNat n -> r) -> r

module GHC.TypeNats.Internal where
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type Natural :: *
  data Natural = ...

module GHC.Unicode where
  ClosePunctuation :: GeneralCategory
  ConnectorPunctuation :: GeneralCategory
  Control :: GeneralCategory
  CurrencySymbol :: GeneralCategory
  DashPunctuation :: GeneralCategory
  DecimalNumber :: GeneralCategory
  EnclosingMark :: GeneralCategory
  FinalQuote :: GeneralCategory
  Format :: GeneralCategory
  type GeneralCategory :: *
  data GeneralCategory = ...
  InitialQuote :: GeneralCategory
  LetterNumber :: GeneralCategory
  LineSeparator :: GeneralCategory
  LowercaseLetter :: GeneralCategory
  MathSymbol :: GeneralCategory
  ModifierLetter :: GeneralCategory
  ModifierSymbol :: GeneralCategory
  NonSpacingMark :: GeneralCategory
  NotAssigned :: GeneralCategory
  OpenPunctuation :: GeneralCategory
  OtherLetter :: GeneralCategory
  OtherNumber :: GeneralCategory
  OtherPunctuation :: GeneralCategory
  OtherSymbol :: GeneralCategory
  ParagraphSeparator :: GeneralCategory
  PrivateUse :: GeneralCategory
  Space :: GeneralCategory
  SpacingCombiningMark :: GeneralCategory
  Surrogate :: GeneralCategory
  TitlecaseLetter :: GeneralCategory
  UppercaseLetter :: GeneralCategory
  generalCategory :: GHC.Types.Char -> GeneralCategory
  isAlpha :: GHC.Types.Char -> GHC.Types.Bool
  isAlphaNum :: GHC.Types.Char -> GHC.Types.Bool
  isAscii :: GHC.Types.Char -> GHC.Types.Bool
  isAsciiLower :: GHC.Types.Char -> GHC.Types.Bool
  isAsciiUpper :: GHC.Types.Char -> GHC.Types.Bool
  isControl :: GHC.Types.Char -> GHC.Types.Bool
  isDigit :: GHC.Types.Char -> GHC.Types.Bool
  isHexDigit :: GHC.Types.Char -> GHC.Types.Bool
  isLatin1 :: GHC.Types.Char -> GHC.Types.Bool
  isLower :: GHC.Types.Char -> GHC.Types.Bool
  isLowerCase :: GHC.Types.Char -> GHC.Types.Bool
  isOctDigit :: GHC.Types.Char -> GHC.Types.Bool
  isPrint :: GHC.Types.Char -> GHC.Types.Bool
  isPunctuation :: GHC.Types.Char -> GHC.Types.Bool
  isSpace :: GHC.Types.Char -> GHC.Types.Bool
  isSymbol :: GHC.Types.Char -> GHC.Types.Bool
  isUpper :: GHC.Types.Char -> GHC.Types.Bool
  isUpperCase :: GHC.Types.Char -> GHC.Types.Bool
  toLower :: GHC.Types.Char -> GHC.Types.Char
  toTitle :: GHC.Types.Char -> GHC.Types.Char
  toUpper :: GHC.Types.Char -> GHC.Types.Char
  unicodeVersion :: Data.Version.Version

module GHC.Weak where
  Weak :: GHC.Prim.Weak# v -> Weak v
  type Weak :: * -> *
  data Weak v = ...
  deRefWeak :: Weak v -> GHC.Types.IO (GHC.Maybe.Maybe v)
  finalize :: Weak v -> GHC.Types.IO ()
  getFinalizerExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  mkWeak :: k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak v)
  setFinalizerExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()

module GHC.Weak.Finalize where
  getFinalizerExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  runFinalizerBatch :: GHC.Types.Int -> GHC.Prim.Array# (GHC.Prim.State# GHC.Prim.RealWorld -> GHC.Prim.State# GHC.Prim.RealWorld) -> GHC.Types.IO ()
  setFinalizerExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()

module GHC.Word where
  W# :: GHC.Prim.Word# -> Word
  W16# :: GHC.Prim.Word16# -> Word16
  W32# :: GHC.Prim.Word32# -> Word32
  W64# :: GHC.Prim.Word64# -> Word64
  W8# :: GHC.Prim.Word8# -> Word8
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  eqWord :: Word -> Word -> GHC.Types.Bool
  eqWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  eqWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  eqWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  eqWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  geWord :: Word -> Word -> GHC.Types.Bool
  geWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  geWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  geWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  geWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  gtWord :: Word -> Word -> GHC.Types.Bool
  gtWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  gtWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  gtWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  gtWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  leWord :: Word -> Word -> GHC.Types.Bool
  leWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  leWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  leWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  leWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  ltWord :: Word -> Word -> GHC.Types.Bool
  ltWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  ltWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  ltWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  ltWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  neWord :: Word -> Word -> GHC.Types.Bool
  neWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  neWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  neWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  neWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  uncheckedShiftL64# :: GHC.Prim.Word64# -> GHC.Prim.Int# -> GHC.Prim.Word64#
  uncheckedShiftRL64# :: GHC.Prim.Word64# -> GHC.Prim.Int# -> GHC.Prim.Word64#

module Numeric where
  (**) :: Floating a => a -> a -> a
  type Floating :: * -> Constraint
  class GHC.Real.Fractional a => Floating a
    ...
  acos :: Floating a => a -> a
  acosh :: Floating a => a -> a
  asin :: Floating a => a -> a
  asinh :: Floating a => a -> a
  atan :: Floating a => a -> a
  atanh :: Floating a => a -> a
  cos :: Floating a => a -> a
  cosh :: Floating a => a -> a
  exp :: Floating a => a -> a
  expm1 :: Floating a => a -> a
  floatToDigits :: GHC.Float.RealFloat a => GHC.Num.Integer.Integer -> a -> ([GHC.Types.Int], GHC.Types.Int)
  fromRat :: GHC.Float.RealFloat a => GHC.Real.Rational -> a
  lexDigits :: Text.ParserCombinators.ReadP.ReadS GHC.Base.String
  log :: Floating a => a -> a
  log1mexp :: Floating a => a -> a
  log1p :: Floating a => a -> a
  log1pexp :: Floating a => a -> a
  logBase :: Floating a => a -> a -> a
  pi :: Floating a => a
  readBin :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readDec :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readFloat :: GHC.Real.RealFrac a => Text.ParserCombinators.ReadP.ReadS a
  readHex :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readInt :: GHC.Num.Num a => a -> (GHC.Types.Char -> GHC.Types.Bool) -> (GHC.Types.Char -> GHC.Types.Int) -> Text.ParserCombinators.ReadP.ReadS a
  readOct :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readSigned :: GHC.Real.Real a => Text.ParserCombinators.ReadP.ReadS a -> Text.ParserCombinators.ReadP.ReadS a
  showBin :: GHC.Real.Integral a => a -> GHC.Show.ShowS
  showEFloat :: GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFFloat :: GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFFloatAlt :: GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFloat :: GHC.Float.RealFloat a => a -> GHC.Show.ShowS
  showGFloat :: GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showGFloatAlt :: GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showHFloat :: GHC.Float.RealFloat a => a -> GHC.Show.ShowS
  showHex :: GHC.Real.Integral a => a -> GHC.Show.ShowS
  showInt :: GHC.Real.Integral a => a -> GHC.Show.ShowS
  showIntAtBase :: GHC.Real.Integral a => a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
  showOct :: GHC.Real.Integral a => a -> GHC.Show.ShowS
  showSigned :: GHC.Real.Real a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
  sin :: Floating a => a -> a
  sinh :: Floating a => a -> a
  sqrt :: Floating a => a -> a
  tan :: Floating a => a -> a
  tanh :: Floating a => a -> a

module Numeric.Natural where
  type Natural :: *
  data Natural = ...
  minusNaturalMaybe :: Natural -> Natural -> GHC.Maybe.Maybe Natural

module Prelude where
  (!!) :: GHC.Stack.Types.HasCallStack => [a] -> Int -> a
  ($) :: (a -> b) -> a -> b
  ($!) :: (a -> b) -> a -> b
  (&&) :: Bool -> Bool -> Bool
  (*) :: Num a => a -> a -> a
  (**) :: Floating a => a -> a -> a
  (*>) :: Applicative f => f a -> f b -> f b
  (+) :: Num a => a -> a -> a
  (++) :: [a] -> [a] -> [a]
  (-) :: Num a => a -> a -> a
  (.) :: (b -> c) -> (a -> b) -> a -> c
  (/) :: Fractional a => a -> a -> a
  (/=) :: Eq a => a -> a -> Bool
  (<) :: Ord a => a -> a -> Bool
  (<$) :: Functor f => a -> f b -> f a
  (<$>) :: Functor f => (a -> b) -> f a -> f b
  (<*) :: Applicative f => f a -> f b -> f a
  (<*>) :: Applicative f => f (a -> b) -> f a -> f b
  (<=) :: Ord a => a -> a -> Bool
  (<>) :: Semigroup a => a -> a -> a
  (=<<) :: Monad m => (a -> m b) -> m a -> m b
  (==) :: Eq a => a -> a -> Bool
  (>) :: Ord a => a -> a -> Bool
  (>=) :: Ord a => a -> a -> Bool
  (>>) :: Monad m => m a -> m b -> m b
  (>>=) :: Monad m => m a -> (a -> m b) -> m b
  type Applicative :: (* -> *) -> Constraint
  class Functor f => Applicative f
    ...
  type Bool :: *
  data Bool = ...
  type Bounded :: * -> Constraint
  class Bounded a
    ...
  type Char :: *
  data Char = ...
  type Double :: *
  data Double = ...
  EQ :: Ordering
  type Either :: * -> * -> *
  data Either a b = ...
  type Enum :: * -> Constraint
  class Enum a
    ...
  type Eq :: * -> Constraint
  class Eq a
    ...
  False :: Bool
  type FilePath :: *
  type FilePath = String
  type Float :: *
  data Float = ...
  type Floating :: * -> Constraint
  class Fractional a => Floating a
    ...
  type Foldable :: (* -> *) -> Constraint
  class Foldable t
    ...
  type Fractional :: * -> Constraint
  class Num a => Fractional a
    ...
  type Functor :: (* -> *) -> Constraint
  class Functor f
    ...
  GT :: Ordering
  type IO :: * -> *
  newtype IO a = ...
  type IOError :: *
  type IOError = GHC.IO.Exception.IOException
  type Int :: *
  data Int = ...
  type Integer :: *
  data Integer = ...
  type Integral :: * -> Constraint
  class (Real a, Enum a) => Integral a
    ...
  Just :: a -> Maybe a
  LT :: Ordering
  Left :: a -> Either a b
  type Maybe :: * -> *
  data Maybe a = ...
  type Monad :: (* -> *) -> Constraint
  class Applicative m => Monad m
    ...
  type MonadFail :: (* -> *) -> Constraint
  class Monad m => MonadFail m
    ...
  type Monoid :: * -> Constraint
  class Semigroup a => Monoid a
    ...
  Nothing :: Maybe a
  type Num :: * -> Constraint
  class Num a
    ...
  type Ord :: * -> Constraint
  class Eq a => Ord a
    ...
  type Ordering :: *
  data Ordering = ...
  type Rational :: *
  type Rational = GHC.Real.Ratio Integer
  type Read :: * -> Constraint
  class Read a
    ...
  type ReadS :: * -> *
  type ReadS a = String -> [(a, String)]
  type Real :: * -> Constraint
  class (Num a, Ord a) => Real a
    ...
  type RealFloat :: * -> Constraint
  class (RealFrac a, Floating a) => RealFloat a
    ...
  type RealFrac :: * -> Constraint
  class (Real a, Fractional a) => RealFrac a
    ...
  Right :: b -> Either a b
  type Semigroup :: * -> Constraint
  class Semigroup a
    ...
  type Show :: * -> Constraint
  class Show a
    ...
  type ShowS :: *
  type ShowS = String -> String
  type String :: *
  type String = [Char]
  type Traversable :: (* -> *) -> Constraint
  class (Functor t, Foldable t) => Traversable t
    ...
  True :: Bool
  type Word :: *
  data Word = ...
  (^) :: (Num a, Integral b) => a -> b -> a
  (^^) :: (Fractional a, Integral b) => a -> b -> a
  abs :: Num a => a -> a
  acos :: Floating a => a -> a
  acosh :: Floating a => a -> a
  all :: Foldable t => (a -> Bool) -> t a -> Bool
  and :: Foldable t => t Bool -> Bool
  any :: Foldable t => (a -> Bool) -> t a -> Bool
  appendFile :: FilePath -> String -> IO ()
  asTypeOf :: a -> a -> a
  asin :: Floating a => a -> a
  asinh :: Floating a => a -> a
  atan :: Floating a => a -> a
  atan2 :: RealFloat a => a -> a -> a
  atanh :: Floating a => a -> a
  break :: (a -> Bool) -> [a] -> ([a], [a])
  ceiling :: (RealFrac a, Integral b) => a -> b
  compare :: Ord a => a -> a -> Ordering
  concat :: Foldable t => t [a] -> [a]
  concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
  const :: a -> b -> a
  cos :: Floating a => a -> a
  cosh :: Floating a => a -> a
  curry :: ((a, b) -> c) -> a -> b -> c
  cycle :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  decodeFloat :: RealFloat a => a -> (Integer, Int)
  div :: Integral a => a -> a -> a
  divMod :: Integral a => a -> a -> (a, a)
  drop :: Int -> [a] -> [a]
  dropWhile :: (a -> Bool) -> [a] -> [a]
  either :: (a -> c) -> (b -> c) -> Either a b -> c
  elem :: (Foldable t, Eq a) => a -> t a -> Bool
  encodeFloat :: RealFloat a => Integer -> Int -> a
  enumFrom :: Enum a => a -> [a]
  enumFromThen :: Enum a => a -> a -> [a]
  enumFromThenTo :: Enum a => a -> a -> a -> [a]
  enumFromTo :: Enum a => a -> a -> [a]
  error :: GHC.Stack.Types.HasCallStack => [Char] -> a
  errorWithoutStackTrace :: [Char] -> a
  even :: Integral a => a -> Bool
  exp :: Floating a => a -> a
  exponent :: RealFloat a => a -> Int
  fail :: MonadFail m => String -> m a
  filter :: (a -> Bool) -> [a] -> [a]
  flip :: (a -> b -> c) -> b -> a -> c
  floatDigits :: RealFloat a => a -> Int
  floatRadix :: RealFloat a => a -> Integer
  floatRange :: RealFloat a => a -> (Int, Int)
  floor :: (RealFrac a, Integral b) => a -> b
  fmap :: Functor f => (a -> b) -> f a -> f b
  foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
  foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
  foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
  foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
  fromEnum :: Enum a => a -> Int
  fromInteger :: Num a => Integer -> a
  fromIntegral :: (Integral a, Num b) => a -> b
  fromRational :: Fractional a => Rational -> a
  fst :: (a, b) -> a
  gcd :: Integral a => a -> a -> a
  getChar :: IO Char
  getContents :: IO String
  getLine :: IO String
  head :: GHC.Stack.Types.HasCallStack => [a] -> a
  id :: a -> a
  init :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  interact :: (String -> String) -> IO ()
  ioError :: IOError -> IO a
  isDenormalized :: RealFloat a => a -> Bool
  isIEEE :: RealFloat a => a -> Bool
  isInfinite :: RealFloat a => a -> Bool
  isNaN :: RealFloat a => a -> Bool
  isNegativeZero :: RealFloat a => a -> Bool
  iterate :: (a -> a) -> a -> [a]
  last :: GHC.Stack.Types.HasCallStack => [a] -> a
  lcm :: Integral a => a -> a -> a
  length :: Foldable t => t a -> Int
  lex :: ReadS String
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  lines :: String -> [String]
  log :: Floating a => a -> a
  logBase :: Floating a => a -> a -> a
  lookup :: Eq a => a -> [(a, b)] -> Maybe b
  map :: (a -> b) -> [a] -> [b]
  mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
  mappend :: Monoid a => a -> a -> a
  max :: Ord a => a -> a -> a
  maxBound :: Bounded a => a
  maximum :: (Foldable t, Ord a) => t a -> a
  maybe :: b -> (a -> b) -> Maybe a -> b
  mconcat :: Monoid a => [a] -> a
  mempty :: Monoid a => a
  min :: Ord a => a -> a -> a
  minBound :: Bounded a => a
  minimum :: (Foldable t, Ord a) => t a -> a
  mod :: Integral a => a -> a -> a
  negate :: Num a => a -> a
  not :: Bool -> Bool
  notElem :: (Foldable t, Eq a) => a -> t a -> Bool
  null :: Foldable t => t a -> Bool
  odd :: Integral a => a -> Bool
  or :: Foldable t => t Bool -> Bool
  otherwise :: Bool
  pi :: Floating a => a
  pred :: Enum a => a -> a
  print :: Show a => a -> IO ()
  product :: (Foldable t, Num a) => t a -> a
  properFraction :: (RealFrac a, Integral b) => a -> (b, a)
  pure :: Applicative f => a -> f a
  putChar :: Char -> IO ()
  putStr :: String -> IO ()
  putStrLn :: String -> IO ()
  quot :: Integral a => a -> a -> a
  quotRem :: Integral a => a -> a -> (a, a)
  read :: Read a => String -> a
  readFile :: FilePath -> IO String
  readIO :: Read a => String -> IO a
  readList :: Read a => ReadS [a]
  readLn :: Read a => IO a
  readParen :: Bool -> ReadS a -> ReadS a
  reads :: Read a => ReadS a
  readsPrec :: Read a => Int -> ReadS a
  realToFrac :: (Real a, Fractional b) => a -> b
  recip :: Fractional a => a -> a
  rem :: Integral a => a -> a -> a
  repeat :: a -> [a]
  replicate :: Int -> a -> [a]
  return :: Monad m => a -> m a
  reverse :: [a] -> [a]
  round :: (RealFrac a, Integral b) => a -> b
  scaleFloat :: RealFloat a => Int -> a -> a
  scanl :: (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: (a -> a -> a) -> [a] -> [a]
  scanr :: (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: (a -> a -> a) -> [a] -> [a]
  seq :: a -> b -> b
  sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
  sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
  sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
  show :: Show a => a -> String
  showChar :: Char -> ShowS
  showList :: Show a => [a] -> ShowS
  showParen :: Bool -> ShowS -> ShowS
  showString :: String -> ShowS
  shows :: Show a => a -> ShowS
  showsPrec :: Show a => Int -> a -> ShowS
  significand :: RealFloat a => a -> a
  signum :: Num a => a -> a
  sin :: Floating a => a -> a
  sinh :: Floating a => a -> a
  snd :: (a, b) -> b
  span :: (a -> Bool) -> [a] -> ([a], [a])
  splitAt :: Int -> [a] -> ([a], [a])
  sqrt :: Floating a => a -> a
  subtract :: Num a => a -> a -> a
  succ :: Enum a => a -> a
  sum :: (Foldable t, Num a) => t a -> a
  tail :: GHC.Stack.Types.HasCallStack => [a] -> [a]
  take :: Int -> [a] -> [a]
  takeWhile :: (a -> Bool) -> [a] -> [a]
  tan :: Floating a => a -> a
  tanh :: Floating a => a -> a
  toEnum :: Enum a => Int -> a
  toInteger :: Integral a => a -> Integer
  toRational :: Real a => a -> Rational
  traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
  truncate :: (RealFrac a, Integral b) => a -> b
  uncurry :: (a -> b -> c) -> (a, b) -> c
  undefined :: GHC.Stack.Types.HasCallStack => a
  unlines :: [String] -> String
  until :: (a -> Bool) -> (a -> a) -> a -> a
  unwords :: [String] -> String
  unzip :: [(a, b)] -> ([a], [b])
  unzip3 :: [(a, b, c)] -> ([a], [b], [c])
  userError :: String -> IOError
  words :: String -> [String]
  writeFile :: FilePath -> String -> IO ()
  zip :: [a] -> [b] -> [(a, b)]
  zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
  zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  (||) :: Bool -> Bool -> Bool
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b

module System.CPUTime where
  cpuTimePrecision :: GHC.Num.Integer.Integer
  getCPUTime :: GHC.Types.IO GHC.Num.Integer.Integer

module System.Console.GetOpt where
  type ArgDescr :: * -> *
  data ArgDescr a = ...
  type ArgOrder :: * -> *
  data ArgOrder a = ...
  NoArg :: a -> ArgDescr a
  OptArg :: (GHC.Maybe.Maybe GHC.Base.String -> a) -> GHC.Base.String -> ArgDescr a
  type OptDescr :: * -> *
  data OptDescr a = ...
  Option :: [GHC.Types.Char] -> [GHC.Base.String] -> ArgDescr a -> GHC.Base.String -> OptDescr a
  Permute :: ArgOrder a
  ReqArg :: (GHC.Base.String -> a) -> GHC.Base.String -> ArgDescr a
  RequireOrder :: ArgOrder a
  ReturnInOrder :: (GHC.Base.String -> a) -> ArgOrder a
  getOpt :: ArgOrder a -> [OptDescr a] -> [GHC.Base.String] -> ([a], [GHC.Base.String], [GHC.Base.String])
  getOpt' :: ArgOrder a -> [OptDescr a] -> [GHC.Base.String] -> ([a], [GHC.Base.String], [GHC.Base.String], [GHC.Base.String])
  usageInfo :: GHC.Base.String -> [OptDescr a] -> GHC.Base.String

module System.Environment where
  executablePath :: GHC.Maybe.Maybe (GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.FilePath))
  getArgs :: GHC.Types.IO [GHC.Base.String]
  getEnv :: GHC.Base.String -> GHC.Types.IO GHC.Base.String
  getEnvironment :: GHC.Types.IO [(GHC.Base.String, GHC.Base.String)]
  getExecutablePath :: GHC.Types.IO GHC.IO.FilePath
  getProgName :: GHC.Types.IO GHC.Base.String
  lookupEnv :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  setEnv :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  unsetEnv :: GHC.Base.String -> GHC.Types.IO ()
  withArgs :: [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  withProgName :: GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a

module System.Environment.Blank where
  getArgs :: GHC.Types.IO [GHC.Base.String]
  getEnv :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  getEnvDefault :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO GHC.Base.String
  getEnvironment :: GHC.Types.IO [(GHC.Base.String, GHC.Base.String)]
  getExecutablePath :: GHC.Types.IO GHC.IO.FilePath
  getProgName :: GHC.Types.IO GHC.Base.String
  setEnv :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool -> GHC.Types.IO ()
  unsetEnv :: GHC.Base.String -> GHC.Types.IO ()
  withArgs :: [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  withProgName :: GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a

module System.Exit where
  type ExitCode :: *
  data ExitCode = ...
  ExitFailure :: GHC.Types.Int -> ExitCode
  ExitSuccess :: ExitCode
  die :: GHC.Base.String -> GHC.Types.IO a
  exitFailure :: GHC.Types.IO a
  exitSuccess :: GHC.Types.IO a
  exitWith :: ExitCode -> GHC.Types.IO a

module System.IO where
  AbsoluteSeek :: SeekMode
  AppendMode :: IOMode
  BlockBuffering :: GHC.Maybe.Maybe GHC.Types.Int -> BufferMode
  type BufferMode :: *
  data BufferMode = ...
  CRLF :: Newline
  type FilePath :: *
  type FilePath = GHC.Base.String
  type Handle :: *
  data Handle = ...
  type HandlePosn :: *
  data HandlePosn = ...
  type IO :: * -> *
  newtype IO a = ...
  type IOMode :: *
  data IOMode = ...
  LF :: Newline
  LineBuffering :: BufferMode
  type Newline :: *
  data Newline = ...
  NewlineMode :: Newline -> Newline -> NewlineMode
  type NewlineMode :: *
  data NewlineMode = ...
  NoBuffering :: BufferMode
  ReadMode :: IOMode
  ReadWriteMode :: IOMode
  RelativeSeek :: SeekMode
  SeekFromEnd :: SeekMode
  type SeekMode :: *
  data SeekMode = ...
  type TextEncoding :: *
  data TextEncoding = ...
  WriteMode :: IOMode
  appendFile :: FilePath -> GHC.Base.String -> IO ()
  char8 :: TextEncoding
  fixIO :: (a -> IO a) -> IO a
  getChar :: IO GHC.Types.Char
  getContents :: IO GHC.Base.String
  getContents' :: IO GHC.Base.String
  getLine :: IO GHC.Base.String
  hClose :: Handle -> IO ()
  hFileSize :: Handle -> IO GHC.Num.Integer.Integer
  hFlush :: Handle -> IO ()
  hGetBuf :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBufNonBlocking :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBufSome :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBuffering :: Handle -> IO BufferMode
  hGetChar :: Handle -> IO GHC.Types.Char
  hGetContents :: Handle -> IO GHC.Base.String
  hGetContents' :: Handle -> IO GHC.Base.String
  hGetEcho :: Handle -> IO GHC.Types.Bool
  hGetEncoding :: Handle -> IO (GHC.Maybe.Maybe TextEncoding)
  hGetLine :: Handle -> IO GHC.Base.String
  hGetPosn :: Handle -> IO HandlePosn
  hIsClosed :: Handle -> IO GHC.Types.Bool
  hIsEOF :: Handle -> IO GHC.Types.Bool
  hIsOpen :: Handle -> IO GHC.Types.Bool
  hIsReadable :: Handle -> IO GHC.Types.Bool
  hIsSeekable :: Handle -> IO GHC.Types.Bool
  hIsTerminalDevice :: Handle -> IO GHC.Types.Bool
  hIsWritable :: Handle -> IO GHC.Types.Bool
  hLookAhead :: Handle -> IO GHC.Types.Char
  hPrint :: GHC.Show.Show a => Handle -> a -> IO ()
  hPutBuf :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO ()
  hPutBufNonBlocking :: Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hPutChar :: Handle -> GHC.Types.Char -> IO ()
  hPutStr :: Handle -> GHC.Base.String -> IO ()
  hPutStrLn :: Handle -> GHC.Base.String -> IO ()
  hReady :: Handle -> IO GHC.Types.Bool
  hSeek :: Handle -> SeekMode -> GHC.Num.Integer.Integer -> IO ()
  hSetBinaryMode :: Handle -> GHC.Types.Bool -> IO ()
  hSetBuffering :: Handle -> BufferMode -> IO ()
  hSetEcho :: Handle -> GHC.Types.Bool -> IO ()
  hSetEncoding :: Handle -> TextEncoding -> IO ()
  hSetFileSize :: Handle -> GHC.Num.Integer.Integer -> IO ()
  hSetNewlineMode :: Handle -> NewlineMode -> IO ()
  hSetPosn :: HandlePosn -> IO ()
  hShow :: Handle -> IO GHC.Base.String
  hTell :: Handle -> IO GHC.Num.Integer.Integer
  hWaitForInput :: Handle -> GHC.Types.Int -> IO GHC.Types.Bool
  inputNL :: NewlineMode -> Newline
  interact :: (GHC.Base.String -> GHC.Base.String) -> IO ()
  isEOF :: IO GHC.Types.Bool
  latin1 :: TextEncoding
  localeEncoding :: TextEncoding
  mkTextEncoding :: GHC.Base.String -> IO TextEncoding
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  openBinaryFile :: FilePath -> IOMode -> IO Handle
  openBinaryTempFile :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openBinaryTempFileWithDefaultPermissions :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openFile :: FilePath -> IOMode -> IO Handle
  openTempFile :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openTempFileWithDefaultPermissions :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  outputNL :: NewlineMode -> Newline
  print :: GHC.Show.Show a => a -> IO ()
  putChar :: GHC.Types.Char -> IO ()
  putStr :: GHC.Base.String -> IO ()
  putStrLn :: GHC.Base.String -> IO ()
  readFile :: FilePath -> IO GHC.Base.String
  readFile' :: FilePath -> IO GHC.Base.String
  readIO :: GHC.Read.Read a => GHC.Base.String -> IO a
  readLn :: GHC.Read.Read a => IO a
  stderr :: Handle
  stdin :: Handle
  stdout :: Handle
  universalNewlineMode :: NewlineMode
  utf16 :: TextEncoding
  utf16be :: TextEncoding
  utf16le :: TextEncoding
  utf32 :: TextEncoding
  utf32be :: TextEncoding
  utf32le :: TextEncoding
  utf8 :: TextEncoding
  utf8_bom :: TextEncoding
  withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
  withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
  writeFile :: FilePath -> GHC.Base.String -> IO ()

module System.IO.Error where
  type IOError :: *
  type IOError = GHC.IO.Exception.IOException
  type IOErrorType :: *
  data IOErrorType = ...
  alreadyExistsErrorType :: IOErrorType
  alreadyInUseErrorType :: IOErrorType
  annotateIOError :: IOError -> GHC.Base.String -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.IO.FilePath -> IOError
  catchIOError :: GHC.Types.IO a -> (IOError -> GHC.Types.IO a) -> GHC.Types.IO a
  doesNotExistErrorType :: IOErrorType
  eofErrorType :: IOErrorType
  fullErrorType :: IOErrorType
  illegalOperationErrorType :: IOErrorType
  ioError :: IOError -> GHC.Types.IO a
  ioeGetErrorString :: IOError -> GHC.Base.String
  ioeGetErrorType :: IOError -> IOErrorType
  ioeGetFileName :: IOError -> GHC.Maybe.Maybe GHC.IO.FilePath
  ioeGetHandle :: IOError -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle
  ioeGetLocation :: IOError -> GHC.Base.String
  ioeSetErrorString :: IOError -> GHC.Base.String -> IOError
  ioeSetErrorType :: IOError -> IOErrorType -> IOError
  ioeSetFileName :: IOError -> GHC.IO.FilePath -> IOError
  ioeSetHandle :: IOError -> GHC.IO.Handle.Types.Handle -> IOError
  ioeSetLocation :: IOError -> GHC.Base.String -> IOError
  isAlreadyExistsError :: IOError -> GHC.Types.Bool
  isAlreadyExistsErrorType :: IOErrorType -> GHC.Types.Bool
  isAlreadyInUseError :: IOError -> GHC.Types.Bool
  isAlreadyInUseErrorType :: IOErrorType -> GHC.Types.Bool
  isDoesNotExistError :: IOError -> GHC.Types.Bool
  isDoesNotExistErrorType :: IOErrorType -> GHC.Types.Bool
  isEOFError :: IOError -> GHC.Types.Bool
  isEOFErrorType :: IOErrorType -> GHC.Types.Bool
  isFullError :: IOError -> GHC.Types.Bool
  isFullErrorType :: IOErrorType -> GHC.Types.Bool
  isIllegalOperation :: IOError -> GHC.Types.Bool
  isIllegalOperationErrorType :: IOErrorType -> GHC.Types.Bool
  isPermissionError :: IOError -> GHC.Types.Bool
  isPermissionErrorType :: IOErrorType -> GHC.Types.Bool
  isResourceVanishedError :: IOError -> GHC.Types.Bool
  isResourceVanishedErrorType :: IOErrorType -> GHC.Types.Bool
  isUserError :: IOError -> GHC.Types.Bool
  isUserErrorType :: IOErrorType -> GHC.Types.Bool
  mkIOError :: IOErrorType -> GHC.Base.String -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.IO.FilePath -> IOError
  modifyIOError :: (IOError -> IOError) -> GHC.Types.IO a -> GHC.Types.IO a
  permissionErrorType :: IOErrorType
  resourceVanishedErrorType :: IOErrorType
  tryIOError :: GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either IOError a)
  userError :: GHC.Base.String -> IOError
  userErrorType :: IOErrorType

module System.IO.Unsafe where
  unsafeDupablePerformIO :: GHC.Types.IO a -> a
  unsafeFixIO :: (a -> GHC.Types.IO a) -> GHC.Types.IO a
  unsafeInterleaveIO :: GHC.Types.IO a -> GHC.Types.IO a
  unsafePerformIO :: GHC.Types.IO a -> a

module System.Info where
  arch :: GHC.Base.String
  compilerName :: GHC.Base.String
  compilerVersion :: Data.Version.Version
  fullCompilerVersion :: Data.Version.Version
  os :: GHC.Base.String

module System.Mem where
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  performGC :: GHC.Types.IO ()
  performMajorGC :: GHC.Types.IO ()
  performMinorGC :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()

module System.Mem.StableName where
  type role StableName phantom
  type StableName :: * -> *
  data StableName a = ...
  eqStableName :: StableName a -> StableName b -> GHC.Types.Bool
  hashStableName :: StableName a -> GHC.Types.Int
  makeStableName :: a -> GHC.Types.IO (StableName a)

module System.Mem.Weak where
  type Weak :: * -> *
  data Weak v = ...
  addFinalizer :: key -> GHC.Types.IO () -> GHC.Types.IO ()
  deRefWeak :: Weak v -> GHC.Types.IO (GHC.Maybe.Maybe v)
  finalize :: Weak v -> GHC.Types.IO ()
  mkWeak :: k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak v)
  mkWeakPair :: k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak (k, v))
  mkWeakPtr :: k -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak k)

module System.Posix.Internals where
  type CFLock :: *
  data CFLock
  type CFilePath :: *
  type CFilePath = GHC.Foreign.CString
  type CGroup :: *
  data CGroup
  type CLconv :: *
  data CLconv
  type CPasswd :: *
  data CPasswd
  type CSigaction :: *
  data CSigaction
  type CSigset :: *
  data CSigset
  type CStat :: *
  data CStat
  type CTermios :: *
  data CTermios
  type CTm :: *
  data CTm
  type CTms :: *
  data CTms
  type CUtimbuf :: *
  data CUtimbuf
  type CUtsname :: *
  data CUtsname
  type FD :: *
  type FD = Foreign.C.Types.CInt
  c_access :: GHC.Foreign.CString -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_chmod :: GHC.Foreign.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_close :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_creat :: GHC.Foreign.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_dup :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_dup2 :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_lock :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Ptr.Ptr CFLock -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_read :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_write :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> Foreign.C.Types.CLong -> GHC.Types.IO Foreign.C.Types.CInt
  c_fork :: GHC.Types.IO System.Posix.Types.CPid
  c_fstat :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  c_ftruncate :: Foreign.C.Types.CInt -> System.Posix.Types.COff -> GHC.Types.IO Foreign.C.Types.CInt
  c_getpid :: GHC.Types.IO System.Posix.Types.CPid
  c_interruptible_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_interruptible_open_ :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_isatty :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_lflag :: GHC.Ptr.Ptr CTermios -> GHC.Types.IO System.Posix.Types.CTcflag
  c_link :: GHC.Foreign.CString -> GHC.Foreign.CString -> GHC.Types.IO Foreign.C.Types.CInt
  c_lseek :: Foreign.C.Types.CInt -> System.Posix.Types.COff -> Foreign.C.Types.CInt -> GHC.Types.IO System.Posix.Types.COff
  c_mkfifo :: GHC.Foreign.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_pipe :: GHC.Ptr.Ptr Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_read :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_s_isblk :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_ischr :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isdir :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isfifo :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isreg :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_issock :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_safe_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_safe_open_ :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_safe_read :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_safe_write :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_sigaddset :: GHC.Ptr.Ptr CSigset -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_sigemptyset :: GHC.Ptr.Ptr CSigset -> GHC.Types.IO Foreign.C.Types.CInt
  c_sigprocmask :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CSigset -> GHC.Ptr.Ptr CSigset -> GHC.Types.IO Foreign.C.Types.CInt
  c_stat :: CFilePath -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  c_tcgetattr :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO Foreign.C.Types.CInt
  c_tcsetattr :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO Foreign.C.Types.CInt
  c_umask :: System.Posix.Types.CMode -> GHC.Types.IO System.Posix.Types.CMode
  c_unlink :: GHC.Foreign.CString -> GHC.Types.IO Foreign.C.Types.CInt
  c_utime :: GHC.Foreign.CString -> GHC.Ptr.Ptr CUtimbuf -> GHC.Types.IO Foreign.C.Types.CInt
  c_waitpid :: System.Posix.Types.CPid -> GHC.Ptr.Ptr Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO System.Posix.Types.CPid
  c_write :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  const_echo :: Foreign.C.Types.CInt
  const_f_getfl :: Foreign.C.Types.CInt
  const_f_setfd :: Foreign.C.Types.CInt
  const_f_setfl :: Foreign.C.Types.CInt
  const_fd_cloexec :: Foreign.C.Types.CLong
  const_icanon :: Foreign.C.Types.CInt
  const_sig_block :: Foreign.C.Types.CInt
  const_sig_setmask :: Foreign.C.Types.CInt
  const_sigttou :: Foreign.C.Types.CInt
  const_tcsanow :: Foreign.C.Types.CInt
  const_vmin :: Foreign.C.Types.CInt
  const_vtime :: Foreign.C.Types.CInt
  dEFAULT_BUFFER_SIZE :: GHC.Types.Int
  fdFileSize :: FD -> GHC.Types.IO GHC.Num.Integer.Integer
  fdGetMode :: FD -> GHC.Types.IO GHC.IO.IOMode.IOMode
  fdStat :: FD -> GHC.Types.IO (GHC.IO.Device.IODeviceType, System.Posix.Types.CDev, System.Posix.Types.CIno)
  fdType :: FD -> GHC.Types.IO GHC.IO.Device.IODeviceType
  fileType :: GHC.IO.FilePath -> GHC.Types.IO GHC.IO.Device.IODeviceType
  getEcho :: FD -> GHC.Types.IO GHC.Types.Bool
  get_saved_termios :: Foreign.C.Types.CInt -> GHC.Types.IO (GHC.Ptr.Ptr CTermios)
  hostIsThreaded :: GHC.Types.Bool
  ioe_unknownfiletype :: GHC.IO.Exception.IOException
  lstat :: CFilePath -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  newFilePath :: GHC.IO.FilePath -> GHC.Types.IO GHC.Foreign.CString
  o_APPEND :: Foreign.C.Types.CInt
  o_BINARY :: Foreign.C.Types.CInt
  o_CREAT :: Foreign.C.Types.CInt
  o_EXCL :: Foreign.C.Types.CInt
  o_NOCTTY :: Foreign.C.Types.CInt
  o_NONBLOCK :: Foreign.C.Types.CInt
  o_RDONLY :: Foreign.C.Types.CInt
  o_RDWR :: Foreign.C.Types.CInt
  o_TRUNC :: Foreign.C.Types.CInt
  o_WRONLY :: Foreign.C.Types.CInt
  peekFilePath :: GHC.Foreign.CString -> GHC.Types.IO GHC.IO.FilePath
  peekFilePathLen :: GHC.Foreign.CStringLen -> GHC.Types.IO GHC.IO.FilePath
  poke_c_lflag :: GHC.Ptr.Ptr CTermios -> System.Posix.Types.CTcflag -> GHC.Types.IO ()
  ptr_c_cc :: GHC.Ptr.Ptr CTermios -> GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8)
  puts :: GHC.Base.String -> GHC.Types.IO ()
  rtsIsThreaded_ :: GHC.Types.Int
  sEEK_CUR :: Foreign.C.Types.CInt
  sEEK_END :: Foreign.C.Types.CInt
  sEEK_SET :: Foreign.C.Types.CInt
  s_isblk :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_ischr :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isdir :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isfifo :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isreg :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_issock :: System.Posix.Types.CMode -> GHC.Types.Bool
  setCloseOnExec :: FD -> GHC.Types.IO ()
  setCooked :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  setEcho :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  setNonBlockingFD :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  set_saved_termios :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO ()
  sizeof_sigset_t :: GHC.Types.Int
  sizeof_stat :: GHC.Types.Int
  sizeof_termios :: GHC.Types.Int
  st_dev :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CDev
  st_ino :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CIno
  st_mode :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CMode
  st_mtime :: GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CTime
  st_size :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.COff
  statGetType :: GHC.Ptr.Ptr CStat -> GHC.Types.IO GHC.IO.Device.IODeviceType
  tcSetAttr :: FD -> (GHC.Ptr.Ptr CTermios -> GHC.Types.IO a) -> GHC.Types.IO a
  withFilePath :: GHC.IO.FilePath -> (GHC.Foreign.CString -> GHC.Types.IO a) -> GHC.Types.IO a

module System.Posix.Types where

-- ignored


module System.Timeout where
  type Timeout :: *
  newtype Timeout = ...
  timeout :: GHC.Types.Int -> GHC.Types.IO a -> GHC.Types.IO (GHC.Maybe.Maybe a)

module Text.ParserCombinators.ReadP where
  (+++) :: ReadP a -> ReadP a -> ReadP a
  (<++) :: ReadP a -> ReadP a -> ReadP a
  type ReadP :: * -> *
  newtype ReadP a = ...
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
  chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  char :: GHC.Types.Char -> ReadP GHC.Types.Char
  choice :: [ReadP a] -> ReadP a
  count :: GHC.Types.Int -> ReadP a -> ReadP [a]
  endBy :: ReadP a -> ReadP sep -> ReadP [a]
  endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
  eof :: ReadP ()
  gather :: ReadP a -> ReadP (GHC.Base.String, a)
  get :: ReadP GHC.Types.Char
  look :: ReadP GHC.Base.String
  many :: ReadP a -> ReadP [a]
  many1 :: ReadP a -> ReadP [a]
  manyTill :: ReadP a -> ReadP end -> ReadP [a]
  munch :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Base.String
  munch1 :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Base.String
  option :: a -> ReadP a -> ReadP a
  optional :: ReadP a -> ReadP ()
  pfail :: ReadP a
  readP_to_S :: ReadP a -> ReadS a
  readS_to_P :: ReadS a -> ReadP a
  satisfy :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Types.Char
  sepBy :: ReadP a -> ReadP sep -> ReadP [a]
  sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
  skipMany :: ReadP a -> ReadP ()
  skipMany1 :: ReadP a -> ReadP ()
  skipSpaces :: ReadP ()
  string :: GHC.Base.String -> ReadP GHC.Base.String

module Text.ParserCombinators.ReadPrec where
  (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
  (<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
  type Prec :: *
  type Prec = GHC.Types.Int
  type ReadPrec :: * -> *
  newtype ReadPrec a = ...
  choice :: [ReadPrec a] -> ReadPrec a
  get :: ReadPrec GHC.Types.Char
  lift :: Text.ParserCombinators.ReadP.ReadP a -> ReadPrec a
  look :: ReadPrec GHC.Base.String
  minPrec :: Prec
  pfail :: ReadPrec a
  prec :: Prec -> ReadPrec a -> ReadPrec a
  readP_to_Prec :: (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a) -> ReadPrec a
  readPrec_to_P :: ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
  readPrec_to_S :: ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
  readS_to_Prec :: (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> ReadPrec a
  reset :: ReadPrec a -> ReadPrec a
  step :: ReadPrec a -> ReadPrec a

module Text.Printf where
  FieldFormat :: GHC.Maybe.Maybe GHC.Types.Int -> GHC.Maybe.Maybe GHC.Types.Int -> GHC.Maybe.Maybe FormatAdjustment -> GHC.Maybe.Maybe FormatSign -> GHC.Types.Bool -> GHC.Base.String -> GHC.Types.Char -> FieldFormat
  type FieldFormat :: *
  data FieldFormat = ...
  type FieldFormatter :: *
  type FieldFormatter = FieldFormat -> GHC.Show.ShowS
  type FormatAdjustment :: *
  data FormatAdjustment = ...
  FormatParse :: GHC.Base.String -> GHC.Types.Char -> GHC.Base.String -> FormatParse
  type FormatParse :: *
  data FormatParse = ...
  type FormatSign :: *
  data FormatSign = ...
  type HPrintfType :: * -> Constraint
  class HPrintfType t
    ...
  type IsChar :: * -> Constraint
  class IsChar c
    ...
  LeftAdjust :: FormatAdjustment
  type ModifierParser :: *
  type ModifierParser = GHC.Base.String -> FormatParse
  type PrintfArg :: * -> Constraint
  class PrintfArg a
    ...
  type PrintfType :: * -> Constraint
  class PrintfType t
    ...
  SignPlus :: FormatSign
  SignSpace :: FormatSign
  ZeroPad :: FormatAdjustment
  errorBadArgument :: a
  errorBadFormat :: GHC.Types.Char -> a
  errorMissingArgument :: a
  errorShortFormat :: a
  fmtAdjust :: FieldFormat -> GHC.Maybe.Maybe FormatAdjustment
  fmtAlternate :: FieldFormat -> GHC.Types.Bool
  fmtChar :: FieldFormat -> GHC.Types.Char
  fmtModifiers :: FieldFormat -> GHC.Base.String
  fmtPrecision :: FieldFormat -> GHC.Maybe.Maybe GHC.Types.Int
  fmtSign :: FieldFormat -> GHC.Maybe.Maybe FormatSign
  fmtWidth :: FieldFormat -> GHC.Maybe.Maybe GHC.Types.Int
  formatArg :: PrintfArg a => a -> FieldFormatter
  formatChar :: GHC.Types.Char -> FieldFormatter
  formatInt :: (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> FieldFormatter
  formatInteger :: GHC.Num.Integer.Integer -> FieldFormatter
  formatRealFloat :: GHC.Float.RealFloat a => a -> FieldFormatter
  formatString :: IsChar a => [a] -> FieldFormatter
  fpChar :: FormatParse -> GHC.Types.Char
  fpModifiers :: FormatParse -> GHC.Base.String
  fpRest :: FormatParse -> GHC.Base.String
  fromChar :: IsChar c => GHC.Types.Char -> c
  hPrintf :: HPrintfType r => GHC.IO.Handle.Types.Handle -> GHC.Base.String -> r
  parseFormat :: PrintfArg a => a -> ModifierParser
  perror :: GHC.Base.String -> a
  printf :: PrintfType r => GHC.Base.String -> r
  toChar :: IsChar c => c -> GHC.Types.Char
  vFmt :: GHC.Types.Char -> FieldFormat -> FieldFormat

module Text.Read where
  (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
  (<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
  Char :: GHC.Types.Char -> Lexeme
  EOF :: Lexeme
  Ident :: GHC.Base.String -> Lexeme
  type Lexeme :: *
  data Lexeme = ...
  Number :: Text.Read.Lex.Number -> Lexeme
  type Prec :: *
  type Prec = GHC.Types.Int
  Punc :: GHC.Base.String -> Lexeme
  type Read :: * -> Constraint
  class Read a
    ...
  type ReadPrec :: * -> *
  newtype ReadPrec a = ...
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  String :: GHC.Base.String -> Lexeme
  Symbol :: GHC.Base.String -> Lexeme
  choice :: [ReadPrec a] -> ReadPrec a
  get :: ReadPrec GHC.Types.Char
  lex :: ReadS GHC.Base.String
  lexP :: ReadPrec Lexeme
  lift :: Text.ParserCombinators.ReadP.ReadP a -> ReadPrec a
  look :: ReadPrec GHC.Base.String
  minPrec :: Prec
  parens :: ReadPrec a -> ReadPrec a
  pfail :: ReadPrec a
  prec :: Prec -> ReadPrec a -> ReadPrec a
  read :: Read a => GHC.Base.String -> a
  readEither :: Read a => GHC.Base.String -> Data.Either.Either GHC.Base.String a
  readList :: Read a => ReadS [a]
  readListDefault :: Read a => ReadS [a]
  readListPrec :: Read a => ReadPrec [a]
  readListPrecDefault :: Read a => ReadPrec [a]
  readMaybe :: Read a => GHC.Base.String -> GHC.Maybe.Maybe a
  readP_to_Prec :: (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a) -> ReadPrec a
  readParen :: GHC.Types.Bool -> ReadS a -> ReadS a
  readPrec :: Read a => ReadPrec a
  readPrec_to_P :: ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
  readPrec_to_S :: ReadPrec a -> GHC.Types.Int -> ReadS a
  readS_to_Prec :: (GHC.Types.Int -> ReadS a) -> ReadPrec a
  reads :: Read a => ReadS a
  readsPrec :: Read a => GHC.Types.Int -> ReadS a
  reset :: ReadPrec a -> ReadPrec a
  step :: ReadPrec a -> ReadPrec a

module Text.Read.Lex where
  Char :: GHC.Types.Char -> Lexeme
  EOF :: Lexeme
  Ident :: GHC.Base.String -> Lexeme
  type Lexeme :: *
  data Lexeme = ...
  Number :: Number -> Lexeme
  type Number :: *
  data Number = ...
  Punc :: GHC.Base.String -> Lexeme
  String :: GHC.Base.String -> Lexeme
  Symbol :: GHC.Base.String -> Lexeme
  expect :: Lexeme -> Text.ParserCombinators.ReadP.ReadP ()
  hsLex :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
  isSymbolChar :: GHC.Types.Char -> GHC.Types.Bool
  lex :: Text.ParserCombinators.ReadP.ReadP Lexeme
  lexChar :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
  numberToFixed :: GHC.Num.Integer.Integer -> Number -> GHC.Maybe.Maybe (GHC.Num.Integer.Integer, GHC.Num.Integer.Integer)
  numberToInteger :: Number -> GHC.Maybe.Maybe GHC.Num.Integer.Integer
  numberToRangedRational :: (GHC.Types.Int, GHC.Types.Int) -> Number -> GHC.Maybe.Maybe GHC.Real.Rational
  numberToRational :: Number -> GHC.Real.Rational
  readBinP :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readDecP :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readHexP :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readIntP :: GHC.Num.Num a => a -> (GHC.Types.Char -> GHC.Types.Bool) -> (GHC.Types.Char -> GHC.Types.Int) -> Text.ParserCombinators.ReadP.ReadP a
  readOctP :: (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a

module Text.Show where
  type Show :: * -> Constraint
  class Show a
    ...
  type ShowS :: *
  type ShowS = GHC.Base.String -> GHC.Base.String
  show :: Show a => a -> GHC.Base.String
  showChar :: GHC.Types.Char -> ShowS
  showList :: Show a => [a] -> ShowS
  showListWith :: (a -> ShowS) -> [a] -> ShowS
  showParen :: GHC.Types.Bool -> ShowS -> ShowS
  showString :: GHC.Base.String -> ShowS
  shows :: Show a => a -> ShowS
  showsPrec :: Show a => GHC.Types.Int -> a -> ShowS

module Text.Show.Functions where


module Type.Reflection where
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    ...
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    ...
  pattern App :: forall k2 (t :: k2). () => forall k1 (a :: k1 -> k2) (b :: k1). (t ~ a b) => TypeRep a -> TypeRep b -> TypeRep t
  pattern Con :: forall k (a :: k). () => base-4.18.0.0:Data.Typeable.Internal.NotApplication a => TyCon -> TypeRep a
  pattern Con' :: forall k (a :: k). () => base-4.18.0.0:Data.Typeable.Internal.NotApplication a => TyCon -> [SomeTypeRep] -> TypeRep a
  pattern Fun :: forall k (fun :: k). () => forall (r1 :: GHC.Types.RuntimeRep) (r2 :: GHC.Types.RuntimeRep) (arg :: TYPE r1) (res :: TYPE r2). (k ~ *, fun ~~ (arg -> res)) => TypeRep arg -> TypeRep res -> TypeRep fun
  HRefl :: forall {k1} (a :: k1). a :~~: a
  type Module :: *
  data Module = ...
  Refl :: forall {k} (a :: k). a :~: a
  SomeTypeRep :: forall k (a :: k). TypeRep a -> SomeTypeRep
  type SomeTypeRep :: *
  data SomeTypeRep where
    ...
  type TyCon :: *
  data TyCon = ...
  pattern TypeRep :: forall {k} (a :: k). () => Typeable a => TypeRep a
  type role TypeRep nominal
  type TypeRep :: forall k. k -> *
  data TypeRep a where
    ...
  type Typeable :: forall k. k -> Constraint
  class Typeable a
    ...
  eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> GHC.Maybe.Maybe (a :~~: b)
  moduleName :: Module -> GHC.Base.String
  modulePackage :: Module -> GHC.Base.String
  rnfModule :: Module -> ()
  rnfSomeTypeRep :: SomeTypeRep -> ()
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: forall {k} (a :: k). TypeRep a -> ()
  someTypeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> SomeTypeRep
  someTypeRepTyCon :: SomeTypeRep -> TyCon
  splitApps :: forall {k} (a :: k). TypeRep a -> (TyCon, [SomeTypeRep])
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  typeOf :: Typeable a => a -> TypeRep a
  typeRep :: forall {k} (a :: k). Typeable a => TypeRep a
  typeRepKind :: forall k (a :: k). TypeRep a -> TypeRep k
  typeRepTyCon :: forall {k} (a :: k). TypeRep a -> TyCon
  withTypeable :: forall k (a :: k) r. TypeRep a -> (Typeable a => r) -> r

module Type.Reflection.Unsafe where
  type KindRep :: *
  data KindRep = ...
  KindRepApp :: KindRep -> KindRep -> KindRep
  KindRepFun :: KindRep -> KindRep -> KindRep
  KindRepTYPE :: GHC.Types.RuntimeRep -> KindRep
  KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
  pattern KindRepTypeLit :: TypeLitSort -> GHC.Base.String -> KindRep
  KindRepTypeLitD :: TypeLitSort -> [GHC.Types.Char] -> KindRep
  KindRepTypeLitS :: TypeLitSort -> GHC.Prim.Addr# -> KindRep
  KindRepVar :: GHC.Types.KindBndr -> KindRep
  type TyCon :: *
  data TyCon = ...
  TypeLitChar :: TypeLitSort
  TypeLitNat :: TypeLitSort
  type TypeLitSort :: *
  data TypeLitSort = ...
  TypeLitSymbol :: TypeLitSort
  type role TypeRep nominal
  type TypeRep :: forall k. k -> *
  data TypeRep a where
    ...
  mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep a -> TypeRep b -> TypeRep (a b)
  mkTrCon :: forall k (a :: k). TyCon -> [base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep] -> TypeRep a
  mkTyCon :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Types.Int -> KindRep -> TyCon
  someTypeRepFingerprint :: base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -> GHC.Fingerprint.Type.Fingerprint
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConKindArgs :: TyCon -> GHC.Types.Int
  tyConKindRep :: TyCon -> KindRep
  typeRepFingerprint :: forall {k} (a :: k). TypeRep a -> GHC.Fingerprint.Type.Fingerprint

module Unsafe.Coerce where
  type role UnsafeEquality nominal nominal
  type UnsafeEquality :: forall {k}. k -> k -> *
  data UnsafeEquality a b where
    ...
  UnsafeRefl :: forall {k} (a :: k). UnsafeEquality a a
  unsafeCoerce :: a -> b
  unsafeCoerce# :: a -> b
  unsafeCoerceAddr :: a -> b
  unsafeCoerceUnlifted :: a -> b
  unsafeEqualityProof :: forall {k} (a :: k) (b :: k). UnsafeEquality a b


-- Instances:
instance GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance [safe] Control.Monad.IO.Class.MonadIO GHC.Types.IO -- Defined in ‘Control.Monad.IO.Class’
instance [safe] Data.Bifoldable1.Bifoldable1 (,) -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 ((,,) x) -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 ((,,,) x y) -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 ((,,,,) x y z) -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 Data.Semigroup.Arg -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 Data.Either.Either -- Defined in ‘Data.Bifoldable1’
instance GHC.TypeNats.KnownNat n => Data.Fixed.HasResolution n -- Defined in ‘Data.Fixed’
instance Data.Foldable1.Foldable1 ((,) a) -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Complex.Complex -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Ord.Down -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.First -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Functor.Identity.Identity -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Last -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Max -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Min -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 GHC.Base.NonEmpty -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 GHC.Generics.Par1 -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Solo -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Foldable1’
instance [safe] Data.Functor.Classes.Eq2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Classes.Eq a => Data.Functor.Classes.Eq2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Classes.Ord a => Data.Functor.Classes.Ord2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Read.Read a => Data.Functor.Classes.Read2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Show.Show a => Data.Functor.Classes.Show2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance Control.Category.Category (Data.Type.Equality.:~:) -- Defined in ‘Control.Category’
instance Control.Category.Category (Data.Type.Equality.:~~:) -- Defined in ‘Control.Category’
instance Control.Category.Category Data.Type.Coercion.Coercion -- Defined in ‘Control.Category’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison -- Defined in ‘Data.Functor.Contravariant’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence -- Defined in ‘Data.Functor.Contravariant’
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a) -- Defined in ‘Data.Functor.Contravariant’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate -- Defined in ‘Data.Functor.Contravariant’
instance [safe] Control.Monad.Zip.MonadZip Data.Ord.Down -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Monoid.First -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Monoid.Last -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip [] -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Base.NonEmpty -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Generics.Par1 -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Solo -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Control.Monad.Zip’
instance Control.Monad.Zip.MonadZip Data.Complex.Complex -- Defined in ‘Data.Complex’
instance [safe] GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => Data.Functor.Classes.Eq1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => Data.Functor.Classes.Ord1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => Data.Functor.Classes.Read1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => Data.Functor.Classes.Show1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Bifoldable.Bifoldable (,) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable ((,,) x) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable ((,,,) x y) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable ((,,,,) x y z) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable ((,,,,,) x y z w) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v) -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable Data.Either.Either -- Defined in ‘Data.Bifoldable’
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance [safe] Data.Bifunctor.Bifunctor (,) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor ((,,) x1) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor ((,,,) x1 x2) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5) -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor Data.Either.Either -- Defined in ‘Data.Bifunctor’
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance Data.Bitraversable.Bitraversable (,) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable ((,,) x) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable ((,,,) x y) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable ((,,,,) x y z) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable Data.Either.Either -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance Data.Foldable.Foldable ((,) a) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable (GHC.Arr.Array i) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Ord.Down -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable (Data.Either.Either a) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Monoid.First -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Monoid.Last -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable [] -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Maybe.Maybe -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Base.NonEmpty -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Generics.Par1 -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Solo -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Complex.Complex -- Defined in ‘Data.Complex’
instance Data.Foldable.Foldable Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance Data.Foldable.Foldable (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Ord.Down -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix (Data.Either.Either e) -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Data.Monoid.First -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Types.IO -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Data.Monoid.Last -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix [] -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Base.NonEmpty -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Generics.Par1 -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix (GHC.ST.ST s) -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Solo -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance Control.Monad.Fix.MonadFix Data.Complex.Complex -- Defined in ‘Data.Complex’
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance Control.Monad.Fix.MonadFix Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable ((,) a) -- Defined in ‘Data.Traversable’
instance GHC.Ix.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i) -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Ord.Down -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable (Data.Either.Either a) -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Monoid.First -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Functor.Identity.Identity -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Monoid.Last -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable [] -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Maybe.Maybe -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Base.NonEmpty -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Generics.Par1 -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Solo -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Control.Applicative.ZipList -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Complex.Complex -- Defined in ‘Data.Complex’
instance Data.Traversable.Traversable (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance forall a k (b :: k). Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b) -- Defined in ‘Data.String’
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a) -- Defined in ‘Data.String’
instance (a ~ GHC.Types.Char) => Data.String.IsString [a] -- Defined in ‘Data.String’
instance forall a k (b :: k). GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits GHC.Types.Bool -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Types.Int -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Num.Integer.Integer -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Num.Natural.Natural -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Types.Word -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Bits.Bits GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Bits.Bits GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Bits.Bits Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a k (b :: k). GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Bool -- Defined in ‘GHC.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Int -- Defined in ‘GHC.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Word -- Defined in ‘GHC.Bits’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Bits.FiniteBits GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Bits.FiniteBits GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Bits.FiniteBits Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a k (b :: k). GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.Integral GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Types.Int -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Num.Integer.Integer -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Num.Natural.Natural -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Types.Word -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Integral Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance Data.Data.Data Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance base-4.18.0.0:Data.Typeable.Internal.Typeable s => Data.Data.Data (Data.Array.Byte.MutableByteArray s) -- Defined in ‘Data.Array.Byte’
instance Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance Data.Data.Data () -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g) -- Defined in ‘Data.Data’
instance forall i j (a :: i) (b :: j). (base-4.18.0.0:Data.Typeable.Internal.Typeable i, base-4.18.0.0:Data.Typeable.Internal.Typeable j, base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable b, a ~~ b) => Data.Data.Data (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Data’
instance Data.Data.Data base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘Data.Data’
instance Data.Data.Data base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b, GHC.Ix.Ix a) => Data.Data.Data (GHC.Arr.Array a b) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.Associativity -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Bool -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Char -- Defined in ‘Data.Data’
instance forall k a (b :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data a, base-4.18.0.0:Data.Typeable.Internal.Typeable b) => Data.Data.Data (Data.Functor.Const.Const a b) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.DecidedStrictness -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Double -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Data.Ord.Down a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.First a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.Fixity -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Float -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Int -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int16 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int32 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int64 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int8 -- Defined in ‘Data.Data’
instance Data.Data.Data Foreign.Ptr.IntPtr -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Num.Integer.Integer -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.Last a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data [a] -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (GHC.Maybe.Maybe a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Num.Natural.Natural -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (GHC.Base.NonEmpty a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Ordering -- Defined in ‘Data.Data’
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.Par1 p) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (GHC.Ptr.Ptr a) -- Defined in ‘Data.Data’
instance (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Solo a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.SourceStrictness -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.SourceUnpackedness -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Data’
instance Data.Data.Data Data.Version.Version -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Base.Void -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Word -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word16 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word32 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word64 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word8 -- Defined in ‘Data.Data’
instance Data.Data.Data Foreign.Ptr.WordPtr -- Defined in ‘Data.Data’
instance (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable b, base-4.18.0.0:Data.Typeable.Internal.Typeable c, Data.Data.Data (a b c)) => Data.Data.Data (Control.Applicative.WrappedArrow a b c) -- Defined in ‘Data.Data’
instance (base-4.18.0.0:Data.Typeable.Internal.Typeable m, base-4.18.0.0:Data.Typeable.Internal.Typeable a, Data.Data.Data (m a)) => Data.Data.Data (Control.Applicative.WrappedMonad m a) -- Defined in ‘Data.Data’
instance Data.Data.Data a => Data.Data.Data (Control.Applicative.ZipList a) -- Defined in ‘Data.Data’
instance forall k (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable k, base-4.18.0.0:Data.Typeable.Internal.Typeable a) => Data.Data.Data (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k1, base-4.18.0.0:Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) => Data.Data.Data (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation -- Defined in ‘GHC.Exts’
instance GHC.IsList.IsList Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.IsList.IsList GHC.Stack.Types.CallStack -- Defined in ‘GHC.IsList’
instance GHC.IsList.IsList [a] -- Defined in ‘GHC.IsList’
instance GHC.IsList.IsList (GHC.Base.NonEmpty a) -- Defined in ‘GHC.IsList’
instance GHC.IsList.IsList Data.Version.Version -- Defined in ‘GHC.IsList’
instance GHC.IsList.IsList (Control.Applicative.ZipList a) -- Defined in ‘GHC.IsList’
instance forall a k (b :: k). GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Float.Floating GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Float.Floating GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Integral a => GHC.Real.Fractional (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.Fractional GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.Fractional GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Real.Real a => GHC.Real.Real (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance GHC.Real.Real a => GHC.Real.Real (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.Real GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Real.Real a => GHC.Real.Real (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Real GHC.Types.Int -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Num.Integer.Integer -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Num.Natural.Natural -- Defined in ‘GHC.Real’
instance GHC.Real.Integral a => GHC.Real.Real (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Types.Word -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Real.Real Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Real Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Real GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.Real GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Float.RealFloat GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Float.RealFloat GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Integral a => GHC.Real.RealFrac (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.RealFrac GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.RealFrac GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.GHCi.GHCiSandboxIO GHC.Types.IO -- Defined in ‘GHC.GHCi’
instance GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance forall a k (b :: k). GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Bounded GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (t :: k). GHC.Enum.Bounded (Data.Proxy.Proxy t) -- Defined in ‘Data.Proxy’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Enum.Bounded GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Bounded m => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Enum.Bounded GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Enum.Bounded GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Enum.Bounded () -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (a, b) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c) => GHC.Enum.Bounded (a, b, c) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d) => GHC.Enum.Bounded (a, b, c, d) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e) => GHC.Enum.Bounded (a, b, c, d, e) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f) => GHC.Enum.Bounded (a, b, c, d, e, f) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g) => GHC.Enum.Bounded (a, b, c, d, e, f, g) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Enum’
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n, GHC.Enum.Bounded o) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Bool -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Char -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Int -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Levity -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Ordering -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Solo a) -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.VecCount -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.VecElem -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Word -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance (GHC.TypeLits.KnownSymbol n, GHC.Generics.SingI f, GHC.Generics.SingI r) => GHC.Generics.Constructor (GHC.Generics.MetaCons n f r) -- Defined in ‘GHC.Generics’
instance (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol p, GHC.Generics.SingI nt) => GHC.Generics.Datatype (GHC.Generics.MetaData n m p nt) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (Data.Functor.Const.Const a) -- Defined in ‘Data.Functor.Const’
instance [safe] forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Product.Product f g) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g) -- Defined in ‘Data.Functor.Sum’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Monoid.Ap f) -- Defined in ‘Data.Monoid’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (base-4.18.0.0:Data.Semigroup.Internal.Alt f) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:*: g) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:+: g) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.K1 i c) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.M1 i c f) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 Data.Proxy.Proxy -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.Rec1 f) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 GHC.Generics.U1 -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec (GHC.Ptr.Ptr ())) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Char) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Double) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Float) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Int) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Word) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic1 GHC.Generics.V1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Monoid () -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (a, b) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monoid (a, b, c) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d) => GHC.Base.Monoid (a, b, c, d) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d, GHC.Base.Monoid e) => GHC.Base.Monoid (a, b, c, d, e) -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a) -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid [a] -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup a => GHC.Base.Monoid (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid GHC.Types.Ordering -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid a => GHC.Base.Monoid (Solo a) -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Conc.Sync.STM a) -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Base.Monoid Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance forall k (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Monoid (f (g a)) => GHC.Base.Monoid (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Monoid (f a), GHC.Base.Monoid (g a)) => GHC.Base.Monoid (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance GHC.Base.Monoid (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Monoid (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Monoid base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monoid base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monoid a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Monoid (f p), GHC.Base.Monoid (g p)) => GHC.Base.Monoid ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Monoid (f (g p)) => GHC.Base.Monoid ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance (GHC.Generics.Generic a, GHC.Base.Monoid (GHC.Generics.Rep a ())) => GHC.Base.Monoid (GHC.Generics.Generically a) -- Defined in ‘GHC.Generics’
instance forall k c i (p :: k). GHC.Base.Monoid c => GHC.Base.Monoid (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Base.Monoid p => GHC.Base.Monoid (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Monoid (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance (GHC.Generics.SingI mn, GHC.Generics.SingI su, GHC.Generics.SingI ss, GHC.Generics.SingI ds) => GHC.Generics.Selector (GHC.Generics.MetaSel mn su ss ds) -- Defined in ‘GHC.Generics’
instance GHC.Base.Semigroup () -- Defined in ‘GHC.Base’
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (a, b) -- Defined in ‘GHC.Base’
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c) => GHC.Base.Semigroup (a, b, c) -- Defined in ‘GHC.Base’
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d) => GHC.Base.Semigroup (a, b, c, d) -- Defined in ‘GHC.Base’
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d, GHC.Base.Semigroup e) => GHC.Base.Semigroup (a, b, c, d, e) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Types.IO a) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup [a] -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup GHC.Types.Ordering -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Solo a) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Conc.Sync.STM a) -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Base.Semigroup Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits a => GHC.Base.Semigroup (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance forall k (s :: k). GHC.Base.Semigroup (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Base.Semigroup (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance GHC.Base.Semigroup (Data.Foldable1.FromMaybe b) -- Defined in ‘Data.Foldable1’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Foldable1.JoinWith a) -- Defined in ‘Data.Foldable1’
instance GHC.Base.Semigroup (Data.Foldable1.NonEmptyDList a) -- Defined in ‘Data.Foldable1’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Semigroup (f (g a)) => GHC.Base.Semigroup (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Semigroup (f a), GHC.Base.Semigroup (g a)) => GHC.Base.Semigroup (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance GHC.Base.Semigroup (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Semigroup (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Semigroup base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Semigroup base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Base.Semigroup (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Semigroup (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monoid m => GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Semigroup (f p), GHC.Base.Semigroup (g p)) => GHC.Base.Semigroup ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Semigroup (f (g p)) => GHC.Base.Semigroup ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance (GHC.Generics.Generic a, GHC.Base.Semigroup (GHC.Generics.Rep a ())) => GHC.Base.Semigroup (GHC.Generics.Generically a) -- Defined in ‘GHC.Generics’
instance forall k c i (p :: k). GHC.Base.Semigroup c => GHC.Base.Semigroup (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Base.Semigroup p => GHC.Base.Semigroup (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.LeftAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NotAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.RightAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Types.False -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Types.True -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedLazy -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedStrict -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedUnpack -- Defined in ‘GHC.Generics’
instance (GHC.Generics.SingI a, GHC.TypeNats.KnownNat n) => GHC.Generics.SingI (GHC.Generics.InfixI a n) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.PrefixI -- Defined in ‘GHC.Generics’
instance forall a1 (a2 :: a1). GHC.Generics.SingI a2 => GHC.Generics.SingI (GHC.Maybe.Just a2) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Maybe.Nothing -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NoSourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceLazy -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceStrict -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NoSourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceNoUnpack -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceUnpack -- Defined in ‘GHC.Generics’
instance GHC.TypeLits.KnownSymbol a => GHC.Generics.SingI a -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Types.Bool -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.FixityI -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind a => GHC.Generics.SingKind (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Types.Symbol -- Defined in ‘GHC.Generics’
instance GHC.IO.BufferedIO.BufferedIO GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.IO.Device.IODevice GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.IO.Device.RawIO GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance forall a k (b :: k). GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Ix.Ix GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (s :: k). GHC.Ix.Ix (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Ix.Ix GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix () -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a, GHC.Ix.Ix b) => GHC.Ix.Ix (a, b) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3) => GHC.Ix.Ix (a1, a2, a3) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4) => GHC.Ix.Ix (a1, a2, a3, a4) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5) => GHC.Ix.Ix (a1, a2, a3, a4, a5) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE) -- Defined in ‘GHC.Ix’
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE, GHC.Ix.Ix aF) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF) -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Bool -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Char -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Int -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Num.Integer.Integer -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Num.Natural.Natural -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Ordering -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix a => GHC.Ix.Ix (Solo a) -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Base.Void -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Word -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix a => GHC.Ix.Ix (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Ix.Ix GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Ix.Ix Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Ix.Ix GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Ix.Ix GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance forall a k (b :: k). GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Enum GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance forall k (a :: k). GHC.Enum.Enum (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Enum.Enum GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance (GHC.Enum.Enum a, GHC.Enum.Bounded a, GHC.Classes.Eq a) => GHC.Enum.Enum (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Integral a => GHC.Enum.Enum (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Enum.Enum GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Enum.Enum Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Enum.Enum GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Enum.Enum () -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Bool -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Char -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Int -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Num.Integer.Integer -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Levity -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Num.Natural.Natural -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Ordering -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum a => GHC.Enum.Enum (Solo a) -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.VecCount -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.VecElem -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Word -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Enum.Enum GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.Enum.Enum GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Enum.Enum GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance forall a k (b :: k). Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance Foreign.Storable.Storable () -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Bool -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Char -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Double -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Float -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable (GHC.Ptr.FunPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Int -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int8 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable (GHC.Ptr.Ptr a) -- Defined in ‘Foreign.Storable’
instance (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable (GHC.Stable.StablePtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Word -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word8 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance forall a k (b :: k). GHC.Num.Num a => GHC.Num.Num (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Num.Num GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Num.Num (f a) => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Num.Num a => GHC.Num.Num (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Num.Num GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Num.Num Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Num.Num Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Num.Num GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Num.Num GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.Num.Num GHC.Types.Int -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Num.Integer.Integer -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Num.Natural.Natural -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Types.Word -- Defined in ‘GHC.Num’
instance GHC.StaticPtr.IsStatic GHC.StaticPtr.StaticPtr -- Defined in ‘GHC.StaticPtr’
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c) -- Defined in ‘Control.Applicative’
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a) -- Defined in ‘Control.Applicative’
instance GHC.Generics.Generic (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Generics.Generic (Control.Arrow.Kleisli m a b) -- Defined in ‘Control.Arrow’
instance GHC.Generics.Generic GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Generics.Generic (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Generics.Generic (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Generics.Generic (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance GHC.Generics.Generic (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Generics.Generic (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Generics.Generic base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance GHC.Generics.Generic (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Generics.Generic (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Generics.Generic (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Generics.Generic (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance [safe] GHC.Generics.Generic Data.Version.Version -- Defined in ‘Data.Version’
instance [safe] GHC.Generics.Generic GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Generics.Generic () -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Generics.Generic ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Types.Bool -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (Data.Ord.Down a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (Data.Either.Either a b) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Generics.Generic (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic [a] -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Types.Ordering -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (t :: k). GHC.Generics.Generic (Data.Proxy.Proxy t) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic (Solo a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Base.Void -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.RTS.Flags.CCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ConcFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DebugFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.GCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.MiscFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ParFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ProfFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.RTSFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.TickyFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.TraceFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Generics.Generic GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Classes.Ord GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Classes.Ord GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Classes.Ord Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Classes.Ord () -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a, b) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (a, b, c) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (a, b, c, d) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e) => GHC.Classes.Ord (a, b, c, d, e) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f) => GHC.Classes.Ord (a, b, c, d, e, f) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g) => GHC.Classes.Ord (a, b, c, d, e, f, g) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h) => GHC.Classes.Ord (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n, GHC.Classes.Ord o) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Bool -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Char -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Double -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Float -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Int -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord a => GHC.Classes.Ord [a] -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Ordering -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Solo a) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.TyCon -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Word -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Ord (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Classes.Ord base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Classes.Ord (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). GHC.Classes.Ord (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Ord (f (g a)) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Classes.Ord GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Maybe’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Ord base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Classes.Ord Data.Unique.Unique -- Defined in ‘Data.Unique’
instance [safe] GHC.Classes.Ord Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Classes.Ord GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance GHC.Classes.Ord (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Ord (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Ord Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Ord Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Ord (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance (GHC.Ix.Ix i, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Arr.Array i e) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Classes.Ord GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Classes.Ord GHC.Event.TimeOut.TimeoutKey -- Defined in ‘GHC.Event.TimeOut’
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Ord (GHC.Generics.Rep1 f a)) => GHC.Classes.Ord (GHC.Generics.Generically1 f a) -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Ord GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Classes.Ord GHC.Num.Integer.Integer -- Defined in ‘GHC.Num.Integer’
instance GHC.Classes.Ord GHC.Num.BigNat.BigNat -- Defined in ‘GHC.Num.BigNat’
instance GHC.Classes.Ord GHC.Num.Natural.Natural -- Defined in ‘GHC.Num.Natural’
instance GHC.Classes.Ord GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Ord GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Read.Read GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Read.Read () -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (a, b) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => GHC.Read.Read (a, b, c) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d) => GHC.Read.Read (a, b, c, d) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e) => GHC.Read.Read (a, b, c, d, e) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f) => GHC.Read.Read (a, b, c, d, e, f) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g) => GHC.Read.Read (a, b, c, d, e, f, g) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h) => GHC.Read.Read (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i) => GHC.Read.Read (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Read’
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n, GHC.Read.Read o) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Read’
instance (GHC.Ix.Ix a, GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (GHC.Arr.Array a b) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Bool -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Char -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Double -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Float -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Int -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Num.Integer.Integer -- Defined in ‘GHC.Read’
instance GHC.Read.Read Text.Read.Lex.Lexeme -- Defined in ‘GHC.Read’
instance GHC.Read.Read a => GHC.Read.Read [a] -- Defined in ‘GHC.Read’
instance GHC.Read.Read a => GHC.Read.Read (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Num.Natural.Natural -- Defined in ‘GHC.Read’
instance GHC.Read.Read a => GHC.Read.Read (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Ordering -- Defined in ‘GHC.Read’
instance (GHC.Real.Integral a, GHC.Read.Read a) => GHC.Read.Read (GHC.Real.Ratio a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read a => GHC.Read.Read (Solo a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Base.Void -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Word -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word16 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word32 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word64 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word8 -- Defined in ‘GHC.Read’
instance GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Read.Read (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (t :: k). GHC.Read.Read (Data.Proxy.Proxy t) -- Defined in ‘Data.Proxy’
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Read.Read (f (g a)) => GHC.Read.Read (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Read.Read GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Read.Read base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance [safe] GHC.Read.Read Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Read.Read Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Read.Read Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Read.Read GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Read.Read GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Read.Read GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Read.Read GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance GHC.Read.Read GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Read.Read GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance GHC.Read.Read GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SChar -- Defined in ‘GHC.TypeLits’
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SSymbol -- Defined in ‘GHC.TypeLits’
instance Data.Type.Coercion.TestCoercion GHC.TypeNats.SNat -- Defined in ‘GHC.TypeNats’
instance forall k (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a) -- Defined in ‘Data.Type.Coercion’
instance forall k1 k (a :: k1). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a) -- Defined in ‘Data.Type.Coercion’
instance Data.Type.Equality.TestEquality GHC.TypeLits.SChar -- Defined in ‘GHC.TypeLits’
instance Data.Type.Equality.TestEquality GHC.TypeLits.SSymbol -- Defined in ‘GHC.TypeLits’
instance Data.Type.Equality.TestEquality GHC.TypeNats.SNat -- Defined in ‘GHC.TypeNats’
instance forall k (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a) -- Defined in ‘Data.Type.Equality’
instance forall k1 k (a :: k1). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a) -- Defined in ‘Data.Type.Equality’
instance Data.Type.Equality.TestEquality base-4.18.0.0:Data.Typeable.Internal.TypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1). Data.Type.Equality.TestEquality f => Data.Type.Equality.TestEquality (Data.Functor.Compose.Compose f g) -- Defined in ‘Data.Functor.Compose’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AllocationLimitExceeded -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AssertionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnMVar -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnSTM -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.CompactionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.Deadlock -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.FixIOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.SomeAsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Exception.Type.SomeException -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Base.Void -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Exception.Type.Exception Control.Exception.Base.NestedAtomically -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMatchingContinuationPrompt -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMethodError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NonTermination -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.PatternMatchFail -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecConError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecSelError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecUpdError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.TypeError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Data.Dynamic.Dynamic -- Defined in ‘Data.Dynamic’
instance [safe] GHC.Exception.Type.Exception base-4.18.0.0:GHC.IO.Handle.Lock.Common.FileLockingNotSupported -- Defined in ‘base-4.18.0.0:GHC.IO.Handle.Lock.Common’
instance GHC.Exception.Type.Exception GHC.IOPort.IOPortException -- Defined in ‘GHC.IOPort’
instance [safe] GHC.Exception.Type.Exception System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Alternative Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Alternative GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Alternative [] -- Defined in ‘GHC.Base’
instance GHC.Base.Alternative GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Alternative GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Applicative Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Monoid a => GHC.Base.Applicative ((,) a) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Applicative ((,,) a b) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Applicative ((,,,) a b c) -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative [] -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative Solo -- Defined in ‘GHC.Base’
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Applicative GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Applicative (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance GHC.Base.Applicative (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Applicative Data.Complex.Complex -- Defined in ‘Data.Complex’
instance GHC.Base.Applicative (Data.Either.Either e) -- Defined in ‘Data.Either’
instance GHC.Base.Applicative Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Applicative Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Applicative Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative Data.Ord.Down -- Defined in ‘Data.Ord’
instance GHC.Base.Applicative Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Applicative GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Functor Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Functor ((,) a) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor ((,,,,) a b c d) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor ((,,,,,) a b c d e) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor ((,,,,,,) a b c d e f) -- Defined in ‘GHC.Base’
instance GHC.Base.Functor GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Functor [] -- Defined in ‘GHC.Base’
instance GHC.Base.Functor GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Functor GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Functor Solo -- Defined in ‘GHC.Base’
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Functor GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Functor Control.Exception.Handler -- Defined in ‘Control.Exception’
instance GHC.Base.Functor (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance GHC.Base.Functor (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Functor Data.Complex.Complex -- Defined in ‘Data.Complex’
instance GHC.Base.Functor (Data.Either.Either a) -- Defined in ‘Data.Either’
instance GHC.Base.Functor Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Functor Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Functor Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor Data.Ord.Down -- Defined in ‘Data.Ord’
instance GHC.Base.Functor (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor (GHC.Arr.Array i) -- Defined in ‘GHC.Arr’
instance GHC.Base.Functor GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Functor GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance [safe] GHC.Base.Functor System.Console.GetOpt.ArgDescr -- Defined in ‘System.Console.GetOpt’
instance [safe] GHC.Base.Functor System.Console.GetOpt.ArgOrder -- Defined in ‘System.Console.GetOpt’
instance [safe] GHC.Base.Functor System.Console.GetOpt.OptDescr -- Defined in ‘System.Console.GetOpt’
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance Control.Monad.Fail.MonadFail GHC.Types.IO -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail [] -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance GHC.Base.MonadPlus GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.MonadPlus [] -- Defined in ‘GHC.Base’
instance GHC.Base.MonadPlus GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Monoid a => GHC.Base.Monad ((,) a) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monad ((,,) a b) -- Defined in ‘GHC.Base’
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monad ((,,,) a b c) -- Defined in ‘GHC.Base’
instance GHC.Base.Monad GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Monad [] -- Defined in ‘GHC.Base’
instance GHC.Base.Monad GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Monad GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Monad Solo -- Defined in ‘GHC.Base’
instance Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Monad GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Monad (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance GHC.Base.Monad (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Monad Data.Complex.Complex -- Defined in ‘Data.Complex’
instance GHC.Base.Monad (Data.Either.Either e) -- Defined in ‘Data.Either’
instance GHC.Base.Monad Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Monad Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Monad Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad Data.Ord.Down -- Defined in ‘Data.Ord’
instance GHC.Base.Monad Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Monad GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance [safe] (a ~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a) -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.IsChar GHC.Types.Char -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Char -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Double -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Float -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Int -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int16 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int32 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int64 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int8 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Num.Integer.Integer -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.IsChar c => Text.Printf.PrintfArg [c] -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Num.Natural.Natural -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Word -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word16 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word32 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word64 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word8 -- Defined in ‘Text.Printf’
instance [safe] (a ~ ()) => Text.Printf.PrintfType (GHC.Types.IO a) -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.IsChar c => Text.Printf.PrintfType [c] -- Defined in ‘Text.Printf’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Classes.Eq GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Classes.Eq (Control.Concurrent.Chan.Chan a) -- Defined in ‘Control.Concurrent.Chan’
instance GHC.Classes.Eq (GHC.MVar.MVar a) -- Defined in ‘GHC.MVar’
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq (GHC.Conc.Sync.TVar a) -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.IOErrorType -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Classes.Eq GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Classes.Eq GHC.IO.MaskingState -- Defined in ‘GHC.IO’
instance GHC.Classes.Eq Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Classes.Eq (Data.Array.Byte.MutableByteArray s) -- Defined in ‘Data.Array.Byte’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Classes.Eq () -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a, b) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (a, b, c) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (a, b, c, d) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e) => GHC.Classes.Eq (a, b, c, d, e) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (a, b, c, d, e, f) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g) => GHC.Classes.Eq (a, b, c, d, e, f, g) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h) => GHC.Classes.Eq (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Classes’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Bool -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Char -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Double -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Float -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Int -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq a => GHC.Classes.Eq [a] -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Module -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Ordering -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Solo a) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.TrName -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.TyCon -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Word -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance GHC.Classes.Eq Data.Data.Constr -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.ConstrRep -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.DataRep -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.Fixity -- Defined in ‘Data.Data’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Eq (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Classes.Eq base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Classes.Eq (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). GHC.Classes.Eq (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Eq (f (g a)) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Classes.Eq (GHC.IORef.IORef a) -- Defined in ‘GHC.IORef’
instance GHC.Classes.Eq GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Maybe’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Eq base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Classes.Eq (GHC.STRef.STRef s a) -- Defined in ‘GHC.STRef’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Ord.OrderingI a b) -- Defined in ‘Data.Type.Ord’
instance GHC.Classes.Eq Data.Unique.Unique -- Defined in ‘Data.Unique’
instance [safe] GHC.Classes.Eq Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Classes.Eq GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance GHC.Classes.Eq (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Eq (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Eq Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Eq Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Eq (GHC.Stable.StablePtr a) -- Defined in ‘GHC.Stable’
instance GHC.Classes.Eq Foreign.C.Error.Errno -- Defined in ‘Foreign.C.Error’
instance GHC.Classes.Eq (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance (GHC.Ix.Ix i, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Arr.Array i e) -- Defined in ‘GHC.Arr’
instance GHC.Classes.Eq (GHC.Arr.STArray s i e) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Classes.Eq GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Manager.FdKey -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Manager.State -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Classes.Eq GHC.Event.TimeOut.TimeoutKey -- Defined in ‘GHC.Event.TimeOut’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.TimerManager.State -- Defined in ‘base-4.18.0.0:GHC.Event.TimerManager’
instance GHC.Classes.Eq GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Stack.Types’
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation -- Defined in ‘GHC.Exts’
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Eq (GHC.Generics.Rep1 f a)) => GHC.Classes.Eq (GHC.Generics.Generically1 f a) -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState -- Defined in ‘GHC.IO.Buffer’
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Eq GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn -- Defined in ‘GHC.IO.Handle’
instance GHC.Classes.Eq GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.Handle -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Classes.Eq GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance GHC.Classes.Eq (GHC.IOArray.IOArray i e) -- Defined in ‘GHC.IOArray’
instance GHC.Classes.Eq (GHC.IOPort.IOPort a) -- Defined in ‘GHC.IOPort’
instance GHC.Classes.Eq GHC.InfoProv.InfoProv -- Defined in ‘GHC.InfoProv’
instance GHC.Classes.Eq GHC.Num.Integer.Integer -- Defined in ‘GHC.Num.Integer’
instance GHC.Classes.Eq GHC.Num.BigNat.BigNat -- Defined in ‘GHC.Num.BigNat’
instance GHC.Classes.Eq GHC.Num.Natural.Natural -- Defined in ‘GHC.Num.Natural’
instance GHC.Classes.Eq (GHC.StableName.StableName a) -- Defined in ‘GHC.StableName’
instance GHC.Classes.Eq GHC.Stack.CloneStack.StackEntry -- Defined in ‘GHC.Stack.CloneStack’
instance GHC.Classes.Eq GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Eq GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance [safe] GHC.Classes.Eq System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance GHC.Classes.Eq Text.Read.Lex.Lexeme -- Defined in ‘Text.Read.Lex’
instance GHC.Classes.Eq Text.Read.Lex.Number -- Defined in ‘Text.Read.Lex’
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Show.Show GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.IO.Exception.AllocationLimitExceeded -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.AssertionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnMVar -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnSTM -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.CompactionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.Deadlock -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.FixIOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.IOErrorType -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.SomeAsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Show.Show GHC.Exception.Type.SomeException -- Defined in ‘GHC.Exception.Type’
instance GHC.Show.Show GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Show.Show GHC.IO.MaskingState -- Defined in ‘GHC.IO’
instance GHC.Show.Show Control.Exception.Base.NestedAtomically -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NoMatchingContinuationPrompt -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NoMethodError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NonTermination -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecConError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecSelError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecUpdError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.TypeError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Show.Show Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Show.Show GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance GHC.Show.Show () -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a, b) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (a, b, c) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (a, b, c, d) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e) => GHC.Show.Show (a, b, c, d, e) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f) => GHC.Show.Show (a, b, c, d, e, f) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g) => GHC.Show.Show (a, b, c, d, e, f, g) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h) => GHC.Show.Show (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i) => GHC.Show.Show (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Show’
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Bool -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Stack.Types.CallStack -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Char -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Int -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Num.Integer.Integer -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.KindRep -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Levity -- Defined in ‘GHC.Show’
instance GHC.Show.Show a => GHC.Show.Show [a] -- Defined in ‘GHC.Show’
instance GHC.Show.Show a => GHC.Show.Show (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Module -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Num.Natural.Natural -- Defined in ‘GHC.Show’
instance GHC.Show.Show a => GHC.Show.Show (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Ordering -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.RuntimeRep -- Defined in ‘GHC.Show’
instance GHC.Show.Show a => GHC.Show.Show (Solo a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TrName -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TyCon -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TypeLitSort -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.VecCount -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.VecElem -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Base.Void -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Word -- Defined in ‘GHC.Show’
instance GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance GHC.Show.Show Data.Data.Constr -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.ConstrRep -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.DataRep -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.DataType -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.Fixity -- Defined in ‘Data.Data’
instance forall k (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Show.Show (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Show.Show (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Show.Show base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Show.Show (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance GHC.Show.Show Data.Dynamic.Dynamic -- Defined in ‘Data.Dynamic’
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Show.Show (f (g a)) => GHC.Show.Show (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Show.Show GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Show.Show base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Show.Show GHC.Real.FractionalExponentBase -- Defined in ‘GHC.Real’
instance GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Ord.OrderingI a b) -- Defined in ‘Data.Type.Ord’
instance [safe] GHC.Show.Show Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Show.Show GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Show.Show (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance GHC.Show.Show (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance GHC.Show.Show (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Show.Show Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Show.Show Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Show.Show (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance (GHC.Ix.Ix a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (GHC.Arr.Array a b) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Show.Show GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Timeout -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Manager.FdKey -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Manager.State -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.TimerManager.State -- Defined in ‘base-4.18.0.0:GHC.Event.TimerManager’
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance GHC.Show.Show GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Show.Show GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode -- Defined in ‘GHC.IO.Encoding.Failure’
instance GHC.Show.Show GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.Show.Show GHC.IO.Handle.HandlePosn -- Defined in ‘GHC.IO.Handle’
instance GHC.Show.Show GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.Handle -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.HandleType -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance [safe] GHC.Show.Show base-4.18.0.0:GHC.IO.Handle.Lock.Common.FileLockingNotSupported -- Defined in ‘base-4.18.0.0:GHC.IO.Handle.Lock.Common’
instance GHC.Show.Show GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Show.Show GHC.RTS.Flags.CCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.GCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ParFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.IOPort.IOPortException -- Defined in ‘GHC.IOPort’
instance GHC.Show.Show GHC.InfoProv.InfoProv -- Defined in ‘GHC.InfoProv’
instance GHC.Show.Show GHC.Stack.CloneStack.StackEntry -- Defined in ‘GHC.Stack.CloneStack’
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo -- Defined in ‘GHC.StaticPtr’
instance GHC.Show.Show GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Show.Show GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance GHC.Show.Show (GHC.TypeLits.SChar c) -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show (GHC.TypeLits.SSymbol s) -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show (GHC.TypeNats.SNat n) -- Defined in ‘GHC.TypeNats’
instance GHC.Show.Show GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance [safe] GHC.Show.Show System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance GHC.Show.Show Text.Read.Lex.Lexeme -- Defined in ‘Text.Read.Lex’
instance GHC.Show.Show Text.Read.Lex.Number -- Defined in ‘Text.Read.Lex’
